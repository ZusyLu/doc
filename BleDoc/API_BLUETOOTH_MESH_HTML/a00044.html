<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Silicon Labs Bluetooth Mesh API: Bluetooth Mesh Stack Provisioner</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Silicon Labs Bluetooth Mesh API
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00044.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Bluetooth Mesh Stack Provisioner</div>  </div>
</div><!--header-->
<div class="contents">

<p>Bluetooth Mesh Stack Provisioner.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00045"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html">OOB Capabilities</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00046"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">sl_btmesh_evt_prov_initialized</a></td></tr>
<tr class="memdesc:a00046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provisioner is initialized and operational. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00047"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">sl_btmesh_evt_prov_provisioning_suspended</a></td></tr>
<tr class="memdesc:a00047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provisioning suspended. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00048"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00048.html">sl_btmesh_evt_prov_capabilities</a></td></tr>
<tr class="memdesc:a00048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provisioning capabilities message. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00049"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00049.html">sl_btmesh_evt_prov_provisioning_failed</a></td></tr>
<tr class="memdesc:a00049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provisioning a device failed. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html">sl_btmesh_evt_prov_device_provisioned</a></td></tr>
<tr class="memdesc:a00050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device provisioned successfully. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00051"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00051.html">sl_btmesh_evt_prov_unprov_beacon</a></td></tr>
<tr class="memdesc:a00051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unprovisioned beacon seen. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00052"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">sl_btmesh_evt_prov_oob_pkey_request</a></td></tr>
<tr class="memdesc:a00052"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Provisioner needs the OOB public key of the Device with given UUID. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00053"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html">sl_btmesh_evt_prov_oob_auth_request</a></td></tr>
<tr class="memdesc:a00053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the Provisioner with the device's output or static data using prov_oob_auth_rsp. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00054"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">sl_btmesh_evt_prov_oob_display_input</a></td></tr>
<tr class="memdesc:a00054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random OOB input data was generated and should be displayed to and input with the device. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00055"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html">sl_btmesh_evt_prov_ddb_list</a></td></tr>
<tr class="memdesc:a00055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provisioner's device database list entry. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00056"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">sl_btmesh_evt_prov_uri</a></td></tr>
<tr class="memdesc:a00056"><td class="mdescLeft">&#160;</td><td class="mdescRight">URI advertisement received from a nearby device. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00057"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">sl_btmesh_evt_prov_key_refresh_phase_update</a></td></tr>
<tr class="memdesc:a00057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key refresh phase change for a network key has occurred. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00058"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">sl_btmesh_evt_prov_key_refresh_node_update</a></td></tr>
<tr class="memdesc:a00058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key refresh phase change for a node has occurred. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00059"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00059.html">sl_btmesh_evt_prov_key_refresh_complete</a></td></tr>
<tr class="memdesc:a00059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key refresh for a network key has completed. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00060"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">sl_btmesh_evt_prov_add_ddb_entry_complete</a></td></tr>
<tr class="memdesc:a00060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adding a DDB entry has been completed. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00061"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">sl_btmesh_evt_prov_delete_ddb_entry_complete</a></td></tr>
<tr class="memdesc:a00061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleting a DDB entry has been completed. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00062"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">sl_btmesh_evt_prov_initialization_failed</a></td></tr>
<tr class="memdesc:a00062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provisioner has not been initialized successfully and is not operational. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaef002829d183ece261eab2e7b28679bc"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gaef002829d183ece261eab2e7b28679bc">sl_btmesh_prov_init</a> ()</td></tr>
<tr class="separator:gaef002829d183ece261eab2e7b28679bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd4b87a0693257ccb624e553ecc3240e"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gadd4b87a0693257ccb624e553ecc3240e">sl_btmesh_prov_scan_unprov_beacons</a> ()</td></tr>
<tr class="separator:gadd4b87a0693257ccb624e553ecc3240e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga651b792d1cb6a9bf64992fb25b98bd53"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga651b792d1cb6a9bf64992fb25b98bd53">sl_btmesh_prov_create_provisioning_session</a> (uint16_t netkey_index, <a class="el" href="a00020.html#a00211">uuid_128</a> uuid, uint8_t attention_timer_sec)</td></tr>
<tr class="separator:ga651b792d1cb6a9bf64992fb25b98bd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ecc8081c2ac8ef16b5c2c486cfe003a"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga5ecc8081c2ac8ef16b5c2c486cfe003a">sl_btmesh_prov_set_provisioning_suspend_event</a> (uint8_t status)</td></tr>
<tr class="separator:ga5ecc8081c2ac8ef16b5c2c486cfe003a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ca3ae9490cc41c93169ba2e959758d"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gac4ca3ae9490cc41c93169ba2e959758d">sl_btmesh_prov_provision_adv_device</a> (<a class="el" href="a00020.html#a00211">uuid_128</a> uuid)</td></tr>
<tr class="separator:gac4ca3ae9490cc41c93169ba2e959758d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d2796362f838ff0271fcc92014271c"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga09d2796362f838ff0271fcc92014271c">sl_btmesh_prov_provision_gatt_device</a> (<a class="el" href="a00020.html#a00211">uuid_128</a> uuid, uint8_t connection)</td></tr>
<tr class="separator:ga09d2796362f838ff0271fcc92014271c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e1d4fcbe7722c0a3d68cb3f0b0d3bd"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga03e1d4fcbe7722c0a3d68cb3f0b0d3bd">sl_btmesh_prov_continue_provisioning</a> (<a class="el" href="a00020.html#a00211">uuid_128</a> uuid)</td></tr>
<tr class="separator:ga03e1d4fcbe7722c0a3d68cb3f0b0d3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b59b8b384ed32642461d918e26a9e9c"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga1b59b8b384ed32642461d918e26a9e9c">sl_btmesh_prov_abort_provisioning</a> (<a class="el" href="a00020.html#a00211">uuid_128</a> uuid, uint8_t reason)</td></tr>
<tr class="separator:ga1b59b8b384ed32642461d918e26a9e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c05ba910aac5fe390a4212e82b79fd"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gae2c05ba910aac5fe390a4212e82b79fd">sl_btmesh_prov_set_device_address</a> (<a class="el" href="a00020.html#a00211">uuid_128</a> uuid, uint16_t address)</td></tr>
<tr class="separator:gae2c05ba910aac5fe390a4212e82b79fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420ed2df250d81b5aac94f602f30bfa2"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga420ed2df250d81b5aac94f602f30bfa2">sl_btmesh_prov_create_network</a> (uint16_t netkey_index, size_t key_len, const uint8_t *key)</td></tr>
<tr class="separator:ga420ed2df250d81b5aac94f602f30bfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf757502e92df10d3e8b7fbc031026fcf"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gaf757502e92df10d3e8b7fbc031026fcf">sl_btmesh_prov_create_appkey</a> (uint16_t netkey_index, uint16_t appkey_index, size_t key_len, const uint8_t *key, size_t max_application_key_size, size_t *application_key_len, uint8_t *application_key)</td></tr>
<tr class="separator:gaf757502e92df10d3e8b7fbc031026fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc5d865f9215aaab95a2dbc8c68c0197"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gacc5d865f9215aaab95a2dbc8c68c0197">sl_btmesh_prov_send_oob_pkey_response</a> (size_t pkey_len, const uint8_t *pkey)</td></tr>
<tr class="separator:gacc5d865f9215aaab95a2dbc8c68c0197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga215c71a58338df9f360ff384b5bb5389"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga215c71a58338df9f360ff384b5bb5389">sl_btmesh_prov_send_oob_auth_response</a> (size_t data_len, const uint8_t *data)</td></tr>
<tr class="separator:ga215c71a58338df9f360ff384b5bb5389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51cf70a32df1a84943bfc314baef1851"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga51cf70a32df1a84943bfc314baef1851">sl_btmesh_prov_set_oob_requirements</a> (<a class="el" href="a00020.html#a00211">uuid_128</a> uuid, uint8_t public_key, uint8_t auth_methods, uint16_t output_actions, uint16_t input_actions, uint8_t min_size, uint8_t max_size)</td></tr>
<tr class="separator:ga51cf70a32df1a84943bfc314baef1851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbb1625ebdc7c1f5e13b7e6c5c59a625"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gacbb1625ebdc7c1f5e13b7e6c5c59a625">sl_btmesh_prov_start_key_refresh</a> (uint16_t netkey_index, uint8_t num_appkeys, size_t appkey_indices_len, const uint8_t *appkey_indices)</td></tr>
<tr class="separator:gacbb1625ebdc7c1f5e13b7e6c5c59a625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga520859649c176ee70108dba46b6faffa"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga520859649c176ee70108dba46b6faffa">sl_btmesh_prov_get_key_refresh_exclusion</a> (uint16_t key, <a class="el" href="a00020.html#a00211">uuid_128</a> uuid, uint8_t *status)</td></tr>
<tr class="separator:ga520859649c176ee70108dba46b6faffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabedff9566e626d13fd7bee2e7b97ec0d"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gabedff9566e626d13fd7bee2e7b97ec0d">sl_btmesh_prov_set_key_refresh_exclusion</a> (uint16_t key, uint8_t status, <a class="el" href="a00020.html#a00211">uuid_128</a> uuid)</td></tr>
<tr class="separator:gabedff9566e626d13fd7bee2e7b97ec0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e479483cf5dd4b465eca3b30f15137e"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga2e479483cf5dd4b465eca3b30f15137e">sl_btmesh_prov_get_ddb_entry</a> (<a class="el" href="a00020.html#a00211">uuid_128</a> uuid, <a class="el" href="a00020.html#a00215">aes_key_128</a> *device_key, uint16_t *netkey_index, uint16_t *address, uint8_t *elements)</td></tr>
<tr class="separator:ga2e479483cf5dd4b465eca3b30f15137e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898cfc763539e0b31a92afed369e16c8"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga898cfc763539e0b31a92afed369e16c8">sl_btmesh_prov_delete_ddb_entry</a> (<a class="el" href="a00020.html#a00211">uuid_128</a> uuid)</td></tr>
<tr class="separator:ga898cfc763539e0b31a92afed369e16c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafab73afa0dabc2b21828ecd51bbbb857"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gafab73afa0dabc2b21828ecd51bbbb857">sl_btmesh_prov_add_ddb_entry</a> (<a class="el" href="a00020.html#a00211">uuid_128</a> uuid, <a class="el" href="a00020.html#a00215">aes_key_128</a> device_key, uint16_t netkey_index, uint16_t address, uint8_t elements)</td></tr>
<tr class="separator:gafab73afa0dabc2b21828ecd51bbbb857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b34525fe507e95b9160d4d4d3f46c73"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga5b34525fe507e95b9160d4d4d3f46c73">sl_btmesh_prov_list_ddb_entries</a> (uint16_t *count)</td></tr>
<tr class="separator:ga5b34525fe507e95b9160d4d4d3f46c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa179908d8e3cb3c99226437e4f52bbba"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gaa179908d8e3cb3c99226437e4f52bbba">sl_btmesh_prov_initialize_network</a> (uint16_t address, uint32_t ivi)</td></tr>
<tr class="separator:gaa179908d8e3cb3c99226437e4f52bbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc2a3a9b26e05e58ab16b0c4189271f1"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gafc2a3a9b26e05e58ab16b0c4189271f1">sl_btmesh_prov_get_key_refresh_appkey_exclusion</a> (uint16_t netkey_index, uint16_t appkey_index, <a class="el" href="a00020.html#a00211">uuid_128</a> uuid, uint8_t *status)</td></tr>
<tr class="separator:gafc2a3a9b26e05e58ab16b0c4189271f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27928cca1c9db91fd0f0a7131aca2416"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga27928cca1c9db91fd0f0a7131aca2416">sl_btmesh_prov_set_key_refresh_appkey_exclusion</a> (uint16_t netkey_index, uint16_t appkey_index, uint8_t status, <a class="el" href="a00020.html#a00211">uuid_128</a> uuid)</td></tr>
<tr class="separator:ga27928cca1c9db91fd0f0a7131aca2416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa964db0081ed9b1892d00b5c9239fbb4"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gaa964db0081ed9b1892d00b5c9239fbb4">sl_btmesh_prov_stop_scan_unprov_beacons</a> ()</td></tr>
<tr class="separator:gaa964db0081ed9b1892d00b5c9239fbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccf949f86c480bce0b969a3120faf17"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gafccf949f86c480bce0b969a3120faf17">sl_btmesh_prov_update_device_netkey_index</a> (<a class="el" href="a00020.html#a00211">uuid_128</a> uuid, uint16_t netkey_index)</td></tr>
<tr class="separator:gafccf949f86c480bce0b969a3120faf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d3e775608f4bf019537f461e5314e1d"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga2d3e775608f4bf019537f461e5314e1d">sl_btmesh_prov_suspend_key_refresh</a> (uint16_t netkey_index)</td></tr>
<tr class="separator:ga2d3e775608f4bf019537f461e5314e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bdf18e1e7a266d338ad5b52cd4ffc81"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga2bdf18e1e7a266d338ad5b52cd4ffc81">sl_btmesh_prov_resume_key_refresh</a> (uint16_t netkey_index)</td></tr>
<tr class="separator:ga2bdf18e1e7a266d338ad5b52cd4ffc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga576a59e58d0efed29bb3e8dfa4fb4301"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga576a59e58d0efed29bb3e8dfa4fb4301">sl_btmesh_prov_get_key_refresh_phase</a> (uint16_t netkey_index, uint8_t *phase)</td></tr>
<tr class="separator:ga576a59e58d0efed29bb3e8dfa4fb4301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae87cdaaa177f8f9ffd3e023f11581014"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gae87cdaaa177f8f9ffd3e023f11581014">sl_btmesh_prov_start_key_refresh_from_phase</a> (uint8_t phase, uint16_t netkey_index, uint8_t num_appkeys, size_t appkey_indices_len, const uint8_t *appkey_indices)</td></tr>
<tr class="separator:gae87cdaaa177f8f9ffd3e023f11581014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6699c2bd59a17cb2b3f2ad3d8bd1a727"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga6699c2bd59a17cb2b3f2ad3d8bd1a727">sl_btmesh_prov_flush_key_refresh_state</a> (uint16_t netkey_index)</td></tr>
<tr class="separator:ga6699c2bd59a17cb2b3f2ad3d8bd1a727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bc517c1ff1ca39a300d727fec9112db"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga9bc517c1ff1ca39a300d727fec9112db">sl_btmesh_prov_test_identity</a> (uint16_t address, uint16_t netkey_index, size_t data_len, const uint8_t *data, uint8_t *match)</td></tr>
<tr class="separator:ga9bc517c1ff1ca39a300d727fec9112db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Bluetooth Mesh Stack Provisioner. </p>
<p>Bluetooth mesh stack API for the embedded Provisioner</p>
<p>Commands in this class provision nodes in the mesh network and generate security keys for the network.</p>
<p><b>Initialization:</b></p><ul>
<li><a class="el" href="a00044.html#gaef002829d183ece261eab2e7b28679bc">sl_btmesh_prov_init</a></li>
<li><a class="el" href="a00046.html">sl_btmesh_evt_prov_initialized</a></li>
<li><a class="el" href="a00062.html">sl_btmesh_evt_prov_initialization_failed</a></li>
</ul>
<p><b>Provisioning a node:</b></p><ul>
<li><a class="el" href="a00044.html#gadd4b87a0693257ccb624e553ecc3240e">sl_btmesh_prov_scan_unprov_beacons</a> : Scan for unprovisioned device beacons</li>
<li><a class="el" href="a00044.html#gaa964db0081ed9b1892d00b5c9239fbb4">sl_btmesh_prov_stop_scan_unprov_beacons</a> : Stop scanning for unprovisioned device beacons</li>
<li><a class="el" href="a00051.html">sl_btmesh_evt_prov_unprov_beacon</a> : Unprovisioned device beacon seen</li>
<li><a class="el" href="a00056.html">sl_btmesh_evt_prov_uri</a> : URI advertisement seen</li>
<li><a class="el" href="a00044.html#ga651b792d1cb6a9bf64992fb25b98bd53">sl_btmesh_prov_create_provisioning_session</a> : Create provisioning session</li>
<li><a class="el" href="a00044.html#gac4ca3ae9490cc41c93169ba2e959758d">sl_btmesh_prov_provision_adv_device</a> : Provision a device over PB-ADV</li>
<li><a class="el" href="a00044.html#ga09d2796362f838ff0271fcc92014271c">sl_btmesh_prov_provision_gatt_device</a> : Provision a device over PB-GATT</li>
<li><a class="el" href="a00054.html">sl_btmesh_evt_prov_oob_display_input</a> : Request to display input out-of-band data to the user to input on the node</li>
<li><a class="el" href="a00052.html">sl_btmesh_evt_prov_oob_pkey_request</a> : Request for out-of-band public key of a node</li>
<li><a class="el" href="a00044.html#gacc5d865f9215aaab95a2dbc8c68c0197">sl_btmesh_prov_send_oob_pkey_response</a> : Provide stack with out-of-band public key of a node</li>
<li><a class="el" href="a00053.html">sl_btmesh_evt_prov_oob_auth_request</a> : Request for out-of-band authentication data of a node</li>
<li><a class="el" href="a00044.html#ga215c71a58338df9f360ff384b5bb5389">sl_btmesh_prov_send_oob_auth_response</a> : Provide stack with out-of-band authentication data of a node</li>
<li><a class="el" href="a00050.html">sl_btmesh_evt_prov_device_provisioned</a> : Device Provisioned</li>
<li><a class="el" href="a00049.html">sl_btmesh_evt_prov_provisioning_failed</a> : Provisioning a device failed</li>
</ul>
<p><b>Key Management</b></p><ul>
<li><a class="el" href="a00044.html#ga420ed2df250d81b5aac94f602f30bfa2">sl_btmesh_prov_create_network</a> : Create a new network key on the Provisioner</li>
<li><a class="el" href="a00044.html#gaf757502e92df10d3e8b7fbc031026fcf">sl_btmesh_prov_create_appkey</a> : Create a new application key on the Provisioner</li>
<li><a class="el" href="a00044.html#gacbb1625ebdc7c1f5e13b7e6c5c59a625">sl_btmesh_prov_start_key_refresh</a> : Start a key refresh procedure</li>
<li><a class="el" href="a00044.html#ga2d3e775608f4bf019537f461e5314e1d">sl_btmesh_prov_suspend_key_refresh</a> : Suspend an ongoing key refresh procedure</li>
<li><a class="el" href="a00044.html#ga2bdf18e1e7a266d338ad5b52cd4ffc81">sl_btmesh_prov_resume_key_refresh</a> : Resume a suspended key refresh procedure</li>
<li><a class="el" href="a00044.html#ga520859649c176ee70108dba46b6faffa">sl_btmesh_prov_get_key_refresh_exclusion</a> : Get node key refresh exclusion status</li>
<li><a class="el" href="a00044.html#gabedff9566e626d13fd7bee2e7b97ec0d">sl_btmesh_prov_set_key_refresh_exclusion</a> : Set node key refresh exclusion status</li>
<li><a class="el" href="a00044.html#ga576a59e58d0efed29bb3e8dfa4fb4301">sl_btmesh_prov_get_key_refresh_phase</a> : Get node key refresh phase</li>
<li><a class="el" href="a00044.html#gae87cdaaa177f8f9ffd3e023f11581014">sl_btmesh_prov_start_key_refresh_from_phase</a> : Start a key refresh procedure from the given phase</li>
</ul>
<p><b>Device Database</b></p><ul>
<li><a class="el" href="a00044.html#gafab73afa0dabc2b21828ecd51bbbb857">sl_btmesh_prov_add_ddb_entry</a> : Add a node to the device database</li>
<li><a class="el" href="a00044.html#ga898cfc763539e0b31a92afed369e16c8">sl_btmesh_prov_delete_ddb_entry</a> : Remove a node from the device database</li>
<li><a class="el" href="a00044.html#ga2e479483cf5dd4b465eca3b30f15137e">sl_btmesh_prov_get_ddb_entry</a> : Fetch node data from the device database</li>
<li><a class="el" href="a00044.html#ga5b34525fe507e95b9160d4d4d3f46c73">sl_btmesh_prov_list_ddb_entries</a> : Request a list of nodes in the device database</li>
<li><a class="el" href="a00055.html">sl_btmesh_evt_prov_ddb_list</a> : Device database list result</li>
<li><a class="el" href="a00044.html#gafccf949f86c480bce0b969a3120faf17">sl_btmesh_prov_update_device_netkey_index</a> : Update default network key index for a device database entry</li>
</ul>
<p>These commands are available only if the Provisioner functionality is compiled in the device. Otherwise, a "feature not implemented" error code will be returned for all functions in this class. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaef002829d183ece261eab2e7b28679bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef002829d183ece261eab2e7b28679bc">&#9670;&nbsp;</a></span>sl_btmesh_prov_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the Bluetooth mesh stack in the Provisioner role. Note that the result code of this command only indicates that the request to initialize has been accepted for processing. When initialization is completed successfully, a <a class="el" href="a00046.html">sl_btmesh_evt_prov_initialized</a> will be generated. On failed initialization a <a class="el" href="a00062.html">sl_btmesh_evt_prov_initialization_failed</a> event will be generated. Note that the application must wait for an event to be generated before executing further BGAPI commands.</p>
<p>This command must be issued before any other Bluetooth mesh stack commands. Note that the Bluetooth mesh stack can be initialized either in the Provisioner or the Node role, but not both.</p>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise.</dd></dl>
<p><b>Events</b> </p><ul>
<li><a class="el" href="a00046.html">sl_btmesh_evt_prov_initialized</a></li>
<li><a class="el" href="a00062.html">sl_btmesh_evt_prov_initialization_failed</a> </li>
</ul>

</div>
</div>
<a id="gadd4b87a0693257ccb624e553ecc3240e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd4b87a0693257ccb624e553ecc3240e">&#9670;&nbsp;</a></span>sl_btmesh_prov_scan_unprov_beacons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_scan_unprov_beacons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start scanning for unprovisioned device beacons.</p>
<p>Unprovisioned devices send out beacons containing their UUID. An <a class="el" href="a00051.html">sl_btmesh_evt_prov_unprov_beacon</a> will be generated for each beacon seen. Once the UUID of a device is known, the Provisioner may start provisioning the device with the <a class="el" href="a00044.html#ga651b792d1cb6a9bf64992fb25b98bd53">sl_btmesh_prov_create_provisioning_session</a> command.</p>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise.</dd></dl>
<p><b>Events</b> </p><ul>
<li><a class="el" href="a00051.html">sl_btmesh_evt_prov_unprov_beacon</a> </li>
</ul>

</div>
</div>
<a id="ga651b792d1cb6a9bf64992fb25b98bd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga651b792d1cb6a9bf64992fb25b98bd53">&#9670;&nbsp;</a></span>sl_btmesh_prov_create_provisioning_session()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_create_provisioning_session </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>attention_timer_sec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the provisioning session. After this command, it is possible to set the provisioning parameter with the following command:</p>
<ul>
<li><a class="el" href="a00044.html#ga5ecc8081c2ac8ef16b5c2c486cfe003a">sl_btmesh_prov_set_provisioning_suspend_event</a></li>
</ul>
<p>After all optional parameters have been set, the provisioning process is triggered by one of the following commands:</p>
<ul>
<li><a class="el" href="a00044.html#gac4ca3ae9490cc41c93169ba2e959758d">sl_btmesh_prov_provision_adv_device</a></li>
<li><a class="el" href="a00044.html#ga09d2796362f838ff0271fcc92014271c">sl_btmesh_prov_provision_gatt_device</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Index of the initial network key, which is sent to the device during provisioning </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attention_timer_sec</td><td>Attention timer value, in seconds, which indicates the time that the provisioned device should attract human attention</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga5ecc8081c2ac8ef16b5c2c486cfe003a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ecc8081c2ac8ef16b5c2c486cfe003a">&#9670;&nbsp;</a></span>sl_btmesh_prov_set_provisioning_suspend_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_set_provisioning_suspend_event </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set whether the provisioning can be suspended at a specified point while it is occurring. Currently, this can happen after reception on provisioning capabilities message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td><p class="starttd">State of <a class="el" href="a00047.html">sl_btmesh_evt_prov_provisioning_suspended</a> event</p>
<ul>
<li><b>0</b> No suspension during provisioning</li>
<li><b>1</b> Provisioning can be suspended while it is occurring </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise.</dd></dl>
<p><b>Events</b> </p><ul>
<li><a class="el" href="a00047.html">sl_btmesh_evt_prov_provisioning_suspended</a> </li>
</ul>

</div>
</div>
<a id="gac4ca3ae9490cc41c93169ba2e959758d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4ca3ae9490cc41c93169ba2e959758d">&#9670;&nbsp;</a></span>sl_btmesh_prov_provision_adv_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_provision_adv_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provision device over PB-ADV</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise.</dd></dl>
<p><b>Events</b> </p><ul>
<li><a class="el" href="a00050.html">sl_btmesh_evt_prov_device_provisioned</a></li>
<li><a class="el" href="a00049.html">sl_btmesh_evt_prov_provisioning_failed</a> </li>
</ul>

</div>
</div>
<a id="ga09d2796362f838ff0271fcc92014271c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09d2796362f838ff0271fcc92014271c">&#9670;&nbsp;</a></span>sl_btmesh_prov_provision_gatt_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_provision_gatt_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provision device over PB-GATT</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection</td><td>Connection handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise.</dd></dl>
<p><b>Events</b> </p><ul>
<li><a class="el" href="a00050.html">sl_btmesh_evt_prov_device_provisioned</a></li>
<li><a class="el" href="a00049.html">sl_btmesh_evt_prov_provisioning_failed</a></li>
<li><a class="el" href="a00048.html">sl_btmesh_evt_prov_capabilities</a> </li>
</ul>

</div>
</div>
<a id="ga03e1d4fcbe7722c0a3d68cb3f0b0d3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03e1d4fcbe7722c0a3d68cb3f0b0d3bd">&#9670;&nbsp;</a></span>sl_btmesh_prov_continue_provisioning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_continue_provisioning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Continue provisioning after the suspension indicated by <a class="el" href="a00047.html">sl_btmesh_evt_prov_provisioning_suspended</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the device being provisioned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga1b59b8b384ed32642461d918e26a9e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b59b8b384ed32642461d918e26a9e9c">&#9670;&nbsp;</a></span>sl_btmesh_prov_abort_provisioning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_abort_provisioning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abort provisioning. This command is typically used after the suspension indicated by <a class="el" href="a00047.html">sl_btmesh_evt_prov_provisioning_suspended</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the device being provisioned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reason</td><td>Reason for aborting. Values are as follows:<ul>
<li><b>1:</b> Invalid PDU</li>
<li><b>2:</b> Invalid PDU format</li>
<li><b>3:</b> Unexpected PDU</li>
<li><b>4:</b> Confirmation failed</li>
<li><b>5:</b> Out of resources</li>
<li><b>6:</b> Decryption failed</li>
<li><b>7:</b> Unexpected error</li>
<li><b>8:</b> Unable to assign address</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gae2c05ba910aac5fe390a4212e82b79fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2c05ba910aac5fe390a4212e82b79fd">&#9670;&nbsp;</a></span>sl_btmesh_prov_set_device_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_set_device_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the address for the device after the provisioning has been suspended, as indicated by <a class="el" href="a00047.html">sl_btmesh_evt_prov_provisioning_suspended</a> event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the device being provisioned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Unicast address to be assigned for the primary element of the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga420ed2df250d81b5aac94f602f30bfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga420ed2df250d81b5aac94f602f30bfa2">&#9670;&nbsp;</a></span>sl_btmesh_prov_create_network()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_create_network </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new network key on the Provisioner.</p>
<p>The created key can be deployed on a node using the <a class="el" href="a00099.html#ga114fb59ae466106565a96868d93880df">sl_btmesh_config_client_add_netkey</a> command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Index to use for network key. Allowed values are from 0x000 to 0xfff. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_len</td><td>Length of data in <code>key</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key value to use. Set to zero-length array to generate a random key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gaf757502e92df10d3e8b7fbc031026fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf757502e92df10d3e8b7fbc031026fcf">&#9670;&nbsp;</a></span>sl_btmesh_prov_create_appkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_create_appkey </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>appkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_application_key_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>application_key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>application_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new application key on the Provisioner.</p>
<p>An application key is always bound to a network key. In other words, the application key is only valid in the context of a particular network key. The selected network key must exist on the Provisioner (see <a class="el" href="a00044.html#ga420ed2df250d81b5aac94f602f30bfa2">sl_btmesh_prov_create_network</a> command).</p>
<p>The created application key can be deployed on a node using the <a class="el" href="a00099.html#ga53fc4c71ac44d78b2e3dd92a9bd47278">sl_btmesh_config_client_add_appkey</a> command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Index of the network key to which the application key will be bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appkey_index</td><td>Index to use for application key. Allowed values are from 0x000 to 0xfff. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_len</td><td>Length of data in <code>key</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key value to use; set to zero-length array to generate random key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_application_key_size</td><td>Size of output buffer passed in <code>application_key</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">application_key_len</td><td>On return, set to the length of output data written to <code>application_key</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">application_key</td><td>New application key. Ignore it if the result was non-zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gacc5d865f9215aaab95a2dbc8c68c0197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc5d865f9215aaab95a2dbc8c68c0197">&#9670;&nbsp;</a></span>sl_btmesh_prov_send_oob_pkey_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_send_oob_pkey_response </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pkey_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Respond to the prov_oob_pkey_request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pkey_len</td><td>Length of data in <code>pkey</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkey</td><td>Public Key read out-of-band</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga215c71a58338df9f360ff384b5bb5389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga215c71a58338df9f360ff384b5bb5389">&#9670;&nbsp;</a></span>sl_btmesh_prov_send_oob_auth_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_send_oob_auth_response </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Respond to the prov_oob_auth_request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_len</td><td>Length of data in <code>data</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Output or static OOB data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga51cf70a32df1a84943bfc314baef1851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51cf70a32df1a84943bfc314baef1851">&#9670;&nbsp;</a></span>sl_btmesh_prov_set_oob_requirements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_set_oob_requirements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>auth_methods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>output_actions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>input_actions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the OOB requirements for a device being provisioned. This command can be issued after <a class="el" href="a00044.html#ga651b792d1cb6a9bf64992fb25b98bd53">sl_btmesh_prov_create_provisioning_session</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the Device being provisioned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>The public key. Set to zero if the provisioning does not use OOB public Key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">auth_methods</td><td>Enum <a class="el" href="a00021.html#ga389ac994e5bbb78243889781c7602f73">sl_btmesh_node_auth_method_flag_t</a>. Allowed OOB authentication methods The value is a bitmap so that multiple methods can be supported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_actions</td><td>Enum <a class="el" href="a00021.html#ga0de3b582c7fe82c6c0c8ce4a2069b7a3">sl_btmesh_node_oob_output_action_flag_t</a>. Allowed OOB Output Action types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_actions</td><td>Enum <a class="el" href="a00021.html#gaca918867f31e2f6cdbe35cdd782722b1">sl_btmesh_node_oob_input_action_flag_t</a>. Allowed OOB Input Action types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_size</td><td>Minimum input/output OOB size. Values range from 0 (input/output OOB not used) to 8. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_size</td><td>Maximum input/output OOB size. Must be smaller than or equal to the minimum size. Values range from 0 (input/output OOB not used) to 8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gacbb1625ebdc7c1f5e13b7e6c5c59a625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbb1625ebdc7c1f5e13b7e6c5c59a625">&#9670;&nbsp;</a></span>sl_btmesh_prov_start_key_refresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_start_key_refresh </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num_appkeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>appkey_indices_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>appkey_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a key refresh procedure in the network.</p>
<p>A key refresh procedure updates a network key and, optionally, application keys associated with it in all nodes of the network except for excluded nodes. After the refresh procedure is complete, the old keys will be discarded. Therefore, the excluded nodes, which did not receive new keys will be shut out of the network at the completion of the procedure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Index of the network key to update </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_appkeys</td><td>Number of application keys to update; may be zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appkey_indices_len</td><td>Length of data in <code>appkey_indices</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appkey_indices</td><td>Indices of the application keys to update, represented as little endian two byte sequences. The array must contain num_appkeys indices and therefore 2*num_appkeys bytes total.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise.</dd></dl>
<p><b>Events</b> </p><ul>
<li><a class="el" href="a00058.html">sl_btmesh_evt_prov_key_refresh_node_update</a></li>
<li><a class="el" href="a00057.html">sl_btmesh_evt_prov_key_refresh_phase_update</a></li>
<li><a class="el" href="a00059.html">sl_btmesh_evt_prov_key_refresh_complete</a> </li>
</ul>

</div>
</div>
<a id="ga520859649c176ee70108dba46b6faffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga520859649c176ee70108dba46b6faffa">&#9670;&nbsp;</a></span>sl_btmesh_prov_get_key_refresh_exclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_get_key_refresh_exclusion </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check the key refresh exclusion status of a node. Excluded nodes do not participate in the key refresh procedure and can therefore be shut out of the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Network key index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the Device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Non-zero for excluded node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gabedff9566e626d13fd7bee2e7b97ec0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabedff9566e626d13fd7bee2e7b97ec0d">&#9670;&nbsp;</a></span>sl_btmesh_prov_set_key_refresh_exclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_set_key_refresh_exclusion </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the key refresh exclusion status of a node. Excluded nodes do not participate in the key refresh procedure and can therefore be shut out of the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Network key index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Non-zero for excluded node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the Device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga2e479483cf5dd4b465eca3b30f15137e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e479483cf5dd4b465eca3b30f15137e">&#9670;&nbsp;</a></span>sl_btmesh_prov_get_ddb_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_get_ddb_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html#a00215">aes_key_128</a> *&#160;</td>
          <td class="paramname"><em>device_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>netkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a Provisioner device database entry with a matching UUID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the Device to retrieve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">device_key</td><td>Device Key </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">netkey_index</td><td>Index of the network key with which the node was initially provisioned. Used for network-level encryption of Configuration Client messages. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">address</td><td>Unicast address of the primary element of the node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elements</td><td>Number of elements in the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga898cfc763539e0b31a92afed369e16c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga898cfc763539e0b31a92afed369e16c8">&#9670;&nbsp;</a></span>sl_btmesh_prov_delete_ddb_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_delete_ddb_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete the node information from the Provisioner database. Note that a successful result from this command only means the command has been accepted for processing. The status of the actual operation will be returned in the following event; application should not make new BGAPI requests until the event is received. Note also that this should be followed by a <a class="el" href="a00044.html#gacbb1625ebdc7c1f5e13b7e6c5c59a625">sl_btmesh_prov_start_key_refresh</a> updating the keys of the remaining nodes to make sure the deleted node is shut off from the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the node to delete</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise.</dd></dl>
<p><b>Events</b> </p><ul>
<li><a class="el" href="a00061.html">sl_btmesh_evt_prov_delete_ddb_entry_complete</a> </li>
</ul>

</div>
</div>
<a id="gafab73afa0dabc2b21828ecd51bbbb857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafab73afa0dabc2b21828ecd51bbbb857">&#9670;&nbsp;</a></span>sl_btmesh_prov_add_ddb_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_add_ddb_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html#a00215">aes_key_128</a>&#160;</td>
          <td class="paramname"><em>device_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new node entry to the Provisioner's device database. Note that a successful result from this command only means the command has been accepted for processing. The status of the actual operation will be returned in the following event; application should not make new BGAPI requests until the event is received. Note also that the device key, primary element address, and network key need to be deployed to the node being added to ensure it's configurable. See <a class="el" href="a00021.html#gae57746b683cba799cded9e83d9ecf0fe">sl_btmesh_node_set_provisioning_data</a> command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the node to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device_key</td><td>Device key value for the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Index of the network key the node will be used for configuration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Unicast address to allocate for the node's primary element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Number of elements the device has</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise.</dd></dl>
<p><b>Events</b> </p><ul>
<li><a class="el" href="a00060.html">sl_btmesh_evt_prov_add_ddb_entry_complete</a> </li>
</ul>

</div>
</div>
<a id="ga5b34525fe507e95b9160d4d4d3f46c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b34525fe507e95b9160d4d4d3f46c73">&#9670;&nbsp;</a></span>sl_btmesh_prov_list_ddb_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_list_ddb_entries </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List nodes known by this Provisioner. A number of <a class="el" href="a00055.html">sl_btmesh_evt_prov_ddb_list</a> events will be generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Number of events that will follow</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise.</dd></dl>
<p><b>Events</b> </p><ul>
<li><a class="el" href="a00055.html">sl_btmesh_evt_prov_ddb_list</a> </li>
</ul>

</div>
</div>
<a id="gaa179908d8e3cb3c99226437e4f52bbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa179908d8e3cb3c99226437e4f52bbba">&#9670;&nbsp;</a></span>sl_btmesh_prov_initialize_network()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_initialize_network </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ivi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the mesh network and assign the provisioner address and IV index for the network. If this command is not invoked prior to invoking <a class="el" href="a00044.html#ga420ed2df250d81b5aac94f602f30bfa2">sl_btmesh_prov_create_network</a>, the network will be initialized with default address and IV index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address to assign for provisioner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ivi</td><td>IV index of the network.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gafc2a3a9b26e05e58ab16b0c4189271f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc2a3a9b26e05e58ab16b0c4189271f1">&#9670;&nbsp;</a></span>sl_btmesh_prov_get_key_refresh_appkey_exclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_get_key_refresh_appkey_exclusion </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>appkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check the application key refresh exclusion status of a node. Nodes which are excluded for a given application key do not receive updates for that particular application key, but do participate in the key refresh procedure as a whole. This enables the Provisioner to set up and update restricted sets of application keys across nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Network key index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appkey_index</td><td>Application key index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the Device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Non-zero for excluded node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga27928cca1c9db91fd0f0a7131aca2416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27928cca1c9db91fd0f0a7131aca2416">&#9670;&nbsp;</a></span>sl_btmesh_prov_set_key_refresh_appkey_exclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_set_key_refresh_appkey_exclusion </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>appkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the application key refresh exclusion status of a node. Nodes which are excluded for a given application key do not receive updates for that particular application key, but do participate in the key refresh procedure as a whole. This enables the Provisioner to set up and update restricted sets of application keys across nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Network key index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appkey_index</td><td>Application key index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Non-zero for excluded node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gaa964db0081ed9b1892d00b5c9239fbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa964db0081ed9b1892d00b5c9239fbb4">&#9670;&nbsp;</a></span>sl_btmesh_prov_stop_scan_unprov_beacons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_stop_scan_unprov_beacons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop scanning for unprovisioned device beacons.</p>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gafccf949f86c480bce0b969a3120faf17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafccf949f86c480bce0b969a3120faf17">&#9670;&nbsp;</a></span>sl_btmesh_prov_update_device_netkey_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_update_device_netkey_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#a00211">uuid_128</a>&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update a node's entry in the Provisioner's device database by setting a new value to the netkey_index field. The netkey_index field is used to determine the network key to use when encrypting and decrypting configuration model messages to and from the node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Index of the network key used in configuring the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga2d3e775608f4bf019537f461e5314e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d3e775608f4bf019537f461e5314e1d">&#9670;&nbsp;</a></span>sl_btmesh_prov_suspend_key_refresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_suspend_key_refresh </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suspend an ongoing key refresh procedure.</p>
<p>Suspending a key refresh procedure means no further requests for updating keys or setting key refresh phase will be sent to the network by the Provisioner until the key refresh procedure is resumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Index of the network key identifying an ongoing key refresh procedure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga2bdf18e1e7a266d338ad5b52cd4ffc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bdf18e1e7a266d338ad5b52cd4ffc81">&#9670;&nbsp;</a></span>sl_btmesh_prov_resume_key_refresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_resume_key_refresh </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resume a suspended key refresh procedure.</p>
<p>By resuming a suspended key refresh procedure, the Provisioner will again start to send requests for updating keys or setting key refresh phase to the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Index of the network key identifying a suspended key refresh procedure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga576a59e58d0efed29bb3e8dfa4fb4301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga576a59e58d0efed29bb3e8dfa4fb4301">&#9670;&nbsp;</a></span>sl_btmesh_prov_get_key_refresh_phase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_get_key_refresh_phase </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the key refresh phase of an ongoing key refresh procedure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Index of the network key identifying an ongoing key refresh procedure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">phase</td><td>The current key refresh phase. Values are as follows:<ul>
<li>0: Normal operation (no ongoing key refresh)</li>
<li>1: First phase of key refresh procedure (key deployment)</li>
<li>2: Second phase of key refresh procedure (new key activation)</li>
<li>3: Third phase of key refresh procedure (old key deletion)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gae87cdaaa177f8f9ffd3e023f11581014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae87cdaaa177f8f9ffd3e023f11581014">&#9670;&nbsp;</a></span>sl_btmesh_prov_start_key_refresh_from_phase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_start_key_refresh_from_phase </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num_appkeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>appkey_indices_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>appkey_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a key refresh procedure from a non-default phase. Before calling this function, keys to be used in the key refresh procedure should have been specified by calling <a class="el" href="a00084.html#gaec1aa9c3e2e5b7f213b0017ea88190b6">sl_btmesh_test_prov_prepare_key_refresh</a> command.</p>
<p>Note that this command should not normally be used. It is intended only for resuming an interrupted key refresh procedure on a backup Provisioner when the original Provisioner, that started the key refresh procedure, is no longer available to complete the procedure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>Current key refresh phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Index of the network key identifying a key refresh procedure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_appkeys</td><td>Number of application keys to update; may be zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appkey_indices_len</td><td>Length of data in <code>appkey_indices</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appkey_indices</td><td>Indices of the application keys to update, represented as little endian two byte sequences. The array must contain num_appkeys indices and therefore 2*num_appkeys bytes total.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise.</dd></dl>
<p><b>Events</b> </p><ul>
<li><a class="el" href="a00058.html">sl_btmesh_evt_prov_key_refresh_node_update</a></li>
<li><a class="el" href="a00057.html">sl_btmesh_evt_prov_key_refresh_phase_update</a></li>
<li><a class="el" href="a00059.html">sl_btmesh_evt_prov_key_refresh_complete</a> </li>
</ul>

</div>
</div>
<a id="ga6699c2bd59a17cb2b3f2ad3d8bd1a727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6699c2bd59a17cb2b3f2ad3d8bd1a727">&#9670;&nbsp;</a></span>sl_btmesh_prov_flush_key_refresh_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_flush_key_refresh_state </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the key refresh state stored in persistent storage.</p>
<p>Note that this command should not normally be used. It is intended only for clearing stored key refresh state when a key refresh procedure has been suspended and will not be resumed, either because the network key has been deleted from all nodes or the responsibility for completing the key refresh has been moved to another Provisioner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Index of the network key identifying a key refresh procedure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga9bc517c1ff1ca39a300d727fec9112db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bc517c1ff1ca39a300d727fec9112db">&#9670;&nbsp;</a></span>sl_btmesh_prov_test_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_btmesh_prov_test_identity </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>netkey_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if data in the identity beacon matches the mesh device and network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Mesh address of the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">netkey_index</td><td>Network key index of the node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_len</td><td>Length of data in <code>data</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Contents of the identity beacon. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">match</td><td>- 0: Identity record did not match<ul>
<li>1: Identity record match</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
