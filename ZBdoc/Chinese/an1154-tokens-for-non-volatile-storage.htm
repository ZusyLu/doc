<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>AN1154: Using Tokens for Non-Volatile Data Storage</title><meta name="author" content="Silicon Labs"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 h1 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 24pt; }
 .s1 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 6pt; }
 .s2 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s3 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s4 { color: #D81E2A; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 h3 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 .p, p { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; margin:0pt; }
 .s5 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .a { color: #049; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s6 { color: #049; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s8 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s9 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s10 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; }
 h4 { color: #FFF; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s11 { color: #FFF; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 8pt; }
 .s12 { color: #FFF; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s13 { color: #FFF; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s14 { color: #231F20; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 7pt; }
 .s15 { color: #231F20; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; }
 h2 { color: #D91F2A; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 li {display: block; }
 #l2 {padding-left: 0pt;counter-reset: d1 1; }
 #l2> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 #l3 {padding-left: 0pt;counter-reset: d2 1; }
 #l3> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l3> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l4 {padding-left: 0pt; }
 #l4> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l5 {padding-left: 0pt;counter-reset: d3 1; }
 #l5> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l5> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l6 {padding-left: 0pt; }
 #l6> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l7 {padding-left: 0pt; }
 #l7> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l8 {padding-left: 0pt;counter-reset: d3 1; }
 #l8> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l8> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l9 {padding-left: 0pt; }
 #l9> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l10 {padding-left: 0pt; }
 #l10> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l11 {padding-left: 0pt;counter-reset: d2 1; }
 #l11> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l11> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l12 {padding-left: 0pt;counter-reset: i1 1; }
 #l12> li>*:first-child:before {counter-increment: i1; content: counter(i1, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l12> li:first-child>*:first-child:before {counter-increment: i1 0;  }
 #l13 {padding-left: 0pt;counter-reset: d3 1; }
 #l13> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l13> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l14 {padding-left: 0pt;counter-reset: d3 1; }
 #l14> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l14> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l15 {padding-left: 0pt;counter-reset: d4 1; }
 #l15> li>*:first-child:before {counter-increment: d4; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)"."counter(d4, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l15> li:first-child>*:first-child:before {counter-increment: d4 0;  }
 #l16 {padding-left: 0pt;counter-reset: d3 1; }
 #l16> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l16> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l17 {padding-left: 0pt;counter-reset: d4 1; }
 #l17> li>*:first-child:before {counter-increment: d4; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)"."counter(d4, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l17> li:first-child>*:first-child:before {counter-increment: d4 0;  }
 #l18 {padding-left: 0pt;counter-reset: d3 1; }
 #l18> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l18> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 li {display: block; }
 #l19 {padding-left: 0pt; }
 #l19> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 li {display: block; }
 #l20 {padding-left: 0pt;counter-reset: k1 1; }
 #l20> li>*:first-child:before {counter-increment: k1; content: counter(k1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l20> li:first-child>*:first-child:before {counter-increment: k1 0;  }
 li {display: block; }
 #l21 {padding-left: 0pt;counter-reset: l1 3; }
 #l21> li>*:first-child:before {counter-increment: l1; content: counter(l1, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l21> li:first-child>*:first-child:before {counter-increment: l1 0;  }
 #l22 {padding-left: 0pt;counter-reset: l2 6; }
 #l22> li>*:first-child:before {counter-increment: l2; content: counter(l1, decimal)"."counter(l2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l22> li:first-child>*:first-child:before {counter-increment: l2 0;  }
 #l23 {padding-left: 0pt;counter-reset: l3 1; }
 #l23> li>*:first-child:before {counter-increment: l3; content: counter(l1, decimal)"."counter(l2, decimal)"."counter(l3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l23> li:first-child>*:first-child:before {counter-increment: l3 0;  }
 li {display: block; }
 #l24 {padding-left: 0pt;counter-reset: i1 4; }
 #l24> li>*:first-child:before {counter-increment: i1; content: counter(i1, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l24> li:first-child>*:first-child:before {counter-increment: i1 0;  }
</style></head><body><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span><img width="126" height="62" alt="image" src="an1154-tokens-for-non-volatile-storage/Image_001.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-top: 4pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">AN1154: Using Tokens for Non-Volatile Data Storage</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="713" height="1" alt="image" src="an1154-tokens-for-non-volatile-storage/Image_002.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="199" height="1" alt="image" src="an1154-tokens-for-non-volatile-storage/Image_003.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">KEY POINTS</p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="200" height="1" alt="image" src="an1154-tokens-for-non-volatile-storage/Image_004.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l1"><li><p class="s2" style="padding-top: 4pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Defines tokens.</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Discusses dynamic token access.</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Explains manufacturing tokens.</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Describes default tokens.</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Details how to add a custom application dynamic token.</p></li></ul><p style="text-indent: 0pt;text-align: left;"/><p class="s3" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">This application note describes tokens and shows how to use them for non-volatile data storage in EmberZNet PRO and Silicon Labs Connect (part of the Flex SDK).</p><p class="s4" style="padding-bottom: 3pt;text-indent: 0pt;text-align: right;">Introduction</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="713" height="0" alt="image" src="an1154-tokens-for-non-volatile-storage/Image_005.png"/></span></p><ol id="l2"><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark0">Introduction</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">This application note explains how to use tokens for non-volatile data storage. First, the concept of tokens, different types of tokens, and how to categorize them from multiple perspectives is introduced. Then, practical instructions on how to create and access (that is, read and write) tokens from the application are provided.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">After reading this application note you should expect to understand what tokens are, why and when you would use them, and how to create and access them from certain types of applications, currently EmberZNet PRO and Silicon Labs Connect (part of the Flex SDK).</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">A new infrastructure was introduced with Gecko SDK Suite (GSDK) v3.x. As part of that infrastructure update, the HAL APIs used to access and manage tokens have been replaced with Token Manager APIs. Variances are noted throughout.</p></li><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark1">About Tokens</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l3"><li><p class="s5" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark2">Concept of Tokens</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">A token is an abstract data constant that has special persistent meaning for an application. Tokens are used to preserve certain impor- tant data across reboots and during power loss. These tokens are stored in non-volatile memory. A token has two parts: a token key and token data. The token key is a unique identifier that is used to store and retrieve the token data. In many cases, the word &quot;token&quot; is used quite loosely to mean the token key, the token data, or the combination of key and data. Usually it is clear from the context which meaning to use. In this application note, &quot;token&quot; always refers to the key + data pair.</p><p class="s6" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark27" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;">The rest of this section examines the categorization of tokens from a few different angles. The following figure is a conceptual illustra- tion of the “universe” of tokens, and how this application note relates to other documents on non-volatile data storage. Understanding the types of tokens is relevant to understanding how to create and use them, as described in Section </a><a href="#bookmark27" class="a">3. Creating and Accessing To- </a>kens<span style=" color: #000;">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 30pt;text-indent: 0pt;text-align: left;"><span><img width="697" height="284" alt="image" src="an1154-tokens-for-non-volatile-storage/Image_006.png"/></span></p><p class="s5" style="padding-top: 8pt;padding-left: 186pt;text-indent: 0pt;text-align: center;">Figure 2.1.  Non-volatile Data Storage and Tokens</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark3">Types of Tokens: Manufacturing Tokens and Dynamic Tokens</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Tokens are written differently depending on how they are going to be used.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Manufacturing tokens are written either only once or very infrequently during the lifetime of the chip, and they are stored at absolute addresses of the flash. For more information about manufacturing and token programming, refer to document <i>AN961: Bringing up Cus- tom Devices for the EFR32MG and EFR32FG Families.</i></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Dynamic tokens can be accessed (both read and written) frequently. They are stored in a dedicated area of the flash which uses a memory-rotation algorithm to prevent flash overuse. Silicon Labs offers three different dynamic token implementations: Simulated EE- PROM Version 1 (SimEEv1), Simulated EEPROM Version 2 (SimEEv2), and Third Generation Non-Volatile Memory (NVM3). For an overview of non-volatile data storage concepts and a description of the three implementations, see <i>UG103.7: Non-Volatile Data Storage Fundamentals</i>.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The fundamental purpose of the dynamic token system as compared to generic RAM usage is to allow the token data to persist across reboots and during power loss. By using the token key to identify the proper data, the application requesting the token data does not need to know the exact storage location of the data. This simplifies application design and code reuse.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Because EFR32 process technology does not offer an internal EEPROM, the storage mechanism for dynamic tokens is implemented to use a section of internal flash memory for stack and application token storage. For SimEEv1, the EFR32 Series 1 uses 8 kB of upper flash memory for non-volatile data storage. SimEEv2 requires 36 kB of upper flash storage. Using SimEEv2 requires a special key from Silicon Labs. The purpose of this is to prevent an unintended upgrade from Version 1 to Version 2. The only way to downgrade requires full data loss and upgrading might not retain every token. With NVM3, storage size is configurable from 3 flash pages on up.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Parts that use dynamic tokens to store non-volatile data have different levels of flash performance with respect to guaranteed erase cycles. EFR32 flash cells are qualified for a guaranteed 10,000 erase cycles. See the datasheet for your specific part in order to deter- mine the number of guaranteed erase cycles across voltage and temperature. Due to the limited erase cycles, the storage mechanism for dynamic tokens implements a wear-leveling algorithm that effectively extends the number of erase cycles for individual tokens.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Silicon Labs recommends that application designers familiarize themselves with the different dynamic token storage mechanisms, so that they design the application’s use of tokens for optimal flash erase cycles. Refer to document <i>AN703: Using Simulated EEPROM Version 1 and Version 2 for the EFR32 Series 1 SoC Platforms</i>, for more information about SimEEv1/v2. Note that SimEEv1/v2 are not implemented on EFR32 Series 2. Refer to <i>AN1135: Using Third Generation Non-Volatile Memory (NVM3) Data Storage </i>for more infor- mation about NVM3. If you are unsure where to start and are developing for EFR32, Silicon Labs recommends NVM3. NVM3 is more configurable (allows for better balance of token capacity versus reserved flash) and is compatible with DMP in case the application needs to go that way in the future. Here are some very general guidelines on the mechanisms’ distinguishing features:</p><ul id="l4"><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Simulated EEPROM version1: low data requirement, single protocol, EFR32 Series 1.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Simulated EEPROM version2: high data requirement, single protocol, EFR32 Series 1.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">NVM3: high data requirement, dynamic multi-protocol, EFR32 Series 2.</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l5"><li><p class="s5" style="padding-top: 5pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark4">Types of Dynamic Tokens: Basic Tokens and Indexed Tokens</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">There are two types of dynamic tokens, with the types distinguished by their format:</p><ul id="l6"><li><p class="s5" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Non-indexed or basic <span class="p">dynamic tokens. These can be thought of as a simple char variable type. They can be used to store an array, but if one element changes the entire array must be rewritten.</span></p><ul id="l7"><li><p style="padding-top: 2pt;padding-left: 48pt;text-indent: -9pt;text-align: left;">A counter token is a special type of non-indexed dynamic token meant to store a number that increments by 1 at a time.</p></li></ul></li><li><p class="s5" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Indexed <span class="p">dynamic tokens can be considered as a linked array of char variables where each element is expected to change inde- pendently of the others and therefore is stored internally as an independent token and accessed explicitly through the token API.</span></p></li></ul><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">More information on basic and indexed tokens can be found in <i>AN703: Using Simulated EEPROM Version 1 and Version 2 for the EFR32 Series 1 SoC Platforms </i>and <i>AN1135: Using Third Generation Non-Volatile Memory (NVM3) Data Storage</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s5" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark5">Types of Tokens: Default Tokens and Custom Tokens</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Depending on whether a token is provided by Silicon Labs as part of a networking protocol stack or created by a user, the tokens can also be categorized as default tokens or custom tokens.</p><ol id="l8"><li><p class="s5" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark6">Default Tokens</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The networking stack contains default tokens that are grouped by their software purpose:</p><ul id="l9"><li><p class="s5" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Manufacturing Tokens <span class="p">are set at manufacturing time and cannot be changed by the application.</span></p></li><li><p class="s5" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Stack Tokens <span class="p">are runtime configuration options set by the stack. These dynamic tokens should not be changed by the application.</span></p></li><li><p class="s5" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">Application Framework Tokens <span class="p">are application tokens used by the Application Framework and generated by AppBuilder in Con- nect v2.7.x and EmberZNet SDK v6.7.x/v6.8.x. These dynamic tokens should not be changed by the application after project gener- ation. Examples of these are ZCL attribute tokens and plugin tokens.</span></p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark7">Custom Tokens</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">In addition to default tokens, users can add these types of tokens specific to their application:</p><ul id="l10"><li><p class="s5" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Custom Manufacturing Tokens <span class="p">are defined by the user and set at manufacturing time.</span></p></li><li><p class="s5" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Custom Application Tokens <span class="p">are additional application tokens users may add to meet their unique application needs for non-vola- tile data storage.</span></p></li></ul></li></ol></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark8">Creating and Accessing Tokens</a><a name="bookmark27">&zwnj;</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Now that you understand what tokens are and a few ways they may be categorized depending on how you view them, you can learn how to use tokens. This includes knowing where to find default tokens, how to create new tokens, and how to read and potentially modify tokens. Keep in mind that methods may vary depending on the type of tokens involved.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l11"><li><p class="s5" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark9">Token Header Files</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">A token header file is simply a .h file that contains token definitions. Manufacturing tokens and dynamic tokens have separate token header files. There may be more than one header file in an application for dynamic tokens: one for stack tokens, variable number of application framework tokens, and possibly one for custom application tokens.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark10">Creating Dynamic Tokens</a><a name="bookmark28">&zwnj;</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Adding a dynamic token to the header file involves three steps:</p><ol id="l12"><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -8pt;text-align: left;">Define the token name.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -8pt;text-align: left;">Add any typedef needed for the token, if it is using an application-defined type.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -8pt;text-align: left;">Define the token storage.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The rest of this section looks at each of these steps one at a time.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l13"><li><p class="s5" style="padding-top: 6pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark11">Define the Token Name</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">When defining the name, do not prepend the word <span class="s8">TOKEN</span>. For SimEEv1/v2 dynamic tokens, use the word <span class="s8">CREATOR</span>:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">/**</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">* Custom Application Tokens</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">*/</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">// Define token names here</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">#define CREATOR_DEVICE_INSTALL_DATA (0x000A) #define CREATOR_HOURLY_TEMPERATURES (0x000B) #define CREATOR_LIFETIME_HEAT_CYCLES (0x000C)</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For NVM3 dynamic tokens, use the word <span class="s8">NVM3KEY</span>. Note that the example below assumes a Zigbee application. For a different stack, the NVM3 domain would be different. Note also that the <span class="s8">NVM3KEY </span>value for <span class="s8">HOURLY_TEMPERATURES </span>is set to a value where the subse- quent 0x7F values are unused because this is an indexed token. Refer to <i>AN1135: Using Third Generation Non-Volatile Memory (NVM3) Data Storage </i>for more information on NVM3 default instance key spaces and restrictions on selecting <span class="s8">NVM3KEY </span>values for in- dexed tokens.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">/**</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">* Custom Zigbee Application Tokens</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">*/</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">// Define token names here</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">#define NVM3KEY_DEVICE_INSTALL_DATA (NVM3KEY_DOMAIN_USER | 0x000A)</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">// This key is used for an indexed token and the subsequent 0x7F keys are also reserved #define NVM3KEY_HOURLY_TEMPERATURES (NVM3KEY_DOMAIN_USER | 0x1000)</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">#define NVM3KEY_LIFETIME_HEAT_CYCLES (NVM3KEY_DOMAIN_USER | 0x000C)</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">These examples define the token key and link it to a programmatic variable. The token names are actually <span class="s8">DEVICE_INSTALL_DATA, HOURLY_TEMPERATURES </span>and <span class="s8">LIFETIME_HEAT_CYCLES</span>, with different tags prepended to the beginning depending on the usage. Thus, they are referred to in the example code as <span class="s8">TOKEN_DEVICE_INSTALL_DATA</span>, and so on.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The token key values must be unique within this device. The token key is critical to linking application usage with the proper data. As such, a unique key should always be used when defining a new token or even changing the structure of an existing token. Always using a unique key guarantees a proper link between application and data. <span class="s8">CREATOR </span>code values are 16-bit and <span class="s8">NVM3KEY </span>code values are 20- bit. For SimEEv1/v2, the first bit is reserved for manufacturing tokens, stack tokens, and those application tokens defined by the appli- cation framework, so all custom tokens should have a token key less than 0x8000.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">For NVM3, custom application tokens should use the <span class="s8">NVM3KEY_DOMAIN_USER </span>range so they do not collide with the stack tokens in the</p><p class="s8" style="padding-left: 23pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">NVM3KEY_DOMAIN_ZIGBEE <span class="p">range.</span></p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark12">Define the Token Type</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">The token type can be either a built-in C data type or defined as a custom data structure using <span class="s8">typedef</span>. Note that the token type must be defined only in one place, as the compiler will complain if the same data structure is defined twice.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><a href="#bookmark28" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;">Each token in the code examples in Section </a><span style=" color: #049;">3.2 Creating Dynamic Tokens </span>is a different type; the <span class="s8">HOURLY_TEMPERATURES </span>and</p><p class="s8" style="padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: left;">LIFETIME_HEAT_CYCLES <span class="p">types are built-in types in C, while the </span>DEVICE_INSTALL_DATA <span class="p">type is a custom data structure:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">#ifdef DEFINETYPES</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">// Include or define any typedef for tokens here typedef struct {</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">int8u install_date[11] /** YYYY-mm-dd + NULL */</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">int8u room_number; /** The room where this device is installed */</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">} InstallationData_t; #endif //DEFINETYPES</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-top: 4pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark13">Define the Token Storage</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">After any custom types are defined, the token storage is defined. This informs the token management software about the tokens being defined. Each token, whether custom or default, gets its own entry in this part:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">#ifdef DEFINETOKENS</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">// Define the actual token storage information here DEFINE_BASIC_TOKEN(DEVICE_INSTALL_DATA,</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">InstallationData_t,</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">{0, {0,...}})</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">DEFINE_INDEXED_TOKEN(HOURLY_TEMPERATURES, int16u, HOURS_IN_DAY, {0,...}) DEFINE_COUNTER_TOKEN(LIFETIME_HEAT_CYCLES, int32u, 0}</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">#endif //DEFINETOKENS</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">The following expands on each step in this process.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">DEFINE_BASIC_TOKEN(DEVICE_INSTALL_DATA,</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">InstallationData_t,</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">{0, {0,...}})</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p class="s8" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">DEFINE_BASIC_TOKEN <span class="p">takes three arguments: the name (</span>DEVICE_INSTALL_DATA<span class="p">), the data type (</span>InstallationData_t<span class="p">), and the de- fault value of the token if it has never been written by the application (</span>{0, {0,...}}<span class="p">).</span></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The default value takes the same syntax as C default initializers. In this case, the first value (<span class="s8">room_number</span>) is initialized to 0, and the next value (<span class="s8">install_date</span>) is set to all 0s because the {0,...} syntax fills the remainder of the array with 0.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The syntax of <span class="s8">DEFINE_COUNTER_TOKEN </span>is identical to <span class="s8">DEFINE_BASIC_TOKEN</span>.</p><p class="s8" style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">DEFINE_INDEXED_TOKEN <span class="p">requires a length of the array—in this case, </span>HOURS_IN_DAY <span class="p">or 24. Its final argument is the default value of ev- ery element in the array. Again, in this case it is initialized to all 0s.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li></ol></li><li><p class="s5" style="padding-top: 5pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark14">Accessing Dynamic Tokens With HAL APIs</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Refer to this information if you are developing with any EmberZNet or Connect in GSDK v2.7x, and with EmberZNet in GSDK v3.0.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The networking stack provides a simple set of APIs for accessing token data. The APIs differ slightly depending on the type of the to- kens. The rest of this section discusses how to access tokens depending on the types. You can find the full documentation in the stack API Reference.</p><ol id="l14"><li><p class="s5" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark15">Accessing Basic (Non-indexed) Tokens</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The non-indexed/basic token API functions include:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">void halCommonGetToken(data, token) void halCommonSetToken(token, data)</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In this case, &#39;token&#39; is the token key, and &#39;data&#39; is the token data. Note that <span class="s8">halCommonGetToken() </span>and <span class="s8">halCommonSetToken() </span><a href="#bookmark29" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;">are gen- eral token APIs that can be used for both basic dynamic tokens and manufacturing tokens (see Section </a><a href="#bookmark29" class="a">3.5.1 Accessing Manufacturing </a><span style=" color: #049;">Tokens</span>).</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The following example explains the usage of these APIs. Assume an application needs to store configuration data at installation time. A basic token has been defined to use the token key <span class="s8">DEVICE_INSTALL_DATA </span>and the data structure looks like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">typedef struct {</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">int8u install_date[11] /** YYYY-mm-dd + NULL */</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">int8u room_number; /** The room where this device is installed */</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">} InstallationData_t;</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Then you can access it with a code snippet like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">InstallationData_t data;</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">// Read the stored token data halCommonGetToken(&amp;data, TOKEN_DEVICE_INSTALL_DATA);</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">// Set the local copy of the data to new values data.room_number = &lt; user input data &gt;</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">MEMCOPY(data.install_date, &lt; user input data&gt;, 0, sizeof(data.install_date));</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">// Update the stored token data with the new values halCommonSetToken(TOKEN_DEVICE_INSTALL_DATA, &amp;data);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l15"><li><p class="s5" style="padding-top: 4pt;padding-left: 56pt;text-indent: -32pt;text-align: left;"><a name="bookmark16">Accessing Counter Tokens</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">There is a special API to increment the counter token (which is a special type of non-indexed tokens):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 21pt;text-indent: 0pt;text-align: justify;"><span class="s9" style=" background-color: #D8D8D8;"> void halCommonIncrementCounterToken(token)                                                                       </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Note that although you can write the counter token with the common <span class="s8">halCommonSetToken() </span>call, doing so is inefficient and defeats the purpose of using a counter token.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The following example explains the usage of a counter token and the special API to increment the counter token. Counting the number of heating cycles a thermostat has initiated is a perfect use for a counter token. Assume it is named <span class="s8">LIFETIME_HEAT_CYCLES</span>, and it is an int32u data type.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">void requestHeatCycle(void) {</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">/// &lt; application logic to initiate heat cycle &gt; halCommonIncrementCounterToken(TOKEN_LIFETIME_HEAT_CYCLES);</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">int32u totalHeatCycles(void) { int32u heatCycles;</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">halCommonGetToken(&amp;heatCycles, TOKEN_LIFETIME_HEAT_CYCLES); return heatCycles;</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Note that to read a counter token, use <span class="s8">halCommonGetToken() </span>just as you would read a general basic token.</p></li></ol></li><li><p class="s5" style="padding-top: 8pt;padding-left: 51pt;text-indent: -27pt;text-align: left;"><a name="bookmark17">Accessing Indexed Tokens</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The indexed token API functions include:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">void halCommonGetIndexedToken(data, token, index) void halCommonSetIndexedToken(token, index, data)</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The following example explains the usage of these APIs for an indexed token. To store a set of similar values, such as an array of preferred temperature settings throughout the day, use the default data type int16s to store the desired temperatures and define an indexed token called <span class="s8">HOURLY_TEMPERATURES</span>.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">A local copy of the entire data set would look like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 21pt;text-indent: 0pt;text-align: left;"><span class="s9" style=" background-color: #D8D8D8;"> int16s hourlyTemperatures[HOURS_IN_DAY]; /** 24 hours per day */                                                </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;">In the application code, you can access or update just one of the values in the day using the indexed token functions:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">int16s getCurrentTargetTemperature(int8u hour) {</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">int16s temperatureThisHour = 0; /** Stores the temperature for return */ if (hour &lt; HOURS_IN_DAY) { halCommonGetIndexedToken(&amp;temperatureThisHour, TOKEN_HOURLY_TEMPERATURES, hour);</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">return temperatureThisHour;</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">void setTargetTemperature(int8u hour, int16s targetTemperature) { if (hour &lt; HOURS_IN_DAY) { halCommonSetIndexedToken(TOKEN_HOURLY_TEMPERATURE, hour, &amp;temperatureThisHour);</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s5" style="padding-top: 4pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark18">Accessing Dynamic Tokens with Token Manager APIs</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Refer to this information if you are developing with Connect in GSDK v3.0.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The networking stack provides a simple set of APIs for accessing token data. The APIs differ slightly depending on the type of the to- kens. The rest of this section discusses how to access tokens depending on the types. You can find the full documentation in the stack API Reference.</p><ol id="l16"><li><p class="s5" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark19">Accessing Basic (Non-Indexed) Tokens</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The non-indexed/basic token API functions include:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">Ecode_t sl_token_get_data(uint32_t token, uint32_t index,</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">void *data, uint32_t length);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">Ecode_t sl_token_set_data(uint32_t token, uint32_t index,</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">void *data, uint32_t length);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">In this case, &#39;token&#39; is the token key, ‘index’ is 1 for non-indexed/basic tokens, &#39;data&#39; is the token data, and ‘length’ is the size in bytes of the data. Note that <span class="s8">sl_token_get_data() </span>and <span class="s8">sl_token_set_data() </span><a href="#bookmark29" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;">are specific for basic dynamic tokens. For manufacturing tokens see section </a><span style=" color: #049;">3.5.1 Accessing Manufacturing Tokens</span>.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The following example explains the usage of these APIs. Assume an application needs to store configuration data at installation time. A basic token has been defined to use the token key <span class="s8">DEVICE_INSTALL_DATA </span>and the data structure looks like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">typedef struct {</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">int8u install_date[11] /** YYYY-mm-dd + NULL */</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">int8u room_number; /** The room where this device is installed */</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">} InstallationData_t;</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Then you can access it with a code snippet like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">InstallationData_t data;</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">// Read the stored token data sl_token_get_data(TOKEN_DEVICE_INSTALL_DATA, 1, &amp;data, sizeof(data));</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">// Set the local copy of the data to new values data.room_number = &lt; user input data &gt; MEMCOPY(data.install_date, &lt; user input data&gt;, 0, sizeof(data.install_date));</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">// Update the stored token data with the new values sl_token_set_data(TOKEN_DEVICE_INSTALL_DATA, 1, &amp;data, sizeof(data));</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l17"><li><p class="s5" style="padding-top: 4pt;padding-left: 56pt;text-indent: -32pt;text-align: left;"><a name="bookmark20">Accessing Counter Tokens</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">There is a special API to increment the counter token (which is a special type of non-indexed tokens):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 21pt;text-indent: 0pt;text-align: justify;"><span class="s9" style=" background-color: #D8D8D8;"> Ecode_t sl_token_increment_counter(uint32_t token);                                                             </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Note that although you can write the counter token with the common <span class="s8">sl_token_set_data() </span>call, doing so is inefficient and defeats the purpose of using a counter token.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The following example explains the usage of a counter token and the special API to increment the counter token. Counting the number of heating cycles a thermostat has initiated is a perfect use for a counter token. Assume it is named <span class="s8">LIFETIME_HEAT_CYCLES</span>, and it is an int32u data type.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">void requestHeatCycle(void) {</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">/// &lt; application logic to initiate heat cycle &gt; sl_token_increment_counter(TOKEN_LIFETIME_HEAT_CYCLES);</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">int32u totalHeatCycles(void) {int32u heatCycles; sl_token_get_data(TOKEN_LIFETIME_HEAT_CYCLES, 1, &amp;heatCycles, sizeof(heatCycles)); return heatCycles;</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Note that to read a counter token, use <span class="s8">sl_token_get_data() </span>just as you would read a general basic token.</p></li></ol></li><li><p class="s5" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark21">Accessing Indexed Tokens</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The indexed token API functions are the same as the non-indexed/basic token API functions. The only difference is the ‘index’ parame- ter can be something other than 1.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The following example explains the usage of these APIs for an indexed token. To store a set of similar values, such as an array of preferred temperature settings throughout the day, use the default data type int16s to store the desired temperatures and define an indexed token called <span class="s8">HOURLY_TEMPERATURES</span>.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">A local copy of the entire data set would look like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 21pt;text-indent: 0pt;text-align: left;"><span class="s9" style=" background-color: #D8D8D8;"> int16s hourlyTemperatures[HOURS_IN_DAY]; /** 24 hours per day */                                                </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;">In the application code, you can access or update just one of the values in the day using the indexed token functions:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">int16s getCurrentTargetTemperature(int8u hour) {</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">int16s temperatureThisHour = 0; /** Stores the temperature for return */ if (hour &lt; HOURS_IN_DAY) {</p><p class="s8" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">sl_token_get_data(TOKEN_HOURLY_TEMPERATURES, hour, &amp;temperatureThisHour, sizeof(temperatureThisHour));</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">return temperatureThisHour;</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">void setTargetTemperature(int8u hour, int16s targetTemperature) { if (hour &lt; HOURS_IN_DAY) {</p><p class="s8" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">sl_token_set_data(TOKEN_HOURLY_TEMPERATURE, hour, &amp;temperatureThisHour, sizeof(temperatureThisHour));</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p class="s8" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s5" style="padding-top: 4pt;padding-left: 41pt;text-indent: -17pt;text-align: justify;"><a name="bookmark22">Manufacturing Tokens</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Manufacturing tokens are defined in a similar way as basic (non-indexed) dynamic tokens, but use the DEFINE_MFG_TOKEN in the manufacturing token header, instead of the other DEFINE_*_TOKEN macros. Note that the CREATOR_* prefix – not NVM3KEY_* - should always be used with manufacturing tokens, even when the NVM plugin is being used for non-volatile storage. Refer to section</p><p class="s6" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">3.2 Creating Dynamic Tokens <span style=" color: #000;">and to the API documentation on the DEFINE_MFG_TOKEN macro for more information.</span></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">There is a major difference, however, on where manufacturing tokens are stored and how they are accessed. Manufacturing tokens reside in the dedicated flash page for manufacturing tokens (with fixed absolute addresses). The rest of this section describes the nec- essary considerations for accessing manufacturing tokens.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l18"><li><p class="s5" style="padding-left: 49pt;text-indent: -25pt;text-align: justify;"><a name="bookmark23">Accessing Manufacturing Tokens</a><a name="bookmark29">&zwnj;</a></p></li></ol></li></ol></li></ol><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Manufacturing tokens, as the name suggests, are usually written once at manufacturing time into fixed locations in a dedicated flash page. Because their addresses are fixed, they can be easily read from external programming tools. Note, however, when the Read Protection feature has been enabled on the chip or on the dedicated flash page, manufacturing tokens can only be read from on-chip code.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Manufacturing tokens are not meant to be written often or from on-chip code, because they are at fixed locations. The same flash cell cannot be written repeatedly without erase operations in between. Writing a manufacturing token from on-chip code works only if the token is currently in an erased state. This means that manufacturing tokens can only be overwritten with external programming tools and not with on-chip code. Overwriting any manufacturing token that has been already written requires erasing the dedicated flash page for the manufacturing tokens. If Read Protection is enabled, it must be disabled first, which will erase the contents of the chip as a side effect. Manufacturing tokens are not wear-leveled so they should be overwritten sparingly.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Acess manufacturing tokens with their own dedicated APIs, which take the same parameters as the basic token APIs:</p><ul id="l19"><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">HAL: <span class="s8">halCommonGetMfgToken() </span>and <span class="s8">halCommonSetMfgToken()</span></p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">Token Manager: <span class="s8">sl_token_get_manufacturing_data() </span>and <span class="s8">sl_token_set_manufacturing_data()</span></p></li></ul><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">The two primary purposes for using the dedicated manufacturing token access APIs are:</p><ol id="l20"><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -8pt;text-align: left;">For slightly faster access;</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -8pt;text-align: left;">For access early in the boot process before <span class="s8">emberInit() </span>or <span class="s8">sl_token_init() </span>is called.</p></li></ol><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 11pt;text-align: left;">If you are using the HAL APIs, manufacturing tokens can also be accessed through the basic token APIs: <span class="s8">halCommonGetToken() </span>and</p><p class="s8" style="padding-left: 23pt;text-indent: 0pt;line-height: 11pt;text-align: left;">halCommonSetToken()<span class="p">.</span></p><ol id="l21"><ol id="l22"><li><p class="s5" style="padding-top: 8pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark24">Accessing Default and Custom Tokens</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l23"><li><p class="s5" style="padding-top: 5pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark25">Where to Find Default Token Definitions</a><a name="bookmark30">&zwnj;</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">To view the stack tokens, refer to the file:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 21pt;text-indent: 0pt;text-align: justify;"><span class="s10" style=" background-color: #D8D8D8;"> &lt;install-dir&gt;/stack/config/token-stack.h                                                                                        </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">To view the Application Framework tokens, refer to the file <span class="s8">&lt;project_name&gt;_tokens.h </span>and the protocol-specific token file (such as <span class="s8">znet-token.h) </span>under your project directory after the project has been generated in AppBuilder in Connect v2.7.x and EmberZNet SDK v6.7.x/v6.8.x SDKs. <span class="s8">&lt;project_name&gt;_tokens.h </span>contains tokens for ZCL attributes that the application has selected to be stored in non-volatile memory. The protocol-specific token file includes plugin token headers and the custom application token header.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">To view the manufacturing tokens for the EFR32 series of chips refer to the following files, respectively:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 21pt;text-indent: 0pt;text-align: justify;"><span class="s9" style=" background-color: #D8D8D8;"> &lt;install-dir&gt;/hal/micro/cortexm3/efm32/token-manufacturing.h                                                    </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Search for <span class="s8">CREATOR </span>to see the defined names. If the entire file seems overwhelming, focus only on the section describing the tokens. Some of the fixed manufacturing tokens may be set by the manufacturer when the board is created. For example, a custom EUI-64 address may be set by the vendor to override the internal EUI-64 address provided by Silicon Labs. Other tokens, such as the internal EUI-64, cannot be overwritten.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark26">Add Custom Tokens</a></p></li></ol></li></ol></ol><p class="s6" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark28" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;">Refer to Section </a>3.2 Creating Dynamic Tokens <a href="#bookmark30" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;">on the methods and APIs for creating custom tokens. You can also refer to the stack token definition file as mentioned near the top of Section </a>3.6.1 Where to Find Default Token Definitions <span style=" color: #000;">as a guide for creating custom application tokens.</span></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">After creating the tokens in a custom token header file, you need one more step: add the header file to the application by using the <b>Includes </b>tab in the .isc file in Simplicity Studio under the “Token Configuration” section. If you define both custom manufacturing tokens and custom application tokens, Silicon Labs recommends that you separate them into two different header files.</p><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;"><b>Note: </b>For custom token files, the inclusion guards (#ifndef) seen in <span class="s8">token-stack.h </span>should not be used.</p><p class="s4" style="padding-bottom: 3pt;text-indent: 0pt;text-align: right;">Token Manager Component</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="713" height="0" alt="image" src="an1154-tokens-for-non-volatile-storage/Image_007.png"/></span></p><ol id="l24"><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark31">Token Manager Component</a></h3></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">To use the Token Manager, the token_manager component (token_manager.slcc) should be added to the project. The token_manager component will default to using the token_manager_nvm3 component, which brings in the NVM3 system. Using NVM3 for storage is highly recommended.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">To use Simulated EEPROM v1 or v2 (SimEEv1, SimEEv2) for storage, the component token_manager_simee1 or token_manager_si- mee2 should be part of the project along with token_manager.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">To upgrade SimEEv2 to NVM3, the sim_eeprom2_to_nvm3_upgrade component should be used along with token_manager. This up- grade component will pull in the necessary SimEE and NVM3 code.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 17pt;text-indent: 0pt;text-align: left;">Smart. Connected. Energy-Friendly.</h4><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="text-indent: 0pt;line-height: 9pt;text-align: center;">Products</p><p style="text-indent: 0pt;text-align: center;"><a href="http://www.silabs.com/products" class="s12">www.silabs.com/products</a></p><p class="s11" style="text-indent: 0pt;line-height: 9pt;text-align: center;">Quality</p><p style="text-indent: 0pt;text-align: center;"><a href="http://www.silabs.com/quality" class="s12">www.silabs.com/quality</a></p><p class="s11" style="text-indent: 0pt;line-height: 9pt;text-align: center;">Support and Community</p><p class="s13" style="text-indent: 0pt;text-align: center;">community.silabs.com</p><p style="padding-left: 64pt;text-indent: 0pt;text-align: left;"><span style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt;">		</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="767" height="695" alt="image" src="an1154-tokens-for-non-volatile-storage/Image_008.png"/></span></p><p class="s14" style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Disclaimer</p><p class="s15" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Silicon Labs intends to provide customers with the latest, accurate, and in-depth documentation of all peripherals and modules available for system and software implementers using or intending to use the Silicon Labs products. Characterization data, available modules and peripherals, memory sizes and memory addresses refer to each specific device, and &quot;Typical&quot; parameters provided can and do vary in different applications. Application examples described herein are for illustrative purposes only. Silicon Labs reserves the right to make changes without further notice to the product information, specifications, and descriptions herein, and does not give warranties as to the accuracy or completeness of the included information. Without prior notification, Silicon Labs may update product firmware during the manufacturing process for security or reliability reasons. Such changes will not alter the specifications or the performance of the product. Silicon Labs shall have no liability for the consequences of use of the information supplied in this document. This document does not imply or expressly grant any license to design or fabricate any integrated circuits. The products are not designed or authorized to be used within any FDA Class III devices, applications for which FDA premarket approval is required, or Life Support Systems without the specific written consent of Silicon Labs. A &quot;Life Support System&quot; is any product or system intended to support or sustain life and/or health, which, if it fails, can be reasonably expected to result in significant personal injury or death. Silicon Labs products are not designed or authorized for military applications. Silicon Labs products shall under no circumstances be used in weapons of mass destruction including (but not limited to) nuclear, biological or chemical weapons, or missiles capable of delivering such weapons. Silicon Labs disclaims all express and implied warranties and shall not be responsible or liable for any injuries or damages related to use of a Silicon Labs product in such unauthorized applications.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Trademark Information</p><p class="s15" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Silicon Laboratories Inc.®, Silicon Laboratories®, Silicon Labs®, SiLabs® and the Silicon Labs logo®, Bluegiga®, Bluegiga Logo®, ClockBuilder®, CMEMS®, DSPLL®, EFM®, EFM32®, EFR, Ember®, Energy Micro, Energy Micro logo and combinations thereof, &quot;the world’s most energy friendly microcontrollers&quot;, Ember®, EZLink®, EZRadio®, EZRadioPRO®, Gecko®, Gecko OS, Gecko OS Studio, ISOmodem®, Precision32®, ProSLIC®, Simplicity Studio®, SiPHY®, Telegesis, the Telegesis Logo®, USBXpress® , Zentri, the Zentri logo and Zentri DMS, Z- Wave®, and others are trademarks or registered trademarks of Silicon Labs. ARM, CORTEX, Cortex-M3 and THUMB are trademarks or registered trademarks of ARM Holdings. Keil is a registered trademark of ARM Limited. Wi-Fi is a registered trademark of the Wi-Fi Alliance. All other products or brand names mentioned herein are trademarks of their respective holders.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="152" height="75" alt="image" src="an1154-tokens-for-non-volatile-storage/Image_009.png"/></span></p><p class="s14" style="padding-left: 168pt;text-indent: 0pt;text-align: left;">Silicon Laboratories Inc. 400 West Cesar Chavez Austin, TX 78701</p><p class="s14" style="padding-left: 168pt;text-indent: 0pt;text-align: left;">USA</p><p style="padding-top: 5pt;padding-left: 168pt;text-indent: 0pt;text-align: left;"><h2 href="http://www.silabs.com/">http://www.silabs.com</h2></p></body></html>
