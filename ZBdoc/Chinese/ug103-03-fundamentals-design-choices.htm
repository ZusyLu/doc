<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>UG103.3: Software Design Fundamentals</title><meta name="author" content="Silicon Labs"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 h1 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 24pt; }
 .s1 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 6pt; }
 .s2 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s3 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .p, p { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; margin:0pt; }
 .s5 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 3pt; }
 .s6 { color: #D81E2A; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 h3 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 .s7 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s8 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 5pt; }
 .s9 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6pt; }
 .s10 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s11 { color: #FFF; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s12 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s13 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s14 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s15 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 h4 { color: #FFF; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s17 { color: #FFF; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 8pt; }
 a { color: #FFF; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s18 { color: #FFF; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s19 { color: #231F20; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 7pt; }
 .s20 { color: #231F20; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; }
 h2 { color: #D91F2A; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 li {display: block; }
 #l2 {padding-left: 0pt;counter-reset: d1 1; }
 #l2> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 #l3 {padding-left: 0pt; }
 #l3> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l4 {padding-left: 0pt;counter-reset: d2 1; }
 #l4> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l4> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l5 {padding-left: 0pt; }
 #l5> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l6 {padding-left: 0pt;counter-reset: d3 1; }
 #l6> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l6> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l7 {padding-left: 0pt; }
 #l7> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l8 {padding-left: 0pt; }
 #l8> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l9 {padding-left: 0pt;counter-reset: d2 1; }
 #l9> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l9> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l10 {padding-left: 0pt;counter-reset: d3 1; }
 #l10> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l10> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l11 {padding-left: 0pt;counter-reset: d3 1; }
 #l11> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l11> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l12 {padding-left: 0pt;counter-reset: d3 1; }
 #l12> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l12> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l13 {padding-left: 0pt; }
 #l13> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l14 {padding-left: 0pt; }
 #l14> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l15 {padding-left: 0pt; }
 #l15> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l16 {padding-left: 0pt; }
 #l16> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l17 {padding-left: 0pt; }
 #l17> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l18 {padding-left: 0pt;counter-reset: d3 1; }
 #l18> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l18> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l19 {padding-left: 0pt; }
 #l19> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l20 {padding-left: 0pt;counter-reset: d3 1; }
 #l20> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l20> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l21 {padding-left: 0pt; }
 #l21> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 table, tbody {vertical-align: top; overflow: visible; }
</style></head><body><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span><img width="126" height="62" alt="image" src="ug103-03-fundamentals-design-choices/Image_001.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-top: 4pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">UG103.3: Software Design Fundamentals</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="724" height="1" alt="image" src="ug103-03-fundamentals-design-choices/Image_002.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="200" height="1" alt="image" src="ug103-03-fundamentals-design-choices/Image_003.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">KEY POINTS</p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="201" height="1" alt="image" src="ug103-03-fundamentals-design-choices/Image_004.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l1"><li><p class="s2" style="padding-top: 4pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Which stack or application framework to use?</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">SoC or NCP?</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Zigbee design choices</p></li></ul><p style="text-indent: 0pt;text-align: left;"/><p class="s3" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">This document describes the application design process in terms of major decisions that must be made about how to architect a wireless networking solution.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Silicon Labs’ <i>Fundamentals </i>series covers topics that project managers, application de- signers, and developers should understand before beginning to work on an embedded networking solution using Silicon Labs chips, networking stacks such as EmberZNet PRO or Silicon Labs <i>Bluetooth</i><span class="s5">®</span>, and associated development tools. The documents can be used as a starting place for anyone needing an introduction to developing wire- less networking applications, or who is new to the Silicon Labs development environ- ment.</p><p class="s6" style="padding-bottom: 3pt;text-indent: 0pt;text-align: right;">Background</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="713" height="0" alt="image" src="ug103-03-fundamentals-design-choices/Image_005.png"/></span></p><ol id="l2"><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark0">Background</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;">Silicon Labs is developing products designed to meet the demands of customers as we move to an ever-connected world of devices in the home, what is often referred to as the IoT (Internet of Things). At a high level the goals of IoT for Silicon Labs are to:</p><ul id="l3"><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Connect all the devices in the home with best-in-class networking, whether with Zigbee, Thread, Bluetooth, or other emerging stand- ards.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Leverage the company’s expertise in energy-friendly microcontrollers.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Enhance established low-power, mixed-signal chips.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Enable cloud services and connectivity to smartphones and tablets that promote ease of use and a common user experience for customers.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Achieving all of these goals will increase adoption rates and user acceptance for IoT devices in the Connected Home.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">As the range of options available to the application designer increases, the impact of early design choices also increases. This docu- ment describes the application design process in terms of major decisions that must be made about how to architect a wireless net- working solution. Basic design choices include:</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Which Silicon Labs wireless technology to use</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Whether to use an SoC (system-on-chip) design or an NCP (network coprocessor) design</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">If using the NCP model, how to select compatible NCP and host applications</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Design choices when developing a Zigbee solution include:</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">How to create the network (form, join, or leave)</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">What security models will be used</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">What kind of routing optimizations to employ in the network</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">How to deliver messages through the network</p></li></ul><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Once you have considered these choices, you can begin implementing the system design.</p></li><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark1">General Design Choices</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Before beginning a wireless design with Silicon Labs’ wireless microcontrollers, you should first consider which of the available network- ing technologies would be most appropriate for your project. Once you’ve decided on the networking protocol you want to use for your design, consider whether your product will fit best into a System-on-Chip (SOC) paradigm or a Network Coprocessor (NCP) paradigm and, for the NCP, what kind of serial communication to use for controlling the coprocessor.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l4"><li><p class="s7" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark2">Which Wireless Protocol Should You Use</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Silicon Labs offers the following stacks for development on the Wireless Gecko family:</p><ul id="l5"><li><p style="padding-top: 8pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">Silicon Labs Flex SDK, including the IEEE 802.15.4-based “Connect” stack (described in <i>UG103.12: Silicon Labs Connect Funda- mentals</i>) for multi-hop “star” network topologies, and the Radio Abstraction Interface Library (RAIL) for truly proprietary designs with custom RF configurations (described in <i>UG103.13: RAIL Fundamentals</i>).</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">EmberZNet, a Zigbee PRO-based mesh networking stack, described in detail in <i>UG103.2: Zigbee Fundamentals</i>.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Silicon Labs <i>Bluetooth® </i>SDK, a Bluetooth networking stack, described in detail in <i>UG103.14: Bluetooth® LE Fundamentals</i>.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Silicon Labs <i>Bluetooth® </i>mesh SDK, a companion to the Bluetooth SDK supporting Bluetooth mesh networks.</p></li></ul><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">To assist with application development, for each protocol or platform Silicon Labs supplies example application code and other support, such as application frameworks or preconfigured GATT structures. EmberZNet and the Connect component of the Flex SDK all contain one or more application frameworks. Application frameworks contain a body of Silicon Labs-supplied code stored in libraries and plu- gins. Silicon Labs also provides Simplicity Studio, which includes an Integrated Development Environment (IDE) based on Application Builder (AppBuilder). AppBuilder is an interactive GUI tool that allows you to configure the libraries and plugins contained in the applica- tion framework to implement devices. Note that the Bluetooth model handles pre-configured code somewhat differently, but the princi- ple of providing examples and other tools to make development easier is the same.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">After familiarizing yourself with the details of these protocols, your choice among them will likely depending on your needs for standards compliance, networking topology, interoperability, frequency range, and message throughput.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark3">SoC or NCP?</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The choice of the design paradigm─either the SoC (system-on-chip) model or the NCP (serial network coprocessor) model─is a crucial one. It dictates the requirements and constraints of both the software and the hardware. This choice governs where the application resides relative to the core stack functionality. In the SoC model the entire system (stack and application) resides on a single chip, whereas in the NCP model the stack processing is done in a separate “coprocessor” that interacts with the application’s own microcon- troller through an external serial interface.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="410" height="131" alt="image" src="ug103-03-fundamentals-design-choices/Image_006.png"/></span></p><p class="s8" style="text-indent: 6pt;text-align: left;">Any Processor</p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="text-indent: 0pt;text-align: left;">APP APP . . .</p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">Physical Radio (PHY)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="padding-top: 3pt;padding-left: 1pt;text-indent: 0pt;text-align: left;">Medium Access (MAC)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s8" style="padding-left: 27pt;text-indent: 0pt;line-height: 5pt;text-align: center;">Network</p><p class="s8" style="padding-left: 26pt;text-indent: 0pt;line-height: 108%;text-align: center;">Co- Processor (NCP)</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-left: 12pt;text-indent: -8pt;text-align: left;">System-on- Chip (SoC)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s10" style="padding-top: 2pt;padding-left: 1pt;text-indent: 0pt;line-height: 124%;text-align: left;">Application Stack</p><p class="s10" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">MAC + PHY</p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="padding-top: 3pt;padding-left: 10pt;text-indent: 0pt;text-align: left;">Network (NWK)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="padding-top: 3pt;padding-left: 20pt;text-indent: 0pt;text-align: left;">Security</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The following figure illustrates the various components of the stack and application and how they are organized relative to the SoC or NCP architecture model.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-top: 7pt;padding-left: 100pt;text-indent: 0pt;text-align: center;">Figure 2.1.  Stack and Application Component Organization in SoC and NCP Architectures</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;">While the choice between architectures is not to be made lightly, the application framework masks the differences to some degree, simplifying a change from one architecture to another when necessary, or supporting a mix of architectures for different products.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Note that Dynamic Multiprotocol applications must be built using the SoC model.</p><ol id="l6"><li><p class="s7" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark4">System-on-Chip Approach</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In the SoC approach, a single chip, such as one of the ICs in the Wireless Gecko (EFR32™) portfolio, provides all stack functionality (including integrated flash, RAM, and RF transceiver) as well as the application-layer components (application profiles, clusters, attrib- ute management, and stack interactions). Stack functionality is implemented as pre-compiled library files. You link with those library files along with your own application-related code during the final build process to produce a single, monolithic binary image comprising everything needed for a completely functional wireless application. An application framework, although supplied by Silicon Labs, is con- sidered part of the Application Layer.</p><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;"><b>Note: </b>While a bootloader is typically used in deployed wireless networking devices, that bootloader firmware is not part of this monolith- ic binary image. However, Silicon Labs does provide post-build tools that can be used to further combine both the application firmware and the stack firmware into a single HEX record file for ease of distribution and manufacturing. For more information about these soft- ware utilities for EmberZNet PRO applications, please consult document <i>UG107: ISA3 Utilities Guide</i>, <i>UG162: Simplicity Commander Reference Guide</i>, and document <i>UG103.6: Bootloader Fundamentals</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In the SoC approach to development, the application, including the application framework, is co-resident with the stack. The application calls APIs (application programming interface functions) provided by the stack libraries, and the stack triggers handler functions imple- mented by the application code. The application framework handles calling these APIs and implementing the necessary handler func- tions, then wraps these in higher level APIs and application callbacks to simplify the design process and help ensure protocol compli- ance.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Because the SoC model requires only a single chip, compared to the NCP model and legacy design architectures that require multiple ICs, the SoC model has lower power consumption, lower BOM (bill of materials) cost, and smaller possible layouts. Also, tighter inte- gration with the stack software and radio hardware can be achieved when everything resides on a single chip, allowing for more precise and timely control over application behaviors correlated to stack activity.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">However, once you have committed to an SoC model, you are bound by the constraints of the available offerings in that SoC family. These include the following:</p><ul id="l7"><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Flash and RAM memory constraints</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Toolchain constraints, such as the requirement to use IAR Embedded Workbench for Zigbee/Bluetooth dynamic multiprotocol appli- cations</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">HAL constraints, such as limited amount of peripherals of a certain type, or lack of a specialized peripheral that may be integral to your hardware design</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Timing constraints based on having to share a CPU with the stack, which has its own set of requirements in order to maintain IEEE</p></li></ul><p style="padding-left: 36pt;text-indent: 0pt;text-align: left;">802.15.4 and protocol compliance</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">If any of these constraints are too much of a deterrent, the NCP model may be a more attractive alternative.</p></li><li><p class="s7" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark5">NCP Approach with a Serial Protocol</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;"><b>Note: </b>This section does not pertain to the Bluetooth SoC or NCP models. For more information, consult <i>AN1042: Using the Silicon Labs Bluetooth® Stack in Network Co-Processor Mode </i>and <i>UG136: Silicon Labs Bluetooth® C Application Developer&#39;s Guide</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">In the NCP approach, a Silicon Labs chip with integrated flash, RAM, and RF transceiver runs most stack functions on its own through pre-loaded coprocessor firmware with runtime configurability, then uses a serial interface such as Serial Peripheral Interface (SPI) or Universal Asynchronous Receiver/Transmitter (UART) to communicate with a second device, known as the “host” processor, on which the application layer functionality is “hosted” separately from the core stack components. The NCP may be a special integrated circuit designed with limited I/O and reduced functionality for the express purpose of acting as a coprocessor or it may be a fully-featured microcontroller that happens to have the coprocessor firmware loaded onto it to make it behave as an NCP.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">To facilitate communication between the application’s host and the stack’s NCP, Silicon Labs provides two serial command sets. The first, known as EZSP (EmberZNet Serial Protocol), is used when developing Zigbee solutions (see document <i>UG100: EZSP Reference Guide</i>, for more information about EZSP.) The second, known as the Connect Serial Protocol (CSP) is used when developing Connect solutions</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">EZSP, which operates either synchronously over SPI or asynchronously over UART (with or without flow control), mimics the EmberZ- Net PRO API with EZSP-specific command frames (which may sometimes differ slightly from their SoC-based counterparts in EmberZ- Net) and the EmberZNet-related handler functions with callback response frames. Silicon Labs provides EZSP driver source code that abstracts these serial commands and responses into a set of APIs and handler functions similar to those used in the SoC model. The application framework takes care of calling the necessary API functions and implementing the required handler functions, allowing the designer to focus on higher level application processing with client APIs and framework callbacks.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Connect Serial Protocol (CSP) is used by a Host application processor to interact with the Connect stack running on an NCP. CSP messages are sent between the Host and the NCP over a UART interface. CSP is a binary protocol encapsulated within the ASHv3 protocol. For details on the ASHv3 protocol, see <i>UG115: ASHv3 Protocol Reference</i>.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The main advantage to the NCP platform is its flexibility. The host processor can be as simple as an 8-bit microcontroller, or it can be something as sophisticated as a 64-bit computer with gigabytes of memory and a Windows or Linux operating system. This means that the NCP design is well-suited to scenarios where a device is being added on or retrofitted to an existing system, such that an OEM’s expertise and intellectual property on the software and hardware side can be leveraged to speed up the design cycle and expedite time to market. Another advantage to the NCP approach is that the host can provide significantly more resources (flash and RAM) and a different peripheral set for the application than the available SoC options. This allows for development of more complex applications with new features, and protects the application from exceeding the limitations of the SoC when significant new features are added to the application.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Decoupling the stack processing from the application allows installing fixes and new features on the stack side with simple firmware updates to the NCP, without necessarily requiring any changes to the application firmware on the host. This decoupling also removes the CPU time constraints of sharing a processor with the stack. Because the NCP firmware manages the sleep state of the NCP to minimize its activity and its current consumption, only the host processor needs to be active when the application has tasks that don’t directly involve the stack. If the host processor’s active current consumption is lower than that of the SoC when the CPU is active with- out the radio, the total current consumed by the host and the NCP when running non-networking application tasks may actually be low- er than the SoC in a comparable scenario.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The primary disadvantage to the NCP approach is the addition of a second, host, processor, which adds extra cost and PCB real es- tate, and may impact the device’s overall power consumption. Another tradeoff is that decoupling stack and application processing means that certain time-sensitive interactions between the stack and the application can no longer occur in “real time” and must instead occur as notifications about decisions made by the stack after the fact. Thus, the host application has fewer opportunities to decide the outcome of certain decisions as they arise. Instead, “policies” are configured on the NCP to guide stack behavior in those situations. Also, because the NCP firmware is pre-built firmware supplied by Silicon Labs, the application designer does forfeit some amount of control over how the stack behaves and how its internal resources are allocated.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Once you commit to using the NCP approach, you must then decide which host platform to use for the design. This platform may be different for the prototyping and final design stages, depending on the availability of materials and the flexibility required during the initial stages of debugging. When choosing a host platform, consider your existing expertise and available tools and resources on that plat- form, the cost and power consumption requirements of that platform, and the amount of memory available for application development, including any headroom needed for future enhancements. When developing a Zigbee solution, you should also consider whether to use UART or SPI for EZSP communication. EZSP-UART requires a more complex driver, generally intended for use in a POSIX-compliant operating system, with more sophisticated logic and a larger memory footprint than the EZSP-SPI driver, and its supported maximum throughput is not as high. However, the EZSP-SPI implementation requires a few more interface pins than the EZSP-UART design. (A Portable Operating System Interface (POSIX)-compliant SPI driver for EZSP is also available but is often less portable across embed- ded Linux operating systems than the POSIX-compliant UART driver.) Because not all microcontrollers or operating systems support SPI, architectural constraints at the host may dictate this design choice.</p></li><li><p class="s7" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark6">Differences in Design</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><b>Note: </b>This section does not pertain to the Bluetooth SoC or NCP models. For more information, consult <i>AN1042: Using the Silicon Labs Bluetooth® Stack in Network Co-Processor Mode </i>and <i>UG136: Silicon Labs Bluetooth® C Application Developer&#39;s Guide</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;">The following table shows some of the primary differences between an SoC application and an NCP-based host application, by func- tion.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 100pt;text-indent: 0pt;text-align: center;">Table 2.1.  Functional Differences, SoC compared with NCP</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:275pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Method</p></td><td style="width:276pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Difference</p></td></tr><tr style="height:30pt"><td style="width:551pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="2"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 11pt;text-indent: 0pt;text-align: left;">Managing stack parameters, such as table sizes and allocation limits, and endpoint descriptor data, such as support clusters and profiles</p></td></tr><tr style="height:30pt"><td style="width:275pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">SoC</p></td><td style="width:276pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 15pt;text-indent: 0pt;text-align: left;">Mainly set up through compile-time definitions built statically into the application binary.</p></td></tr><tr style="height:51pt"><td style="width:275pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">NCP</p></td><td style="width:276pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 3pt;text-indent: 0pt;text-align: left;">Managed by the NCP but configured by host at runtime after boot- up of NCP and before engaging in any network activity; this interval is referred to as the “Configuration” phase and allows dynamic con- figuration of the NCP without rebuilding its firmware.</p></td></tr><tr style="height:19pt"><td style="width:551pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="2"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Application reaction to events</p></td></tr><tr style="height:51pt"><td style="width:275pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">SoC</p></td><td style="width:276pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 3pt;text-indent: 0pt;text-align: left;">The application can react to events, such as security authentication request, an incoming data poll from a child, or a remote binding modification, in the moment and can handle events on a case-by- case basis.</p></td></tr><tr style="height:30pt"><td style="width:275pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">NCP</p></td><td style="width:276pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 5pt;text-indent: 0pt;text-align: left;">The host application configures policies ahead of time to pre-deter- mine the outcome; notifications are after the fact.</p></td></tr><tr style="height:38pt"><td style="width:551pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="2"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Polling (for sleepy end devices that need to poll the network periodically)</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">The application framework takes care of the polling state machine, so the difference is negligible.</p></td></tr><tr style="height:30pt"><td style="width:275pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">SoC</p></td><td style="width:276pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">The application controls when each poll occurs and chooses how to react to the result of each poll.</p></td></tr><tr style="height:40pt"><td style="width:275pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">NCP</p></td><td style="width:276pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 4pt;text-indent: 0pt;text-align: left;">The host application configures poll rate and failure tolerance. NCP handles polling with the configured rate, and only notifies the host when the failure rate surpasses the configured threshold.</p></td></tr><tr style="height:38pt"><td style="width:551pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="2"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Managing message buffers</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">The application framework handles SoC buffer management, so the difference is negligible.</p></td></tr><tr style="height:73pt"><td style="width:275pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">SoC</p></td><td style="width:276pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 8pt;text-indent: 0pt;text-align: left;">The application shares memory for packet data with the stack. Shared message buffers must be allocated by the application for outgoing message data, and by the stack for incoming or relayed message data. Buffer management process, including buffer allo- cation/deallocation and construction, can be tricky and is often the source of errors in SoC application design.</p></td></tr><tr style="height:30pt"><td style="width:275pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">NCP</p></td><td style="width:276pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 12pt;text-indent: 0pt;text-align: left;">NCP handles the buffer management itself and accepts / delivers message payload data as a simple array and a length argument.</p></td></tr><tr style="height:19pt"><td style="width:551pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="2"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Adding and Removing Core Networking and Radio Functionality</p></td></tr><tr style="height:51pt"><td style="width:275pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">SoC</p></td><td style="width:276pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 4pt;text-indent: 0pt;text-align: left;">When changing the core (stack) functionality in an SoC application, you need only add or remove libraries or source code from a single application. This is easily done using the application framework by changing the plugins to be included.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:275pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Method</p></td><td style="width:276pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Difference</p></td></tr><tr style="height:84pt"><td style="width:275pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">NCP</p></td><td style="width:276pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 3pt;text-indent: 0pt;text-align: left;">If you want to change the core (stack) functionality in your host plus NCP application, you must make changes to both the host process- or application and the NCP firmware. This can be slight hindrance to the application development process, but the Network Coproces- sor Application Framework provides an interface to build NCP ap- plications that include only selected pieces of core networking and radio functionality.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s7" style="padding-top: 4pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark7">Security</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">A number of different security aspects must be considered when implementing an IoT solution. <i>UG103.5: IoT Endpoint Security Funda- mentals </i>uses the ioXt Alliance’s eight security principles as a structure for a review of those aspects. The document clearly delineates the solutions Silicon Labs provides to support endpoint security and what manufacturers and developers must do outside of the Silicon Labs framework. The decisions range from implementing product update infrastructure to the level of security offered by the application. For example, most protocols offer different security levels, with tradeoffs between security level and other features such as ease of network formation. Silicon Labs tools are designed to support the various levels of security provided by the protocol in question. Design- ers need to review and decide on the level required by their specific application and use cases. <i>UG103.5: IoT Endpoint Security Funda- mentals </i>offers pointers to more detailed documentation to help make those decisions.</p></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark8">Zigbee Design Choices</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;">Although the application framework simplifies and abstracts the design process, some design decisions must be made as part of imple- mentation. The following design choices are applicable when developing applications for Zigbee protocols, including Zigbee PRO:</p><ul id="l8"><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Single Network or Multi-Network</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Network Discovery / Commissioning Method</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Device Discovery and Provisioning Method</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Route Establishment Method</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Message Delivery Method</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">NCP and Host Application Compatibility</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l9"><li><p class="s7" style="padding-top: 5pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark9">Single Network vs. Multi-Network</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">A single network node is a node that forms or joins one network and must leave that network before forming or joining a second net- work. EmberZNet PRO 4.7 introduced the possibility for a node to be concurrently part of more than one network.</p><p class="s7" style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Note: <span class="p">For EmberZNet PRO, multi-network support is limited to two networks. More than two networks may be supported in the future.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Until now, any device required two physical chips to be part of two networks. For instance, a device that is designed to be a gateway between an HA (Home Automation) PAN (personal area network) and an SE (Smart Energy) PAN would join the first network using the first chip and the second network using the second chip. The application had to manage two pieces of hardware, resulting in increased complexity for the hardware and the application designer.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">A multi-network stack removes the 1-to-1 mapping between logical PANs and physical chip, extending it to an n-to-1 mapping. An appli- cation for a device with a single chip can be designed to be part of multiple PANs possibly running different security profiles (for in- stance HA and SE). Use of one instead of two chips results in cost savings from reduced hardware requirements and reduced complex- ity of the hardware and application code design.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Some applications still require a dual-chip configuration. This configuration is needed if the device needs to be coordinator or router on two networks (see more details below) or if the application needs to operate on two different stacks such as EmberZNet PRO and Sili- con Labs Connect.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Multi-networking on a single chip is achieved by timesharing the chip’s only radio on the networks. In other words, the multi-network node resets all the radio parameters between the networks according to a network scheduling algorithm.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The fact that the node is concurrently active on more than one network is totally transparent to the application. APIs allow the applica- tion to specify which network a set of API calls are referred to. Similarly, APIs allow the application to understand which network a stack callback is related to. See document <i>AN724: Designing for Multiple Networks on a Single Chip</i>, for more details regarding dual network APIs.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Both the Zigbee Application Framework and the Network Coprocessor Application Framework provide dual network support. The appli- cation framework provides many advantages in terms of reduced complexity, mostly related to how the framework seamlessly manages the different network contexts.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Typically a multi-network stack switches network, or retunes the radio on a different network, when an outgoing packet needs to be sent on a particular network. During the non-transmission time, the radio is always tuned on one of the networks, according to the stack’s internal network scheduling algorithm.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">There are some restrictions to the roles a node can assume on the networks. Since a coordinator or a router node is expected to keep the radio constantly on listening for incoming packets, a multi-network node can be coordinator or router on only one network, while it must be a sleepy end device on the other networks.</p><p class="s7" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Note: <span class="p">A node can assume any role on one network, but must be a sleepy end device on the other networks.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The networks in which a node participates can be on different channels, different PAN IDs, different short IDs, different profiles, and so on. However, a multi-network node maintains the same EUI64 address across the networks in which it participates. The next sections discuss in more detail the two basic configurations, the first where the multi-network node is a coordinator or router on one and a sleepy end device on all other networks, and the second where it is a sleepy end device on all networks.</p><ol id="l10"><li><p class="s7" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark10">Coordinator / Router Network + Sleepy End Device Network(s)</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">A multi-network node that is a coordinator/router on one network and a sleepy end device on the other networks should spend most of its time on the coordinator/router network. A network scheduling algorithm seamlessly takes care of switching from one network to the other so that the node is always on the coordinator/router network except for short periods of time. In particular, the node temporarily leaves the coordinator/router network to complete certain transactions on the sleepy end device networks, such as polling/data retriev- ing from the parent and/or data sending to the parent. These transactions are typically initiated at the application layer. Therefore the application designer should design the application so that the node does not spend too much time away from the coordinator/router network. Having a multi-network node too busy on a sleepy end device network can consistently impact the throughput of the node and in general could delay all the traffic that gets routed through the node on the coordinator/router network.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In document <i>AN724: Designing for Multiple Networks on a Single Chip</i>, Silicon Labs provides data obtained from extensive experiments that show the average duration of some typical polling and data transactions between a sleepy end device and its parent. The docu- ment also includes a detailed study on how the activity on the sleepy end device network impacts the throughput on the coordinator/ router network. With this data, you can make educated design choices based on how much traffic the multi-network node will handle on the sleepy network and how this traffic impacts the performance of the coordinator/router network.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Notice that even if the node behaves as a sleepy end device on most of the networks, if it is also a coordinator/router on any one net- work, it will not be able to save energy by temporarily shutting down the radio (sleep mode).</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark11">Multiple Sleepy End Device Networks</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">A multi-network node that is a sleepy end device on all networks does not need to keep its radio always on. The node can poll with different polling rates on each network. The node is able to sleep as long as there is no activity on any network.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s7" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark12">Network Discovery / Commissioning</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Commissioning refers to the process of getting devices into the network. If you have read the discussion of the network joining process in the document <i>UG103.2: Zigbee Fundamentals</i>, you may recall that unless a device is acting as coordinator for a PAN, it must re- quest to join an existing network, and that the joining device must scan one or more channels to locate the available networks. Howev- er, as the network coordinator has several radio channels from which to choose in forming its PAN, and since the network’s PAN ID and Extended PAN are often randomized, your application generally requires some intelligence or external mechanism to assist with net- work discovery and commissioning. Tasks include helping ensure that the device can either join the proper network or receive the de- sired network settings from some external source, and ensuring that the device can be removed from the network when either the wrong network is joined by mistake or the device is being migrated to a new installation. Likewise, if you are designing a device that may act as a Zigbee PAN coordinator, it is important to consider ways in which you can ease the process of network selection for devi- ces looking to enter your coordinator’s network.</p><p class="s7" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Note: <span class="p">If you are designing an application for use in an official, public Zigbee PRO application profile (such as Home Automation), Sili- con Labs recommends that you review the latest published revision of the appropriate Zigbee application profile specification (as ob- tained from http://www.zigbee.org) for your target design, to ensure that it meets any profile-specific requirements or best practices for commissioning.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l11"><li><p class="s7" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark13">Simplifying Network Selection through Extended PAN ID or Channel Mask</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Although Extended PAN ID selection by the PAN’s coordinator is generally random, a proprietary network deployment may use a spe- cific bitmask of extended PAN IDs as a way to enhance network selection for joining devices. In this model, the coordinator forms a network within this agreed-upon Extended PAN ID mask, such that joining devices could scan channels for open PANs and limit those outside of the configured Extended PAN ID range. However, this method of enhancing network selection is not feasible for devices wishing to interoperate on public Zigbee PRO profiles with devices from a wide range of manufacturers. Because the public Zigbee PRO application profiles do not generally limit their Extended PAN ID selection, another vendor’s device may occupy Extended PAN IDs outside of the limiting bitmask that you’ve chosen.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Similarly, although 2.4 GHz Zigbee networks can occupy any of 16 different channels, the joining device may be able to limit its mask of channels to scan. The expected network might be a proprietary design in which the coordinator has chosen to confine its channel selec- tion to only a few channels within a preconfigured mask. Alternatively, the application profile upon which one or more endpoints of the included devices is based may require constraining the network’s channel selection to a specific set of channels. For instance, both the Zigbee PRO SE and HA application profiles require that preference be given when forming a network to channels outside of the most commonly used Wi-Fi channel allocations (channels 1, 6 and 11 in the IEEE802.11 range), which allows the joining device to confine its channel scan to Zigbee channels 11, 14, 15, 19, 20, 24, and 25. Note that the Zigbee Application Framework uses the Network Find plugin (if enabled) to configure the channel mask for the device when joining or forming a network. If using Application Builder to config- ure your application, make sure to review the Channel Mask and other radio parameter settings in the configuration dialog for the Net- work Find plugin. If you are not using the Network Find plugin or your application is not based on the Zigbee Application Framework, your application code needs to use its own method for ensuring that a preferred channel mask and any other preferred network param- eters are enforced during scanning, joining or forming of networks.</p></li><li><p class="s7" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark14">Permit Joining Control</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Devices looking to join a network generally only consider those PANs that are open to new devices (in other words, they permit joining), and devices must not leave their <span class="s14">permitJoining </span>flag permanently set, at the risk of failing Zigbee PRO compliance testing for public profiles and manufacturer-specific profiles (MSPs). Therefore, devices, especially the PAN coordinator, must ensure that they can ena- ble the <span class="s14">permitJoining </span>flag locally for at least some limited time when new devices need to be added to the network. This enabling generally must come from some external stimulus, which will depend on the physical capabilities of a device. If a button or serial inter- face is available to the device, this is usually an appropriate stimulus to enable <span class="s14">permitJoining</span>. However, if the device doesn’t have an external input to act as this stimulus, other methods must be considered. One possibility is to have the device enable <span class="s14">permitJoining </span>for a limited time when it is first powered on. Another option is to cause <span class="s14">permitJoining </span>to be enabled when a particular message is received by the node over the air.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">With regard to the latter method, while it is possible for the application to make a local change to its own <span class="s14">permitJoining </span>state through a local call to the <span class="s14">emberPermitJoining() </span>API or <span class="s14">permitJoining </span>EZSP command, it is also possible to send a standard request through the ZDO (Zigbee Device Object), which is implemented intrinsically by the stack, to a Zigbee node to ask it to change its <span class="s14">permitJoining </span>state. When a ZDO Permit Joining Request is received over the air for endpoint 0 (the ZDO) on application profile 0x0000 (the Zigbee Device Profile), the stack automatically alters the <span class="s14">permitJoining </span>state on the device. A unicast or broadcast of this request provides a standard way to change the joining permissions of the network remotely for some or all devices, respectively. For sample code that implements this request, please refer to the <span class="s14">emberPermitJoiningRequest() </span>API found in the “app/util/zigbee-frame- work/zigbee-device-common.h” file from your EmberZNet PRO installation.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Once the network contains at least one node within range of the joining device that permits joining, the joining device should be able to detect it as joinable through the stack’s native <span class="s14">emberNetworkFoundHandler() / ezspNetworkFoundHandler() </span>callback or its <span class="s14">emberJoinableNetworkFoundHandler() </span>callback provided by the form-and-join utilities found in app/util/common/form-and-join.h, which are used by the AFV2 architecture. (See the Zigbee Application Framework’s “Network Find” plugin or &quot;Network Steering&quot; plugin for a recommended implementation.)</p></li><li><p class="s7" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark15">Avoiding Unintended Consequences in the Commissioning Process</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Once your joining device does find a joinable network and attempts to join it, the application or the installer must determine if it is the “correct” network, meaning the intended one rather than some other, arbitrary PAN that happened to be within range and permitting joining. The joining and subsequent authentication process, which involves the acquisition of the current NWK (network) layer encryp- tion key for the PAN, can fail in a variety of ways, even when joining the intended network. Therefore, permanently excluding networks where a join was attempted but failure in joining/authenticating has occurred is not necessarily the best practice. Similarly, depending on the security expectations of your joining device, it may be possible for it to successfully join a network that really isn’t the correct one at all, so permanently settling into a network simply because the stack sends an <span class="s14">EMBER_NETWORK_UP </span>signal, indicating that the device was successfully joined and authenticated into the network, may not be sufficient either. The appropriate criteria for determining wheth- er the attempted network is the correct one varies based on your design requirements, especially where security is concerned.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">If you are designing a device for use in a Zigbee PRO SE (Smart Energy) network, a complex pre-authorization process is required before the device can successfully enter the network. See the document <i>AN1233: Zigbee Security </i>for more information. Assuming that the requirement for pre-authorization has been met in the target network, joining the wrong network accidentally should be virtually im- possible as the joining device won’t accept the NWK key delivery if it arrives unencrypted or encrypted with a different APS (Application Support) link key.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">However, even with the SE security model, the joining node may still need to account for the fact that an unreliable link or other commu- nication problem, especially if it involves the PAN’s trust center, may cause the delivery of the NWK key from the trust center to fail, even in the correct network. Thus, if a joinable network is detected but the subsequent joining and authentication fails with <span class="s14">EmberStatus </span>of <span class="s14">EMBER_NO_NETWORK_KEY_RECEIVED </span>(meaning the NWK key didn’t arrive successfully), <span class="s14">EMBER_JOIN_FAILED </span>(which could signify that the Association Response for the join wasn’t received successfully), or <span class="s14">EMBER_NO_BEACONS </span>(meaning that the Associa- tion Request on the chosen network failed to get an answer), you may want to retry the joining process on that PAN again either imme- diately or later, in case the first attempt failed due to some temporary disruption. If the joining or authentication process continues to fail on the chosen PAN, consider attempting joining a different joinable network, provided one is available to your device, as the failures may be an indication that this is simply the wrong network.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In networks utilizing an HA (Home Automation) security model with a common, preconfigured APS link key used to pass a randomly generated NWK key, there is significant risk of joining the wrong network by accident if multiple joinable networks happen to exist within range of the joining device, as the security settings among these networks are common to nearly all HA networks rather than being unique for each incoming node. Note that it is possible for HA networks to use a different preconfigured link key, but this key must somehow be communicated to the new node prior to its joining the network. Thus, you should take extra care in your application design to ensure that, once you enter a PAN successfully, it is really the intended one. This typically involves some kind of “join and verify” process for each available network that accepts your device, which means sending some sort of well-defined over-the-air message with an expected response to indicate joining of the correct network; this response may be another over-the-air message or may be some kind of detectable behavior by another part of the system.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">An example of each method is described in the following table, beginning when a new node joins the candidate network:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 100pt;text-indent: 0pt;text-align: center;">Table 3.1.  Join-and-Verify Methods</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:181pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Triggering Event</p></td><td style="width:179pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Success</p></td><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Exception</p></td></tr><tr style="height:19pt"><td style="width:540pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="3"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Example 1</p></td></tr><tr style="height:40pt"><td style="width:181pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;text-align: left;">Node sends broadcast ZDO Match Descrip- tor Request for one or more target clusters that are important to the node’s operation.</p></td><td style="width:179pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 6pt;text-indent: 0pt;text-align: left;">ZDO Match Descriptor Response received from one or more remote nodes.</p></td><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 10pt;text-indent: 0pt;text-align: left;">No matches found; node goes to the next network candidate.</p></td></tr><tr style="height:100pt"><td style="width:540pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="3"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Caveats:</p><p class="s13" style="padding-top: 8pt;padding-left: 2pt;padding-right: 4pt;text-indent: 0pt;text-align: left;">As this verification process detects only devices that support the desired clusters, it can succeed when the joining node has entered a network with the same kind of security model and same kind of cluster capabilities as the intended network. For example, the garage door opener may join an arbitrary network with a garage door to control, but not the intended one. If this happens, the system must somehow detect the condition and instruct the new node to leave the current network and find a different one.</p><p class="s13" style="padding-top: 8pt;padding-left: 2pt;padding-right: 9pt;text-indent: 0pt;text-align: left;">This process only succeeds when at least one other node with the matching services has already been joined to the network. This introduces a commissioning requirement for the order in which devices must be joined, which must be communicated to the installer.</p></td></tr><tr style="height:19pt"><td style="width:540pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="3"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Example 2</p></td></tr><tr style="height:62pt"><td style="width:181pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 8pt;text-indent: 0pt;text-align: justify;">Step 1: Node sends a unicast ZDO Match Descriptor Request to the network coordi- nator (node ID 0x0000), trying to match a device with support for ZCL Identify server cluster.</p></td><td style="width:179pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 18pt;text-indent: 0pt;text-align: left;">Node receives a ZDO Match Descriptor Response from the coordinator.</p></td><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 14pt;text-indent: 0pt;text-align: left;">No response; node goes to the next net- work candidate.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:181pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Triggering Event</p></td><td style="width:179pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Success</p></td><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Exception</p></td></tr><tr style="height:51pt"><td style="width:181pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 17pt;text-indent: 0pt;text-align: justify;">Step 2: Node sends a ZCL Identify com- mand to the coordinator on the matched endpoint.</p></td><td style="width:179pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 9pt;text-indent: 0pt;text-align: left;">The coordinator identifies itself to the sys- tem in some detectable way.</p></td><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 5pt;text-indent: 0pt;text-align: left;">Identification not received within an expec- ted timeframe; system acts on the node so that it leaves the network and goes to the next candidate.</p></td></tr><tr style="height:78pt"><td style="width:540pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="3"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Caveats</p><p class="s13" style="padding-top: 8pt;padding-left: 2pt;padding-right: 8pt;text-indent: 0pt;text-align: left;">In addition to the required instructions for the system, this method depends on having the coordinator accessible whenever a node is joined to the network. This is generally the case, as the coordinator is typically fulfilling the role of trust center to provide central au- thentication for each new node.</p><p class="s13" style="padding-top: 8pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">This method also requires having some system-accessible stimulus available on the joining node to enable it to change networks.</p></td></tr><tr style="height:19pt"><td style="width:540pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="3"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Example 3</p></td></tr><tr style="height:51pt"><td style="width:181pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">PAN’s Trust Center receives the <span class="s15">TrustCenterJoinHandler </span>callback for the joining device.</p></td><td style="width:179pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 4pt;text-indent: 0pt;text-align: left;">PAN’s Trust Center notifies the system through visual or audible indications on the Trust Center or some dedicated user inter- face such as a networked PC.</p></td><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;padding-right: 10pt;text-indent: 0pt;text-align: left;">System does not get the expected indica- tion; system acts on the node so that it leaves the network and goes to the next candidate.</p></td></tr><tr style="height:59pt"><td style="width:540pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="3"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Caveats</p><p class="s13" style="padding-top: 8pt;padding-left: 2pt;padding-right: 8pt;text-indent: 0pt;text-align: left;">This example does not require that the joining node’s application send any extra messages, which greatly simplifies the commission- ing design for the joining node’s application. However, it does rely on certain intelligence and capabilities at the PAN’s trust center device. Use of this method involves cooperation with the designer of the expected trust center (coordinator) node for your system.</p></td></tr></table><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The choice of one of the above methods, or some variant thereof, will likely depend on the capabilities of the devices in your system, the importance of multi-vendor interoperability in your design, the expected latency of the commissioning process, and the sophistica- tion of the installers who will be commissioning your devices.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Zigbee provides a commissioning cluster in the ZCL, which facilitates over-the-air installation of certain commissioning parameters into a device. However, as of this writing neither the HA nor SE profile requires implementation of this cluster on client or server side in its device types, nor has its use been tested as part of the Zigbee interoperability test events for these profiles. Use of the commissioning cluster is only feasible in networks where you can ensure that the joining node has server-side support for the commissioning cluster, and that at least one device in the system has client-side support to send commissioning commands. Furthermore, because the com- missioning cluster relies on Zigbee messaging, which necessitates being in a network in the first place, you would need to design a scheme for having your device join a temporary commissioning network where a commissioning tool exists that can provide the neces- sary parameters. While the application framework allows for use of the ZCL’s commissioning cluster, implementation of that cluster, if desired, is the responsibility of the application developer.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-top: 5pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark16">Leave Mechanism</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Many designers put careful thought into the network selection process and then neglect to provide a way for the system to uninstall the device from the current network and then install it into a new network. As the commissioning examples above show, enabling some way for the device to manually or automatically initiate an <span class="s14">emberLeaveNetwork() </span>action, and possibly find a new network after the leave completes, is often necessary to facilitate successful installation and reinstallation of Zigbee devices in their intended networks.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">If this cannot be implemented in the hardware or software of the joining device itself, the ZDO’s Leave Request mechanism, which is acted on automatically by the stack, may be a viable alternative, as it allows another node in the PAN, such as the network’s controller, to instruct a device to leave the network. For sample code implementing the ZDO Leave Request command, refer to the <span class="s14">emberLeaveRequest() </span>API found in the “app/util/zigbee-framework/zigbee-device-common.h” file from your EmberZNet PRO installa- tion.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s7" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark17">Device Discovery and Provisioning</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Once you’ve joined your device to the correct network, it needs some way to be paired up with other nodes in the PAN that provide related services (in other words, client-side devices are paired up to one or more server-side side devices). This process of pairing together related devices in the PAN for communication at the application level is referred to as “provisioning”. By contrast, “commission- ing” deals with associating devices together for communication at the networking stack level. As you architect your design, consider how you will discover which and how many devices in your PAN provide the services (clusters) of interest and by what means you will provision those related devices to one another. Note that the actual provisioning process generally concludes with one or more of the involved devices each registering the partner device(s) into its binding table, its address table, or some custom storage mechanism designed to remember the provisioned partner, so that messages can be sent to that destination.</p><ol id="l12"><li><p class="s7" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark18">When to Discover and Provision</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Often, application designers craft their application to perform some kind of device discovery, and attempt to provision soon after the commissioning process for a device is complete (that is, just after it comes online). However, because devices join one at a time, mean- ing one side of the provisioning is generally online before the other side, you will likely need to have a mechanism initiated by software state machine logic, external interrupt, or some over-the-air stimulus, to initiate provisioning later in the device’s lifetime in the network.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Different provisioning methods are described in the next sections, with advantages and disadvantages for each.</p><p class="s7" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Note: <span class="p">If you are designing an application for use in an official, public Zigbee PRO application profile such as Zigbee 3.0, Silicon Labs recommends that you review the latest published revision of the appropriate Zigbee PRO application profile specification (as obtained from http://www.zigbee.org) for your target design to ensure that any profile-specific requirements or best practices for provisioning are being met by your design.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark19">Identify and Group Method</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">This method can be used for one-to-one provisioning or one-to-many provisioning, between a single source device (usually a client for the clusters being provisioned) and one or more target devices (usually servers for the clusters being provisioned). It involves putting each of the target nodes into Identify mode either through reception of an Identify command from some device or through some exter- nal stimulus. The source node then sends an “Add Group If Identify” command (a required client command in the ZCL’s Identify cluster) as a broadcast, such that all nodes currently in identification mode add themselves to the specified group through the groups table maintained by the ZCL Groups server cluster. Once the target devices belong to a single group, the source device can send multicasts to the group either directly (<span class="s14">EmberOutgoingMessageType </span>of <span class="s14">EMBER_OUTGOING_DIRECT</span>) or by creating a Multicast binding for the target group and then sending outgoing commands through that binding (<span class="s14">EMBER_OUTGOING_VIA_BINDING</span>).</p><p class="s7" style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Advantages:</p><ul id="l13"><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Allows provisioning a single device to multiple targets simultaneously.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Requires as few as one over-the-air message (the Add Group If Identifying command) if all target devices support local method of being placed into Identify mode.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Can be performed over a long or short time interval, as Identify Time used in the Identify command can be set very small or large.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">Can get devices into identification mode so that they are ready for provisioning in this manner over the air if needed, so works with devices without local stimulus (buttons or other user interface).</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">If the source node can’t be told manually to send Add Group If Identifying command, the source node can be put into identification mode and added to group so that multicast binding is created automatically (as part of groups table logic), for use in communicating with targets.</p><p class="s7" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Disadvantages:</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Target devices must support Groups server and Identify server clusters.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Target devices may require local stimulus such as a button press to get into identification mode, unless another device in the system can be told to send Identify command to specific devices of interest.</p></li></ul></li><li><p class="s7" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark20">Push Button Method</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">This method involves pressing a button on one or more of the devices to cause it either to emit a message that other devices can rec- ognize as a signal to engage in provisioning with this device as appropriate, or to enter a state where receiving a particular message within a particular time window causes it to engage in provisioning with the sender. For example, a light switch needing connection to one or more lights could use a button press to enter a state where, for the next 30 seconds, any “Add to switch” messages sent by lights cause the switch to register a binding entry for those lights. Similarly, a button press (or other stimulus) could be used to cause these “Add to switch” messages to be transmitted by each light.</p><p class="s7" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Advantages:</p><ul id="l14"><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Lots of flexibility in implementation as far as what actions occur on button press and how long certain provisioning states last, which in turn impacts how long the provisioning process is allowed to take.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Can be used for one-to-one or one-to-many provisioning.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Doesn’t require involvement from any third party devices (those not on either side of the provisioning process).</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Allows user/installer to explicitly control the provisioning process through manual interaction.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Doesn’t need any special cluster support.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">May be used in conjunction with other provisioning methods that involve manual interaction, such as Identify and Group method.</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Disadvantages:</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">One or both sides of the provisioning require local stimulus, such as a button, to engage in this process.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">May involve proprietary messaging protocol (for example, the proprietary “Add to switch” message discussed in the example above) or application-specific behavior to accomplish, reducing chances of interoperability among vendors.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Provisioning between the wrong devices could occur if multiple provisioning processes are taking place simultaneously (such as if multiple installers are performing push-button provisioning on the same network at the same time).</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark21">Match Descriptor Request Method</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In this method, a device looking to discover a particular partner for provisioning queries one or more nodes through the ZDO Match Descriptor transaction to find a suitable provisioning partner based on the other nodes’ descriptor information (application profile, device identifier, cluster IDs, and client/server support) for each of their endpoints. In a typical scenario involving this method, a client device for a particular cluster (cluster X), configured on application profile Y, sends out a ZDO Match Descriptor Request as a broadcast to the network, with the descriptor information specifying an endpoint with server support for cluster X on profile Y. All nodes that receive this request process the message automatically using code built into every standard Zigbee PRO stack, by attempting to match the queried endpoint description with an endpoint descriptor on one of their own endpoints. If one or more endpoints on a queried device match the requested criteria, the queried device responds with a unicasted ZDO Match Descriptor Response containing the list of endpoints that match the request. The device that performed the query can then parse the responses and decide which (and how many) of the poten- tial partners it should provision itself with.</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Advantages:</p><ul id="l15"><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Provides for pairing based on a specific set of cluster support criteria.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Doesn’t require interaction of a third party to facilitate pairing (as compared with End Device Bind Method).</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Uses standard ZDO frames for query and response, allowing for an interoperable solution without special parsing required of the query and responses. Stack handles ZDO queries automatically.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Query can be broadcast or unicast.</p><p class="s7" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Disadvantages:</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Generally relies on broadcasts to find all nodes, which is not 100% reliable and consumes network bandwidth.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">When sent as a broadcast, the ZDO Match Descriptor Request can only be sent to the Rx-On-When-Idle broadcast address, mean- ing that sleepy (Rx off when Idle) end devices are not discoverable with this method.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">The application requires some internal logic or a user interface to evaluate the query respondents and decide to which and to how many devices it should provision itself.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Match Descriptor Responses may not contain the sender’s EUI64, so provisioning based on long addresses (rather than dynamic, 16-bit node IDs) may require an additional unicast ZDO IEEE Address Request transaction to query the EUI64 of the partner node.</p></li></ul></li><li><p class="s7" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark22">Simple Descriptor Request Method</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Simple Descriptor Request method is similar to the Match Descriptor Request method in that it uses standard ZDO queries to in- quire about the target node’s endpoint configuration (profiles, clusters, server/client support, and so on). However, where the Match Descriptor Request is sent as a broadcast or a unicast to try matching cluster support criteria on the recipient devices, the Simple De- scriptor Request is only sent as unicast to a specific endpoint of a target node, and produces a full list of supported client and server clusters available on that endpoint of the target. This request can be used iteratively on each available endpoint of the target node to discover all possible cluster support available across endpoints. A ZDO Active Endpoints Request is frequently used as a precursor to the ZDO Simple Descriptor transactions so that the querying device can know how many valid endpoints exist at the target node and their endpoint numbers. Although this method yields more complete information than the Match Descriptor Request method, it is also less efficient, and so is generally not practical to use when a large number of devices need to be queried. This method is most useful when the querying device isn’t sure which clusters it should provision with the target device; once it knows which clusters are available on the partner device, it can choose from among those clusters as it completes the provisioning process.</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Advantages:</p><ul id="l16"><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Provides for pairing based on a specific set of cluster support criteria.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Doesn’t require interaction of a third party to facilitate pairing.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Uses standard ZDO frames for query and response, allowing for an interoperable solution without special parsing required of the query and responses. Stack handles ZDO queries automatically.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Doesn’t rely on broadcast mechanism.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Doesn’t require that the querying device knows which clusters are expected on the target device.</p><p class="s7" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Disadvantages:</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">Requires lots of back-and-forth transactions (one command/response transaction per endpoint, plus one for the Active Endpoints Request to assess viable endpoint numbers) to discover endpoint data of the target. While bandwidth consumption is relatively low for these transactions, the latency in completing the provisioning process can be significant, especially if there are multiple endpoints on the target.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">The application requires some internal logic or a user interface to decode which nodes to query and what to do with the response data when it arrives.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">Simple Descriptor Responses may not contain the sender’s EUI64, so provisioning based on long addresses (rather than dynamic, 16-bit node IDs) may require an additional unicast ZDO IEEE Address Request transaction to query the EUI64 of the partner node. Note: Many devices will include their EUI64 in ZDO responses when the request is a unicast with the Source EUI64 APS option enabled, which is the default behavior for the EmberZNet PRO stack.</p></li></ul></li><li><p class="s7" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark23">Provisioning Tool Method</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In this method, a third party device (not one of the nodes being provisioned) obtains information about some or all of the devices in the network and then provides a user interface to allow the network’s installer/administrator to provision devices to one another in whatever manner he deems appropriate. This device information may be acquired through one of the ZDO discovery processes described in the preceding sections (Simple Descriptor Request or Match Descriptor Request) or by some more proprietary means (similar to the way device information is provided by a network concentrator in the Device Advertisement method).</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The provisioning tool may be a device dedicated to this role, or may also be fulfilling other central roles in the network, such as network concentrator, PAN coordinator, commissioning tool, or gateway. Since the provisioning tool is likely to be communicating with a lot of different devices in the network, Silicon Labs recommends making this node behave as a network concentrator so that routes to the other nodes are readily available without requiring a series of route discoveries, which can burden the network and increase latency.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Once the tool decides which devices should be provisioned to one another, it typically uses a ZDO Bind Request to the target devices to install a binding table entry for communication to the partner device.</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Advantages:</p><ul id="l17"><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Provides for pairing based on user input for maximum flexibility in provisioning.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Doesn’t require any intelligence beyond standard ZDO support in stack in provisioned devices for information discovery. All intelli- gence resides in provisioning tool node.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Provisioned devices don’t need to be awake to do their own provisioning, so the provisioning process can occur while one of the provisioned devices is asleep.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Devices don’t need to worry about re-discovering nodes for provisioning when new nodes enter the network, since the tool can take care of this.</p><p class="s7" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Disadvantages:</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Requires a special tool (either a dedicated device or an extra set of functionality on an existing device) with a custom user interface to facilitate provisioning.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">The provisioning tool periodically needs to gather information from devices to avoid conflicting with the devices’ own provisioning behaviors.</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark24">Address Discovery</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Since provisioning often involves the creation of a binding table or address table entry, which relies on an EUI64 for tracking devices, the nodes involved in provisioning should make an effort to obtain the EUI64 of their partner devices to facilitate these table entry crea- tions. For example, when using the Device Advertisement method, it is useful to include the advertiser’s EUI64 to prevent the receiver from having to discover this later, should the receiver choose to provision itself to the advertiser. As another example, when using ZDO request methods such as Simple Descriptor Request and Match Descriptor Request methods, the request should, when possible, con- tain the source EUI64 of the requesting device so that the receiver can respond in kind by providing its EUI64 address in the response frame, allowing for smoother provisioning.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s7" style="padding-top: 5pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark25">Route Establishment</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In many networks, a large amount of data is funneled to a single node that is designated to store the data or offload it to another system or network. This behavior is most common in large sensor networks where information is gathered from many devices and aggregated at some central point.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Many-to-One Routing (MTOR) allows an aggregation point (a “concentrator” in Zigbee terminology) to provide every device on the net- work with a route to the concentrator without each node needing to discover it individually. Furthermore, MTOR provides a means to convey to the concentrator each node’s own route to that concentrator. This allows the concentrator to collect some or all of these route records at its discretion, a technique known as “source routing”. MTOR works in conjunction with source routing to allow bidirectional communication between the concentrator and other nodes without requiring discovery of new or updated routes at the time of message delivery.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l18"><li><p class="s7" style="padding-top: 5pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark26">Background - Many to One Routing</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Early in Zigbee’s development, it became clear that a common communication pattern in embedded wireless networking applications was many-to-one, in which up to hundreds of devices might be communicating with a central gateway. At Silicon Labs, we sometimes use the term &quot;aggregation&quot; to refer to this pattern and the term &quot;aggregator&quot; for the gateway node.</p><p class="s7" style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Note: <span class="p">For more information, see the Zigbee specification, document #053474. Sections of note include: 3.4.1.9 Source Route Subframe Field, 3.5.5 Route Record Command, 3.7.3.3.1 Originating a Source Routed Data Frame, and 3.7.3.3.2 Relaying a Source Routed Data Frame.</span></p></li><li><p class="s7" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark27">How it Works in Zigbee PRO</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">This section briefly covers the details of how aggregation is now specified in the Zigbee PRO network layer.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The concentrator (for example, a gateway) establishes routes to itself by sending a many-to-one route request. This is just a regular route request sent to a special broadcast address. It signals the network layer of receiving nodes to create the inbound routes rather than a point-to-point route. No route replies are sent; the route record command frame described below serves a conceptually similar purpose.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">When a device sends a unicast to the concentrator, the network layer transparently takes care of sending a route record command frame to the concentrator first. As the route record packet is routed to the concentrator, the relay nodes append their short IDs to the command frame. By storing the route obtained from the route record payload, the concentrator is supplied with the information it needs to source route packets in the reverse direction.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Source routing is accomplished by adding a subframe to the network frame, and setting a bit in the network frame control field. Upon receipt by relays, the next hop is read from the subframe rather than the local routing table. An application callback on the concentrator inserts the source route subframe into outgoing unicasts or APS acknowledgements as necessary.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Route maintenance is accomplished by the concentrator application resending the special many-to-one route request.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">You can find additional information in the online API reference guide and in the many FAQ articles available on the Silicon Labs Sup- port Portal.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s7" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark28">Message Delivery</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">This section provides an overview of this topic. If you would like more detailed information, please refer to document <i>UG105: Advanced Application Programming with the Stack and HAL APIs</i>.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Message handling differs depending on whether you are using the SOC or NCP model. However, regardless of the model, many of the details and decisions involved in message handling are similar. Generally, message handling falls into two major tasks:</p><ul id="l19"><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Create a message</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Process incoming messages</p></li></ul><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The EmberZNet PRO stack software takes care of most of the low level work required in message handling. The following figure illus- trates where the application interacts with the system in message handling. However, while the APS layer handles the APS frame struc- ture, it is still the responsibility of the application to set up the APS header on outbound messages, and to parse the APS header on inbound messages.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 140pt;text-indent: 0pt;text-align: left;"><span><img width="412" height="290" alt="image" src="ug103-03-fundamentals-design-choices/Image_007.png"/></span></p><p class="s7" style="padding-top: 6pt;padding-left: 100pt;text-indent: 0pt;text-align: center;">Figure 3.1.  Application/System Relationship During Message Handling</p><ol id="l20"><li><p class="s7" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark29">Sending Messages</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Three basic types of messages can be sent:</p><ul id="l21"><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Unicast — sent to a specific node ID based on an address table entry (the node ID can also be supplied manually by the application if necessary)</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Broadcast — sent to all devices, all non-sleepy devices, or all non-ZEDs (Zigbee End Devices)</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Multicast — sent to all devices sharing the same Group ID</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Before sending a message you must construct a message. The message frame varies according to message type and security levels. Since much of the message frame is generated outside of the application, the key factor to be considered is the maximum size of the message payload originating in your application.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The following table shows the detailed API for sending the most common message types.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 100pt;text-indent: 0pt;text-align: center;">Table 3.2.  API Messaging Functions</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:168pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">EmberZNet API</p></td><td style="width:205pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Application Framework API</p></td><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:14pt"><td style="width:168pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">emberSendUnicast (</p></td><td style="width:205pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">emberAfSendUnicast(</p></td><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Sends a unicast message as per the Zig-</p></td></tr><tr style="height:11pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">EmberOutgoingMessageType type,</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">EmberOutgoingMessageType type,</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">bee PRO specification.</p></td></tr><tr style="height:11pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int16u indexOrDestination,</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int16u indexOrDestination,</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:11pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">EmberApsFrame * apsFrame,</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">EmberApsFrame *apsFrame,</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:11pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">EmberMessageBuffer message</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int8u messageLength,</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:11pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">)</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int8u* message</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:16pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">)</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:168pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">emberSendBroadcast (</p></td><td style="width:205pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">emberAfSendBroadcast (</p></td><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Sends a broadcast message as per the</p></td></tr><tr style="height:11pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">EmberNodeId destination,</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int16u destination,</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Zigbee PRO specification. The message</p></td></tr><tr style="height:11pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">EmberApsFrame * apsFrame,</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">EmberApsFrame *apsFrame,</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">will be delivered to all nodes within radius</p></td></tr><tr style="height:11pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int8u radius,</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int8u messageLength,</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">hops of the sender. A radius of zero is</p></td></tr><tr style="height:11pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">EmberMessageBuffer message</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int8u* message</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">converted to EMBER_MAX_HOPS.</p></td></tr><tr style="height:16pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">)</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">)</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:168pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">emberSendMulticast (</p></td><td style="width:205pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">emberAfSendMulticast(</p></td><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Sends a multicast message to all end-</p></td></tr><tr style="height:11pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">EmberApsFrame * apsFrame,</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int16u multicastId,</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">points that share a specific multicast ID</p></td></tr><tr style="height:11pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int8u radius,</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">EmberApsFrame * apsFrame,</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">and are within a specified number of hops</p></td></tr><tr style="height:11pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int8u nonmemberRadius,</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int8u messageLength,</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">of the sender.</p></td></tr><tr style="height:11pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">EmberMessageBuffer message</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int8u* message</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:16pt"><td style="width:168pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">)</p></td><td style="width:205pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">)</p></td><td style="width:173pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p class="s7" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Note: <span class="p">Please keep in mind that the online API documentation is more extensive than that shown here. Always refer to the online API documentation for definitive information.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In every case illustrated above, a message buffer contains the message. Normally, the application allocates memory for this buffer (as some multiple of 32 bytes). You can find out dynamically how big this buffer can be, which in turn determines the maximum size of the message to be sent. The function <span class="s14">emberMaximumApsPayloadLength(void) </span>returns the maximum size of the payload that the applica- tion support sub-layer will accept, depending on the security level in use. This means that:</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Constructing your message involves supplying the arguments for the appropriate message type <span class="s14">emberSend... </span>function.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Use <span class="s14">emberMaximumApsPayloadLength(void) </span>to determine how big your message can be.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Executing the <span class="s14">emberSend... </span>function causes your message to be sent.</p></li></ul><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Normally, the <span class="s14">emberSend... </span>function returns a value. Check the online API documentation for further information.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">While the task of sending a message is a bit complex, it is also very consistent. The challenge in designing your application is to keep track of the argument values and the messages to be sent. Some messages may have to be sent in partial segments and some may have to be resent if an error occurs. Your application must deal with the consequences of these possibilities.</p></li><li><p class="s7" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark30">Receiving Messages</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Unlike sending messages, receiving messages is a more open-ended process. The application is notified when a message has been received, but the application must decide what to do with it and how to respond to it. Zigbee Application Framework-based applications use a variety of different callback functions devoted to the specific command or response represented by the message, such as <span class="s14">emberAfReadAttributesResponseCallback </span>or <span class="s14">emberAfDemandResponseLoadControlClusterLoadControlEventCallback</span>. See document <i>UG391: Zigbee Application Framework Developer&#39;s Guide</i>, for details about how the framework processes incoming messages and about the available callbacks for handling these in your application.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">It is also important to note that the stack doesn’t detect or filter duplicate packets in the APS layer. Nor does it guarantee in-order mes- sage delivery. These mechanisms need to be implemented by the application.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">In the case of the SoC, the stack deals with the mechanics of receiving and storing a message. But in the case of the NCP, the mes- sage is passed directly to the host. The host must deal with receiving and storing the message in addition to reacting to the message contents.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In all cases, the application must parse the message into its constituent parts and decide what to do with the information. Note that the application framework, as part of the application, performs most of the message parsing. The application framework does still give the application developer complete flexibility and control over message receive processing. Messages can be generally divided into two broad categories: command or data messages. Command messages involve the operation of the target as a functional member of the network (including housekeeping commands). Data messages are informational to the application, although they may deal with the functionality of a device with which the node is interfaced, such as a temperature sensor.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-top: 5pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark31">Acknowledging Messages</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">When a message is received, it is good network protocol to acknowledge receipt of the message. This is done automatically in the stack software at the MAC layer with a Link ACK, requiring no action by the application. The following figure shows node A sending a message to node D.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 202pt;text-indent: 0pt;text-align: left;"><span><img width="239" height="111" alt="image" src="ug103-03-fundamentals-design-choices/Image_008.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 100pt;text-indent: 0pt;text-align: center;">Figure 3.2.  Link ACK</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Applications receive a callback when the delivery process completes. The callback indicates success or failure of the delivery based on the receipt or lack of the ACK, either the APS [end-to-end] ACK if requested or the MAC [link] ACK if not. ) Developers therefore can read the success or failure of the delivery process and optionally retry the delivery at the application level, if desired.</p></li></ol></li><li><p class="s7" style="padding-top: 8pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark32">NCP and Host Application Compatibility</a></p></li></ol></li></ol><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">It is very important to ensure that the NCP application has the necessary core functionality so that the host processor can rely upon the NCP to perform its networking functions. For example, if a host application needs to be able to send one type of messages, the NCP must contain support for handling that type of EZSP commands from the host processor.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Compatibility is determined differently, depending on if you are building a custom NCP image or using one of the Silicon Labs pre-built firmware images. If you are building a custom NCP image with the Network Coprocessor Application Framework, then you need to in- clude library plugins that contain the functionality your host application wants to perform If a host application is receiving a lot of EZSP_ERROR_INVALID_FRAME_ID error values from the NCP, rebuild the image to include the library that is related to these com- mands.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">If instead you are using the prebuilt firmware images, then the process is a simpler. The current prebuilt offerings include all-encom- passing NCP images that can properly handle any EZSP frame that is sent from a host built using the Zigbee Application Framework.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The following table is designed to help pair a host application with a suitable NCP application (ZAF = Zigbee Application Framework).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 100pt;text-indent: 0pt;text-align: center;">Table 3.3.  Host and NCP Application Compatibility</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:360pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="2" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 143pt;padding-right: 143pt;text-indent: 0pt;text-align: center;">Host Application</p></td></tr><tr style="height:30pt"><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">NCP Application (<i>image name</i><span class="s13">)</span></p></td><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 7pt;padding-right: 7pt;text-indent: 0pt;text-align: center;">Single Zigbee PRO Network (ZAF)</p></td><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 78pt;padding-right: 2pt;text-indent: -74pt;text-align: left;">Dual Zigbee PRO + Zigbee PRO Network (ZAF)</p></td></tr><tr style="height:92pt"><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 6pt;text-indent: 0pt;text-align: left;">Custom NCP application (Network Cop- rocessor Application Framework)</p></td><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 7pt;padding-right: 7pt;text-indent: 0pt;text-align: center;">YES</p><p class="s13" style="padding-top: 8pt;padding-left: 7pt;padding-right: 7pt;text-indent: 0pt;text-align: center;">Functionality in the host application must be mirrored with corresponding plugins in the NCP configuration.</p></td><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 7pt;padding-right: 7pt;text-indent: 0pt;text-align: center;">YES</p><p class="s13" style="padding-top: 8pt;padding-left: 4pt;padding-right: 3pt;text-indent: 0pt;text-align: center;">Functionality in the host application must be mirrored with corresponding plugins in the NCP configuration. For multi-network host configurations, the multi-network-li- brary must be included in the NCP configu- ration.</p></td></tr><tr style="height:30pt"><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 22pt;text-indent: 0pt;text-align: left;">All-encompassing NCP applications (<i>ncp-spi, ncp-uart</i><span class="s13">)</span></p></td><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 7pt;padding-right: 7pt;text-indent: 0pt;text-align: center;">YES</p></td><td style="width:180pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s13" style="padding-top: 3pt;padding-left: 7pt;padding-right: 7pt;text-indent: 0pt;text-align: center;">YES</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 17pt;text-indent: 0pt;text-align: left;">Smart. Connected. Energy-Friendly.</h4><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="text-indent: 0pt;line-height: 9pt;text-align: center;">Products</p><p style="text-indent: 0pt;text-align: center;"><a href="http://www.silabs.com/products">www.silabs.com/products</a></p><p class="s17" style="text-indent: 0pt;line-height: 9pt;text-align: center;">Quality</p><p style="text-indent: 0pt;text-align: center;"><a href="http://www.silabs.com/quality">www.silabs.com/quality</a></p><p class="s17" style="text-indent: 0pt;line-height: 9pt;text-align: center;">Support and Community</p><p class="s18" style="text-indent: 0pt;text-align: center;">community.silabs.com</p><p style="padding-left: 64pt;text-indent: 0pt;text-align: left;"><span style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt;">		</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="767" height="695" alt="image" src="ug103-03-fundamentals-design-choices/Image_009.png"/></span></p><p class="s19" style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Disclaimer</p><p class="s20" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Silicon Labs intends to provide customers with the latest, accurate, and in-depth documentation of all peripherals and modules available for system and software implementers using or intending to use the Silicon Labs products. Characterization data, available modules and peripherals, memory sizes and memory addresses refer to each specific device, and &quot;Typical&quot; parameters provided can and do vary in different applications. Application examples described herein are for illustrative purposes only. Silicon Labs reserves the right to make changes without further notice to the product information, specifications, and descriptions herein, and does not give warranties as to the accuracy or completeness of the included information. Without prior notification, Silicon Labs may update product firmware during the manufacturing process for security or reliability reasons. Such changes will not alter the specifications or the performance of the product. Silicon Labs shall have no liability for the consequences of use of the information supplied in this document. This document does not imply or expressly grant any license to design or fabricate any integrated circuits. The products are not designed or authorized to be used within any FDA Class III devices, applications for which FDA premarket approval is required, or Life Support Systems without the specific written consent of Silicon Labs. A &quot;Life Support System&quot; is any product or system intended to support or sustain life and/or health, which, if it fails, can be reasonably expected to result in significant personal injury or death. Silicon Labs products are not designed or authorized for military applications. Silicon Labs products shall under no circumstances be used in weapons of mass destruction including (but not limited to) nuclear, biological or chemical weapons, or missiles capable of delivering such weapons. Silicon Labs disclaims all express and implied warranties and shall not be responsible or liable for any injuries or damages related to use of a Silicon Labs product in such unauthorized applications.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Trademark Information</p><p class="s20" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Silicon Laboratories Inc.®, Silicon Laboratories®, Silicon Labs®, SiLabs® and the Silicon Labs logo®, Bluegiga®, Bluegiga Logo®, ClockBuilder®, CMEMS®, DSPLL®, EFM®, EFM32®, EFR, Ember®, Energy Micro, Energy Micro logo and combinations thereof, &quot;the world’s most energy friendly microcontrollers&quot;, Ember®, EZLink®, EZRadio®, EZRadioPRO®, Gecko®, Gecko OS, Gecko OS Studio, ISOmodem®, Precision32®, ProSLIC®, Simplicity Studio®, SiPHY®, Telegesis, the Telegesis Logo®, USBXpress® , Zentri, the Zentri logo and Zentri DMS, Z- Wave®, and others are trademarks or registered trademarks of Silicon Labs. ARM, CORTEX, Cortex-M3 and THUMB are trademarks or registered trademarks of ARM Holdings. Keil is a registered trademark of ARM Limited. Wi-Fi is a registered trademark of the Wi-Fi Alliance. All other products or brand names mentioned herein are trademarks of their respective holders.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="152" height="75" alt="image" src="ug103-03-fundamentals-design-choices/Image_010.png"/></span></p><p class="s19" style="padding-left: 168pt;text-indent: 0pt;text-align: left;">Silicon Laboratories Inc. 400 West Cesar Chavez Austin, TX 78701</p><p class="s19" style="padding-left: 168pt;text-indent: 0pt;text-align: left;">USA</p><p style="padding-top: 5pt;padding-left: 168pt;text-indent: 0pt;text-align: left;"><h2 href="http://www.silabs.com/">http://www.silabs.com</h2></p></body></html>
