<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>UG103.4: HAL Fundamentals</title><meta name="author" content="Silicon Labs"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 h1 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 24pt; }
 .s1 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 6pt; }
 .s2 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s3 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .p, p { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; margin:0pt; }
 .s5 { color: #D81E2A; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 h3 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 .s7 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s8 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s9 { color: #FFF; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s10 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 h4 { color: #FFF; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s11 { color: #FFF; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 8pt; }
 a { color: #FFF; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s12 { color: #FFF; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s13 { color: #231F20; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 7pt; }
 .s14 { color: #231F20; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; }
 h2 { color: #D91F2A; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 li {display: block; }
 #l2 {padding-left: 0pt;counter-reset: d1 1; }
 #l2> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 #l3 {padding-left: 0pt; }
 #l3> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l4 {padding-left: 0pt; }
 #l4> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l5 {padding-left: 0pt; }
 #l5> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l6 {padding-left: 0pt;counter-reset: d2 1; }
 #l6> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l6> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l7 {padding-left: 0pt; }
 #l7> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l8 {padding-left: 0pt;counter-reset: d2 1; }
 #l8> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l8> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l9 {padding-left: 0pt;counter-reset: d2 1; }
 #l9> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l9> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l10 {padding-left: 0pt;counter-reset: d3 1; }
 #l10> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l10> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l11 {padding-left: 0pt; }
 #l11> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l12 {padding-left: 0pt; }
 #l12> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l13 {padding-left: 0pt; }
 #l13> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l14 {padding-left: 0pt;counter-reset: d2 1; }
 #l14> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l14> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l15 {padding-left: 0pt; }
 #l15> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 table, tbody {vertical-align: top; overflow: visible; }
</style></head><body><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span><img width="126" height="62" alt="image" src="ug103-04-fundamentals-hal/Image_001.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-top: 4pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">UG103.4: HAL Fundamentals</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="724" height="1" alt="image" src="ug103-04-fundamentals-hal/Image_002.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="207" height="1" alt="image" src="ug103-04-fundamentals-hal/Image_003.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">KEY POINTS</p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="208" height="1" alt="image" src="ug103-04-fundamentals-hal/Image_004.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l1"><li><p class="s2" style="padding-top: 4pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Provides information on how the HAL is organized, including naming conventions, API files, and directory structure.</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Includes an overview of each of the main subsections of the HAL functionality.</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Describes how to adapt the HAL to your specific hardware and application requirements.</p></li></ul><p style="text-indent: 0pt;text-align: left;"/><p class="s3" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Silicon Labs HAL (Hardware Abstraction Layer) is program code between a system’s hardware and its software that provides a consistent interface for applications that can run on several differ- ent hardware platforms. The HAL is designed for developers us- ing EmberZNet PRO with the EFR32MG family of products.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Silicon Labs’ <i>Fundamentals </i>series covers topics that project managers, application de- signers, and developers should understand before beginning to work on an embedded networking solution using Silicon Labs chips, networking stacks such as EmberZNet PRO or Silicon Labs <i>Bluetooth®</i>, and associated development tools. The documents can be used as a starting place for anyone needing an introduction to developing wire- less networking applications, or who is new to the Silicon Labs development environ- ment.</p><p class="s5" style="padding-bottom: 3pt;text-indent: 0pt;text-align: right;">Introduction</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="713" height="0" alt="image" src="ug103-04-fundamentals-hal/Image_005.png"/></span></p><ol id="l2"><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark0">Introduction</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Hardware Abstraction Layer (HAL) is program code between a system’s hardware and its software that provides a consistent inter- face for applications that can run on several different hardware platforms. To take advantage of this capability, applications should ac- cess hardware through the API provided by the HAL, rather than directly. Then, when you move to new hardware, you only need to update the HAL. In some cases, due to extreme differences in hardware, the HAL API may also change slightly to accommodate the new hardware. In these cases, the limited scope of the update makes moving the application easier with the HAL than without.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The introductory parts of this document are recommended for all software developers who are using EmberZNet PRO. Developers needing to modify the HAL or port it to new a hardware platform will want to read the entire document to understand how to make changes while meeting the requirements of the networking stack.</p><p class="s5" style="padding-bottom: 3pt;text-indent: 0pt;text-align: right;">HAL API Organization</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="713" height="0" alt="image" src="ug103-04-fundamentals-hal/Image_006.png"/></span></p></li><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark1">HAL API Organization</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="#bookmark14" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;">The HAL API is organized into the following functional sections, which are described in section </a><span style=" color: #049; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;">5. HAL API Description</span>:</p><ul id="l3"><li><p class="s7" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Common microcontroller functions: <span class="p">APIs for control of the MCU behavior and configuration.</span></p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;"><b>Token access: </b>APIs for token acces, Simulated EEPROM (SimEEPROM) access, and NVM3 access. For an introduction to the token system, see document <i>UG103.7: Non-Volatile Data Storage Fundamentals</i>.</p></li><li><p class="s7" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Sample APIs for Peripheral access: <span class="p">APIs for controlling and accessing system peripherals.</span></p></li><li><p class="s7" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">System timer control: <span class="p">APIs for controlling and accessing the system timers.</span></p></li><li><p class="s7" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Symbol timer control: <span class="p">APIs for accessing the symbol timer for the radio.</span></p></li><li><p class="s7" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">HAL configuration: <span class="p">Miscellaneous API modules for board and chip configuration.</span></p></li><li><p class="s7" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">HAL utilities: <span class="p">General-purpose APIs that may rely on hardware capabilities (for example, CRC calculation that may take advantage of hardware acceleration).</span></p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;"><b>Bootloader interfaces: </b>APIs for interfacing with Gecko bootloader and Ember legacy bootloaders. The use of bootloading is re- viewed in the document <i>UG103.6: Bootloader Fundamentals</i>.</p><p class="s5" style="padding-bottom: 3pt;text-indent: 0pt;text-align: right;">Naming Conventions</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="713" height="0" alt="image" src="ug103-04-fundamentals-hal/Image_007.png"/></span></p></li></ul></li><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><a name="bookmark2">Naming Conventions</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">HAL function names have the following prefix conventions:</p><ul id="l4"><li><p class="s8" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">hal: <span class="p">The API Sample applications use. You can remove or change the implementations of these functions as needed.</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">halCommon: <span class="p">The API used by the stack and that can also be called from an application. Custom HAL modifications must maintain the functionality of these functions.</span></p></li><li><p class="s8" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">halStack: <span class="p">Only the stack uses this API. These functions should not be directly called from any application, as this may violate tim- ing constraints or cause re-entrancy problems. Custom HAL modifications must maintain the functionality of these functions.</span></p></li><li><p class="s8" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">halInternal: <span class="p">The API that is internal to the HAL. These functions are not called directly from the stack and should not be called directly from any application. They are called only from </span>halStack <span class="p">or </span>halCommon <span class="p">functions. You can modify these functions, but be careful to maintain the proper functionality of any dependent </span>halStack <span class="p">or </span>halCommon <span class="p">functions.</span></p></li></ul><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Most applications will call <span class="s8">halXXX </span>and <span class="s8">halCommonXXX </span>functions and will not need to modify the HAL. If you need a special implementa- tion or modification of the HAL, be sure to read the rest of this document as well as the data sheet for your Silicon Labs platform first.</p><p class="s5" style="padding-bottom: 3pt;text-indent: 0pt;text-align: right;">API Files and Directory Structure</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="713" height="0" alt="image" src="ug103-04-fundamentals-hal/Image_008.png"/></span></p></li><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark3">API Files and Directory Structure</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">The HAL directory structure and files are organized to facilitate independent modification of the compiler, the MCU, and the PCB config- uration. <span class="s8">&lt;hal&gt; </span>represents the directory <span class="s8">developer/sdks/gecko_sdk_suite/&lt;version&gt;/platform/base/hal </span>under the Simplicity Studio installation.</p><ul id="l5"><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">&lt;hal&gt;/hal.h<span class="p">: This master include file comprises all other relevant HAL include files, and you should include it in any source file that uses the HAL functionality. Most programs should not include lower-level includes, and instead should include this top-level </span>hal.h<span class="p">.</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">&lt;hal&gt;/ember-base-configuration.c: <span class="p">This file defines the storage for compile-time configurable stack variables and implements default implementations of functions. You can customize many of these functions by defining a preprocessor variable at compile- time and implementing a custom version of the function in the application. (For more information, see </span>ember-configuration- defaults.h <span class="p">in the API Reference for your software).</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">&lt;hal&gt;/micro/generic<span class="p">: This directory contains files used for general MCUs on POSIX-compliant systems. The default compiler is GCC.</span></p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l6"><li><p class="s7" style="padding-top: 5pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark4">HAL Implementation for ARM Cortex-M3 SOC Platforms</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">There is a HAL implementation for the ARM Cortex-M3 System on Chip (SOC) platforms as follows:</p><ul id="l7"><li><p class="s8" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">&lt;hal&gt;/micro/cortexm3: <span class="p">Contains the implementation of the HAL for the cortexm3, which is the processor core used by the EFR32 platform. Functions in this directory are specific to the cortexm3 but are not specific to a particular microcontroller family or variant (see the next entry).</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">&lt;hal&gt;/micro/cortexm3/{mcu_family}: <span class="p">Implements functions that are specific to the a particular MCU family, such as </span>&lt;hal&gt;/ micro/cortexm3/efm32 <span class="p">for the EFR32MG.</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">&lt;hal&gt;/micro/cortexm3/bootloader<span class="p">: Implements functions that pertain to the on-chip bootloaders used on Cortex M3-based plat- forms to facilitate runtime loading/updating of applications. (More MCU-specific files can be found in </span>&lt;hal&gt;/micro/cortexm3/</p><p class="s8" style="padding-left: 36pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{mcu_family}/bootloader<span class="p">.)</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">&lt;hal&gt;/micro/cortexm3/{mcu_family}/config<span class="p">: Contains default settings for different EMDRV peripherals relied upon by the HAL.</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">&lt;hal&gt;/micro/cortexm3/{mcu_family}/hal-config<span class="p">: Additional hardware configuration symbols relied upon by the bootloader.</span></p></li></ul></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark5">HAL API Description</a><a name="bookmark14">&zwnj;</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;"><a href="https://docs.silabs.com/" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;" target="_blank">This section gives an overview of each of the main subsections of the HAL functionality. The HAL reference manual is included as part of the EmberZNet API reference included with the EmberZNet PRO SDK installation and online at </a><span style=" color: #049; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;">https://docs.silabs.com/</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l8"><li><p class="s7" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark6">Common Microcontroller Functions</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Common microcontroller functions include <span class="s8">halInit()</span>, <span class="s8">halSleep()</span>, and <span class="s8">halReboot()</span>. Most applications will only need to call <span class="s8">halInit()</span>, <span class="s8">halSleep() </span>(usually only ZEDs), and <span class="s8">halResetWatchdog(</span>). The functions <span class="s8">halInit()</span>, <span class="s8">halSleep()</span>, <span class="s8">halPowerUp()</span>, <span class="s8">halPowerDown()</span>, and so on call the proper functions defined in the board header file to initialize or power down any board-level periph- erals.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-top: 5pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark7">Token Access and Non-Volatile Data Storage</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The networking stack uses persistent storage to maintain manufacturing and network configuration information when power is lost or the device is rebooted. This data is stored in tokens. A token consists of two parts: a key used to map to the physical location, and data associated with that key. Using this key-based system hides the data’s location from the application, which allows support for different storage mechanisms and the use of flash wear-leveling algorithms to reduce flash usage.</p><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;"><b>Note: </b>For more information about the Silicon Labs token system, refer to both the <span class="s8">token.h </span>file and documents <i>UG103.7: Non-Volatile Data Storage Fundamentals </i>and <i>AN1154: Using Tokens for Non-Volatile Data Storage</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Because EFR32 process technology does not offer an internal EEPROM, non-volatile data storage is implemented to use a section of internal flash memory for stack and application token storage. Parts that use non-volatile data storage have different levels of flash per- formance with respect to guaranteed write cycles. (See the Reference Manual for your specific MCU for details about minimum flash endurance expected over lifetime and temperature variations.).</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Silicon Labs offers several implementations of non-volatile data storage. For the EFR32 platform, two versions of a simulated EE- PROM, also referred to as SimEE, are available. For version 1, the ARM Cortex MCUs utilize either 4 kB or 8 kB (default) of upper flash memory to store the simulated EEPROM. For version 2, the simulated EEPROM requires 36 kB of upper flash storage. Finally, a third generation Non-Volatile Memory (NVM3) data storage driver is also available. It may be used with Connect and Bluetooth to support dynamic multiprotocol applications. Due to the limited write cycles, all versions implement a wear-leveling algorithm that effectively ex- tends the number of write cycles for individual tokens.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For an in-depth discussion of the simulated EEPROM, its design, its usage, and other considerations, refer to document <i>AN703: Using Simulated EEPROM Version 1 and Version 2 for the EFR32 Series 1 SoC Platform</i>. For similar details about NVM3, see <i>AN1135: Us- ing Third Generation Non-Volatile Memory (NVM3) Data Storage</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark8">Sample APIs for Peripheral Access</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The networking stack requires access to certain on-chip peripherals; additionally, applications may use other on-chip or on-board pe- ripherals. The default HAL provides implementations for all required peripherals and also for some commonly used peripherals. Silicon Labs recommends that developers implement additional peripheral control within the HAL framework to facilitate easy porting and up- grade of the stack in the future.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The sample APIs in this section (ADC, BUTTON, BUZZER, LED) illustrate how to use the pins that are defined through the hardware configurator. The other APIs (Serial UART communication and Flash Memory) are not samples. Flash memory contains the API for erasing flash.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark9">System Timer Control</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The networking stack uses the system timer to control low-resolution timing events on the order of seconds or milliseconds. High-reso- lution (microsecond-scale) timing is managed internally through interrupts. Silicon Labs encourages developers to use the system timer control or the event controls whenever possible; this helps to avoid replicating functionality and using scarce flash space unnecessarily. For example, you can use the function <span class="s8">halCommonGetInt16uMillisecondTick() </span>to check a previously stored value against the cur- rent value and implement a millisecond-resolution delay.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark10">Symbol Timer Control</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The APIs in this section are used by the Zigbee MAC layer and should not be called directly.</p></li><li><p class="s7" style="padding-top: 8pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark11">HAL Configuration</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The macros in Common PLATFORM_HEADER configuration are widely used throughout the EmberZNet code. This module serves as a reference. IAR_PLATFORM_HEADER configuration contains macros used with IAR ARM C compiler. The Nested Vectored Interrupt Controller (NVIC) configuration header should not be modified.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark12">HAL Utilities</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The HAL utilities include general-purpose APIs that may rely on hardware capabilities (for example, CRC calculation that may take ad- vantage of hardware acceleration). Crash and watchdog diagnostics, random number generation, and CRC calculation are provided by default in the HAL utilities.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark13">Bootloader Interfaces</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Bootloading functionality is also abstracted in the HAL interface. Refer to the HAL API reference as well as document <i>UG103.6: Boot- loader Fundamentals </i>for a review of the use and implementation of the bootloaders.</p></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark15">Customizing the HAL</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">This section describes how to adapt the Silicon Labs-supplied standard HAL to your specific hardware and application requirements.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l9"><li><p class="s7" style="padding-top: 5pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark16">Compile-Time Configuration</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The following preprocessor definitions are used to configure the networking stack HAL. They are usually defined in the Project file, but depending on the compiler configuration they may be defined in any global preprocessor location.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l10"><li><p class="s7" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark17">Required Definitions</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The following preprocessor definitions must be defined:</p><ul id="l11"><li><p class="s8" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">PLATFORM_HEADER: <span class="p">The location of the platform header file. For example, </span>hal/micro/cortexm3/compiler/iar.h<span class="p">.</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">PLATFORMNAME <span class="p">(for example, CORTEXM3).</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">PLATFORMNAME_MICRONAME <span class="p">(for example, CORTEXM3_EFR32).</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">PHY_PHYNAME <span class="p">(for example PHY_EFR32).</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">BOARD_BOARDNAME <span class="p">(for example, BOARD_BRD4151A).</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">CONFIGURATION_HEADER: <span class="p">Provides additional custom configuration options for </span>ember-base-configuration.c<span class="p">.</span></p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark18">Optional Definitions</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The following preprocessor definitions are optional:</p><ul id="l12"><li><p class="s8" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">APPLICATION_TOKEN_HEADER: <span class="p">When using custom token definitions, this preprocessor constant is the location of the custom token definitions file. Note that AppBuilder provides an option to populate a custom token header. Even if that is not enabled, AppBuilder always defines this symbol to point to its own token header.</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">DISABLE_WATCHDOG: <span class="p">This preprocessor definition can completely disable the watchdog without editing code. Use this definition very sparingly and only in utility or test applications, because the watchdog is critical for robust applications.</span></p></li><li><p class="s8" style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">COM_USARTn_ENABLE <span class="p">(</span>n <span class="p">is the appropriate UART port). This enables writing and reading from the specified UART. This is typically defined in </span>com_device.h<span class="p">.</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">COM_n_RX_QUEUE_SIZE <span class="p">= size of the receive queue in bytes (</span>n <span class="p">is the appropriate UART port). If undefined, the default is 64 bytes.</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">COM_n_TX_QUEUE_SIZE <span class="p">= size of the transmit queue in bytes (</span>n <span class="p">is the appropriate UART port). If undefined, the default is 128 bytes.</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">COM_USARTn_HW_FC <span class="p">or </span>COM_USARTn_SW_FC <span class="p">(</span>n <span class="p">is the appropriate UART port). This enables hardware or software flow control, respec- tively.</span></p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s7" style="padding-top: 5pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark19">Custom PCBs</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For the EFR32, use the Hardware Configurator to create a custom GPIO configuration for your target hardware.</p></li><li><p class="s7" style="padding-top: 8pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark20">Modifying the Default Implementation</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The functionality of the networking stack HAL is grouped into source modules with similar functionality. These modules—the source files—can be easily replaced individually, allowing for custom implementations of their functionality. The following table summarizes the HAL source modules.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 224pt;text-indent: 0pt;text-align: center;">Table 6.1.  HAL Source Modules</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s9" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Source Module</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s9" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:19pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Adc</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Sample functionality for accessing analog-to-digital converters built into the SoC.</p></td></tr><tr style="height:19pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">bootloader-interface-app</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">APIs for using the application bootloader.</p></td></tr><tr style="height:19pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">bootloader-interface-standalone</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">APIs for using the standalone bootloader.</p></td></tr><tr style="height:30pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Button</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;padding-right: 9pt;text-indent: 0pt;text-align: left;">Sample functionality that can be used to access the buttons built into the development kit carrier boards.</p></td></tr><tr style="height:30pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">buzzer</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;padding-right: 4pt;text-indent: 0pt;text-align: left;">Sample functionality that can play notes and short tunes on the buzzer built into the devel- opment kit carrier boards.</p></td></tr><tr style="height:30pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">crc</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;padding-right: 6pt;text-indent: 0pt;text-align: left;">APIs that can be used to calculate a standard 16-bit CRC or a 16-bit CCITT CRC as used by 802.15.4</p></td></tr><tr style="height:30pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">diagnostic</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;text-align: left;">Sample functionality that can be used to help diagnose unknown watchdog resets and oth- er unexpected behavior.</p></td></tr><tr style="height:19pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Flash</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Internal HAL utilities used to read, erase, and write Flash in the SoC.</p></td></tr><tr style="height:19pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Led</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Sample functionality that can be used to manipulate LEDs.</p></td></tr><tr style="height:19pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">mem-util</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Common memory manipulation APIs such as memcopy.</p></td></tr><tr style="height:30pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Micro</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;padding-right: 9pt;text-indent: 0pt;text-align: left;">Core HAL functionality to initialize, put to sleep, shutdown, and reboot the microcontroller and any associated peripherals.</p></td></tr><tr style="height:30pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Random</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;padding-right: 23pt;text-indent: 0pt;text-align: left;">APIs that implement a simple pseudo-random number generator that is seeded with a true-random number when the stack is initialized.</p></td></tr><tr style="height:19pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">sim-eeprom</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Simulated EEPROM system for storage of tokens in the SoC.</p></td></tr><tr style="height:19pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Spi</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">APIs that are used to access the SPI peripherals.</p></td></tr><tr style="height:19pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">symbol-timer</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">APIs that implement the highly accurate symbol timer required by the stack.</p></td></tr><tr style="height:19pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">system-timer</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">APIs that implement the basic millisecond time base used by the stack.</p></td></tr><tr style="height:19pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Token</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">APIs to access and manipulate persistent data used by the stack and many applications.</p></td></tr><tr style="height:19pt"><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Uart</p></td><td style="width:367pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s10" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Low-level sample APIs used by the serial utility APIs to provide serial input and output.</p></td></tr></table><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Before modifying these peripherals, be sure you are familiar with the naming conventions and the hardware data sheet, and take care to adhere to the original contract of the function being replaced. Silicon Labs recommends that you contact Customer Support before beginning any customization of these functions to determine the simplest way to make the required changes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark21">Hardware Configurator</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For EmberZNet applications on the EFR32 platforms, instead of configuration by editing header files, peripherals can be configured using the Hardware Configurator in Simplicity Studio. The Hardware Configurator simplifies peripheral configuration by presenting pe- ripherals and peripheral properties in a graphical user interface. Many peripherals can also be configured from within the Simplicity IDE as plugin options. See <i>AN1115: Configuring Peripherals for 32-Bit Devices using Hardware Configurator </i>for more information.</p><p class="s5" style="padding-bottom: 3pt;text-indent: 0pt;text-align: right;">Debug Channel</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="713" height="0" alt="image" src="ug103-04-fundamentals-hal/Image_009.png"/></span></p></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark22">Debug Channel</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">The networking stack HAL implements a debug channel for communication with Simplicity Studio. The debug channel provides a two- way out-of-band mechanism for the stack and customer applications to send debugging statistics and information to Simplicity Studio for large-scale analysis. The functionality enabled depends on the debug library plugins selected.</p><ul id="l13"><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">Debug Basic Library: Provides node reset message, assert output, core dump output, virtual UART input and output, and basic node information request and response (NodeInfo events).</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: justify;">Debug Extended Library (requires Debug Basic Library): Provides API call trace output, debug error output, and debug printf output. Required for virtual UART input and output on the EFR32. Applications with this library enabled will be large than those with Debug Basic only.</p></li></ul><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Note: For virtual UART support, the HAL plugin Debug JTAG (not the stub) must also be enabled.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">If neither library is enabled, there is no SerialWire interfacing, therefore no Virtual UART and no Network Analyzer event tracing other than the Packet Trace Interface (PTI). PTI uses a debug adapter such as the ISA3 or Wireless Starter Kit (WSTK) but doesn&#39;t rely on SerialWire. On the ARM Cortex platforms, the Serial Wire interface is used for a debug channel in addition to development environ- ment-level debugging.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l14"><li><p class="s7" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark23">Virtual UART</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">EmberZNet supports virtual UART (VUART) functionality through separate libraries that provide debug functionality. VUART, also called “two-way debug”, allows normal serial APIs to still be used on the port being used by the debug channel (SerialWire interface) for debug input and output. When enabled,Virtual UART is designated in software as serial port 0.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For the EFR32, VUART functionality not only requires the plugins configured as in the previous section, but also some configuration through the Hardware Configurator. In the GPIO peripheral, the <b>SerialWire Output Pin </b>must be enabled (can also be configured through the Debug JTAG plugin interface). The Serial VUART peripheral must be enabled and the <b>VUART type </b>must be set to <b>VUART via SWO</b>.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;"><b>Note: </b>Virtual UART is different from the virtual COM port support, known as “VCOM”, provided in the EFR32 Board Support Package (BSP) via <span class="s8">com_device.h</span>. VCOM routes the physical serial port connections of USART0 back through the WSTK’s onboard TTL-to-USB converter for use as a communications port by a USB host. VCOM and VUART are independent of one another and can be enabled separately, together, or not at all.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">When VUART support is enabled, serial output sent to port 0 is encapsulated in the debug channel protocol and sent bidirectionally via the SWO and SWDIO lines through the debug adapter (ISA3 or WSTK). The raw serial output will be displayed by Simplicity Studio’s Device Console tool, and will also appear on port 4900 of the debug adapter. Similarly, data sent to port 4900 of the adapter will be encapsulated in the debug channel protocol and sent to the node. The raw input data can then also be read using the normal serial APIs.</p><p style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;line-height: 19pt;text-align: left;">VUART provides an additional port for output with debug builds that would otherwise not be available. The following behaviors for VUART differ from normal serial UART behavior:</p><ul id="l15"><li><p class="s8" style="padding-top: 1pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">emberSerialWaitSend() <span class="p">does not wait for data to finish transmitting</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">emberSerialGuaranteedPrintf() <span class="p">is not guaranteed</span></p></li><li><p class="s8" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">EMBER_SERIALn_BLOCKING <span class="p">might not block</span></p></li></ul><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">More serial output might be dropped than normal depending on how busy the processor is with other stack functions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s7" style="padding-top: 6pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark24">Packet Trace Support</a></p></li></ol></li></ol><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The networking stack supports a PacketTrace interface (PTI) for use with Simplicity Studio. This capability allows Simplicity Studio to see all packets that are received and transmitted by all nodes in a network with no intrusion on the operation of those nodes. The Pack- etTrace interface works with the radio modules supplied in the development kits but can also be enabled on custom hardware designs.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Custom nodes must have a Packet Trace Port (part of the Mini-Simplicity Connector interface on EFR32-based designs) to use Packet Trace functionality. In addition to the proper hardware connections (such as FRC_DFRAME/FRC_DATA for EFR32-based designs), to use Packet Trace functionality the Hardware Configurator&#39;s PTI peripheral allows you to configure the DFRAME and DOUT pins as well as mode and PTI baud rate.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">PTI is available regardless of what Debug libraries are enabled, because this support is provided by the hardware. Disabling this inter- face requires that the PTI_FRAME and PTI_DATA pins be assigned to different GPIO functions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 17pt;text-indent: 0pt;text-align: left;">Smart. Connected. Energy-Friendly.</h4><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="text-indent: 0pt;line-height: 9pt;text-align: center;">Products</p><p style="text-indent: 0pt;text-align: center;"><a href="http://www.silabs.com/products">www.silabs.com/products</a></p><p class="s11" style="text-indent: 0pt;line-height: 9pt;text-align: center;">Quality</p><p style="text-indent: 0pt;text-align: center;"><a href="http://www.silabs.com/quality">www.silabs.com/quality</a></p><p class="s11" style="text-indent: 0pt;line-height: 9pt;text-align: center;">Support and Community</p><p class="s12" style="text-indent: 0pt;text-align: center;">community.silabs.com</p><p style="padding-left: 64pt;text-indent: 0pt;text-align: left;"><span style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt;">		</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="767" height="695" alt="image" src="ug103-04-fundamentals-hal/Image_010.png"/></span></p><p class="s13" style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Disclaimer</p><p class="s14" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Silicon Labs intends to provide customers with the latest, accurate, and in-depth documentation of all peripherals and modules available for system and software implementers using or intending to use the Silicon Labs products. Characterization data, available modules and peripherals, memory sizes and memory addresses refer to each specific device, and &quot;Typical&quot; parameters provided can and do vary in different applications. Application examples described herein are for illustrative purposes only. Silicon Labs reserves the right to make changes without further notice to the product information, specifications, and descriptions herein, and does not give warranties as to the accuracy or completeness of the included information. Without prior notification, Silicon Labs may update product firmware during the manufacturing process for security or reliability reasons. Such changes will not alter the specifications or the performance of the product. Silicon Labs shall have no liability for the consequences of use of the information supplied in this document. This document does not imply or expressly grant any license to design or fabricate any integrated circuits. The products are not designed or authorized to be used within any FDA Class III devices, applications for which FDA premarket approval is required, or Life Support Systems without the specific written consent of Silicon Labs. A &quot;Life Support System&quot; is any product or system intended to support or sustain life and/or health, which, if it fails, can be reasonably expected to result in significant personal injury or death. Silicon Labs products are not designed or authorized for military applications. Silicon Labs products shall under no circumstances be used in weapons of mass destruction including (but not limited to) nuclear, biological or chemical weapons, or missiles capable of delivering such weapons. Silicon Labs disclaims all express and implied warranties and shall not be responsible or liable for any injuries or damages related to use of a Silicon Labs product in such unauthorized applications.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Trademark Information</p><p class="s14" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Silicon Laboratories Inc.®, Silicon Laboratories®, Silicon Labs®, SiLabs® and the Silicon Labs logo®, Bluegiga®, Bluegiga Logo®, ClockBuilder®, CMEMS®, DSPLL®, EFM®, EFM32®, EFR, Ember®, Energy Micro, Energy Micro logo and combinations thereof, &quot;the world’s most energy friendly microcontrollers&quot;, Ember®, EZLink®, EZRadio®, EZRadioPRO®, Gecko®, Gecko OS, Gecko OS Studio, ISOmodem®, Precision32®, ProSLIC®, Simplicity Studio®, SiPHY®, Telegesis, the Telegesis Logo®, USBXpress® , Zentri, the Zentri logo and Zentri DMS, Z- Wave®, and others are trademarks or registered trademarks of Silicon Labs. ARM, CORTEX, Cortex-M3 and THUMB are trademarks or registered trademarks of ARM Holdings. Keil is a registered trademark of ARM Limited. Wi-Fi is a registered trademark of the Wi-Fi Alliance. All other products or brand names mentioned herein are trademarks of their respective holders.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="152" height="75" alt="image" src="ug103-04-fundamentals-hal/Image_011.png"/></span></p><p class="s13" style="padding-left: 168pt;text-indent: 0pt;text-align: left;">Silicon Laboratories Inc. 400 West Cesar Chavez Austin, TX 78701</p><p class="s13" style="padding-left: 168pt;text-indent: 0pt;text-align: left;">USA</p><p style="padding-top: 5pt;padding-left: 168pt;text-indent: 0pt;text-align: left;"><h2 href="http://www.silabs.com/">http://www.silabs.com</h2></p></body></html>
