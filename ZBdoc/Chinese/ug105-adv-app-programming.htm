<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>UG105: Advanced Application Programming with the Stack and HAL APIs</title><meta name="author" content="Silicon Labs"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 h1 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 24pt; }
 .s1 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: underline; font-size: 6pt; }
 .s2 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s3 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .p, p { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; margin:0pt; }
 .s6 { color: #D81E2A; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 h3 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 .s7 { color: #049; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s8 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s9 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s10 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s11 { color: #FFF; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s12 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 h4 { color: #FFF; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s14 { color: #FFF; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 8pt; }
 .s15 { color: #FFF; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s16 { color: #FFF; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s17 { color: #231F20; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 7pt; }
 .s18 { color: #231F20; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; }
 h2 { color: #D91F2A; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 li {display: block; }
 #l2 {padding-left: 0pt;counter-reset: d1 1; }
 #l2> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 #l3 {padding-left: 0pt; }
 #l3> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l4 {padding-left: 0pt;counter-reset: d2 1; }
 #l4> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l4> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l5 {padding-left: 0pt; }
 #l5> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l6 {padding-left: 0pt;counter-reset: d3 1; }
 #l6> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l6> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l7 {padding-left: 0pt;counter-reset: d3 1; }
 #l7> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l7> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l8 {padding-left: 0pt;counter-reset: d4 1; }
 #l8> li>*:first-child:before {counter-increment: d4; content: counter(d4, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l8> li:first-child>*:first-child:before {counter-increment: d4 0;  }
 #l9 {padding-left: 0pt;counter-reset: d3 1; }
 #l9> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l9> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l10 {padding-left: 0pt; }
 #l10> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l11 {padding-left: 0pt; }
 #l11> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l12 {padding-left: 0pt; }
 #l12> li>*:first-child:before {content: "* "; color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l13 {padding-left: 0pt;counter-reset: d2 1; }
 #l13> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l13> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l14 {padding-left: 0pt; }
 #l14> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l15 {padding-left: 0pt;counter-reset: d3 1; }
 #l15> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l15> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l16 {padding-left: 0pt; }
 #l16> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l17 {padding-left: 0pt; }
 #l17> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l18 {padding-left: 0pt;counter-reset: d4 1; }
 #l18> li>*:first-child:before {counter-increment: d4; content: counter(d4, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l18> li:first-child>*:first-child:before {counter-increment: d4 0;  }
 #l19 {padding-left: 0pt;counter-reset: m1 1; }
 #l19> li>*:first-child:before {counter-increment: m1; content: counter(m1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l19> li:first-child>*:first-child:before {counter-increment: m1 0;  }
 #l20 {padding-left: 0pt; }
 #l20> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l21 {padding-left: 0pt;counter-reset: d4 1; }
 #l21> li>*:first-child:before {counter-increment: d4; content: counter(d4, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l21> li:first-child>*:first-child:before {counter-increment: d4 0;  }
 #l22 {padding-left: 0pt; }
 #l22> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l23 {padding-left: 0pt;counter-reset: d3 1; }
 #l23> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l23> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l24 {padding-left: 0pt; }
 #l24> li>*:first-child:before {content: "* "; color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l25 {padding-left: 0pt; }
 #l25> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 table, tbody {vertical-align: top; overflow: visible; }
</style></head><body><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span><img width="126" height="62" alt="image" src="ug105-adv-app-programming/Image_001.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-top: 4pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">UG105: Advanced Application Programming with the Stack and HAL APIs</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="713" height="1" alt="image" src="ug105-adv-app-programming/Image_002.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 8pt;text-indent: 0pt;text-align: left;">KEY FEATURES                                                                   </p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l1"><li><p class="s2" style="padding-left: 17pt;text-indent: -7pt;text-align: left;">Background on the EmberZNet PRO API</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Details on network formation, sending and receiving messages, security, and more</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Application design requirements</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Application task requirements if creating the application from scratch</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Zigbee network rejoin strategies</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 17pt;text-indent: -7pt;text-align: left;">Zigbee messaging</p></li></ul><p style="text-indent: 0pt;text-align: left;"/><p class="s3" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">This <i>User&#39;s Guide </i>supports developers whose applications require functionality not available through AppBuilder and the Zigbee ap- plication framework, or who prefer working with an API.</p><p style="padding-top: 8pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">Before embarking on an API-based development initiative, if you have not already done so, you may wish to explore AppBuilder and the application framework. AppBuilder is a tool for generating Zigbee-compliant applications, and provides a graphical interface for turning on or off embedded clusters and features in the code. The Zigbee application framework is a superset of all source code needed to develop any Zigbee-compliant de- vice. See <i>UG391: Zigbee Application Framework Developer&#39;s Guide </i>for more informa- tion.</p><p class="s6" style="padding-bottom: 3pt;text-indent: 0pt;text-align: right;">Introduction</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="713" height="0" alt="image" src="ug105-adv-app-programming/Image_003.png"/></span></p><ol id="l2"><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark0">Introduction</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;">This <i>User&#39;s Guide </i>covers the following topics:</p><ul id="l3"><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Introduction to the EmberZNet PRO stack API.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Discussion of several advanced design issues to consider when developing an application using the API.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">An example application to draw upon as you begin your development initiative.</p></li></ul><p class="s7" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;"><a href="http://www.silabs.com/zigbee" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;" target="_blank">Development kit customers are eligible for training and technical support. You can use the Silicon Labs website </a>www.silabs.com/zigbee <a href="https://www.silabs.com/support" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;" target="_blank">to obtain information about all Silicon Labs products and services, and to sign up for product support. You can also contact Customer Support at </a>https://www.silabs.com/support<span style=" color: #000;">.</span></p></li><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark1">Introducing the EmberZNet PRO API</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 24pt;text-indent: 0pt;text-align: justify;"><a href="https://www.silabs.com/" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;" target="_blank">This chapter introduces the EmberZNet PRO API. The EmberZNet PRO API controls the EmberZNet PRO stack library and provides function calls and callbacks related to the network formation, discovery, joining, and messaging capabilities. For full reference docu- mentation of the functions and their parameters, see the API documentation for your Silicon Labs product at </a>silabs.com<span style=" color: #000;">.</span></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Silicon Labs recommends that software engineers new to EmberZNet PRO or those who are looking to refresh their understanding of the different components of the API read this chapter. You will see how the API can help you to quickly develop applications.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l4"><li><p class="s8" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark2">API Organization</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The EmberZNet PRO API is broken into 16 functional sections. This chapter provides a detailed introduction to six of the fundamental API sections:</p><ul id="l5"><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Network Formation</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Packet Buffers</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Sending and Receiving Messages</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">End Devices</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Security and Trust Center</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Event Scheduling</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The other functional sections are:</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Stack Information</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Common Data Types</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Binding Table</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Configuration</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Status Codes</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Stack Tokens</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Zigbee Device Object (ZDO)</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Bootloader</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Manufacturing and Functional Test Library</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Debugging Utilities</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-top: 5pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark3">Naming Conventions</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">All functions that are part of the public EmberZNet PRO API begin with the prefix <span class="s9">ember</span>. Silicon Labs strongly recommends that you maintain this convention when writing custom software so that it is easy to find information and documentation pertaining to a function.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-top: 5pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark4">API Files and Directory Structure</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The following list describes files within the stack that contain useful information.</p><p class="s9" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;stack&gt;/config/config.h: <span class="p">This file contains the stack build revision and can be used when communicating with technical support or when verifying that the stack version used is correct. The format of the version number is described in the file.</span></p><p class="s9" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">&lt;stack&gt;/config/ember-configuration-defaults.h: <span class="p">This file describes compile-time configurable options that affect the behavior of the EmberZNet PRO stack. These should be set in the CONFIGURATION_HEADER or in the Project so that the values are properly set in all files.</span></p><p class="s9" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">&lt;stack&gt;/include: <span class="p">This directory contains all the API header files. The correct ones for the application are included in ember.h, so the application usually only needs to include ember.h. The files can be useful as a reference source for advanced developers. The API reference documentation is generated from these header files.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-top: 5pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark5">Network Formation</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Silicon Labs provides a set of APIs you can use to find, form, join, and leave Zigbee networks.</p><ol id="l6"><li><p class="s8" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark6">Stack Initialization</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The EmberZNet PRO stack is initialized by calling <span class="s9">emberInit() </span>in the <span class="s9">main() </span>function. It may be passed a value for the reset code that can be used for debugging if the device is attached to a Debug Adapter with Simplicity Studio.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 21pt;text-indent: 0pt;text-align: left;"><span class="s10" style=" background-color: #D8D8D8;"> status = emberInit(reset);                                                                                       </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Note: <span class="s9">emberInit() </span>must be called before any other stack APIs are used, or the results will be undefined.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">For more information about debugging, see <i>UG104: Testing and Debugging Applications for the Silicon Labs EFR32MG Platforms</i>.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Calling <span class="s9">emberNetworkInit() </span>causes the device to rejoin the network that it was joined to before it rebooted. This maintains as many of the previous network settings as possible (for example, the network address is maintained if possible).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">if (emberNetworkInit() == EMBER_SUCCESS)) {</p><p class="s9" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">// Successfully rejoined previous network</p><p class="s9" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">} else {</p><p class="s9" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">// No previous network or could not successfully rejoin</p><p class="s9" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p class="s8" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Note: <span class="p">On development systems or systems that change device type (both ZR and ZED, for example), the application should verify if the cached device type is the desired device type. This behavior is shown in the sample applications later in this book.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark7">Network Operation</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Proper operation of the network is facilitated by calling <span class="s9">emberTick() </span>regularly in your program loop. The watchdog should also be re- set:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">while(TRUE) { halResetWatchdog(); emberTick();</p><p class="s9" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">// Application-specific functions here</p><p class="s9" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-top: 4pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark8">Network Formation</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Functions for creating, joining, and leaving a network have descriptive names: <span class="s9">emberFormNetwork(), emberPermitJoining(), emberJoinNetwork(), emberFindAndRejoinNetwork(), </span>and <span class="s9">emberLeaveNetwork()</span>.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Functions for finding a network or determining background energy levels include: <span class="s9">emberStartScan(), emberStopScan(), emberScanCompleteHandler(), emberEnergyScanResultHandler(), </span>and <span class="s9">emberNetworkFoundHandler().</span></p><p class="s8" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Note: <span class="p">EmberZNet PRO does not have different stack libraries for Zigbee controller (ZC) and Zigbee Router (ZR) devices, so any device that calls emberFormNetwork() creates the network and becomes the ZC. As such, only the device starting the network should call emberFormNetwork(), and other devices should call emberJoinNetwork(), which is described below.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The ZC can then use <span class="s9">emberPermitJoining() </span>to allow joining, subject to the configured security settings:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">emberPermitJoining(60); // Permit joining for 60 seconds emberPermitJoining(0xFF); // Permit joining until turned off emberPermitJoining(0); // Do not permit joining</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">For more information on security settings and authorization, please refer to <i>UG103.05: IoT Endpoint Security Fundamentals</i>.</p></li><li><p class="s8" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark9">Joining a Network</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Joining a network is accomplished with the <span class="s9">emberJoinNetwork() </span>API:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">status = emberJoinNetwork(EMBER_ROUTER, &amp;networkParams); // To join as a ZR</p><p class="s9" style="padding-left: 51pt;text-indent: 0pt;line-height: 107%;text-align: left;">status = emberJoinNetwork(EMBER_SLEEPY_END_DEVICE, &amp;networkParams); // To join as a Sleepy ZED status = emberJoinNetwork(EMBER_MOBILE_END_DEVICE, &amp;networkParams); // To join as a Mobile ZED</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">The networkParams variable is a structure of type EmberNetworkParameters and configures the PAN-ID, extended PAN-ID (or 0 for any), channel of the network to join, and the desired TX power with which to join the network.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Silicon Labs also provides a utility function that uses <span class="s9">emberStartScan(), emberStopScan(), </span>and <span class="s9">emberScanCompleteHandler() </span>to discover networks that match the provided options and to join the first one that it finds:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 17pt;text-indent: 0pt;text-align: left;">// Use a function from app/util/common/form-and-join.c</p><p class="s9" style="padding-left: 17pt;text-indent: 0pt;text-align: left;">// that scans and selects a beacon that has:</p><p class="s9" style="padding-left: 17pt;text-indent: 0pt;text-align: left;">// 1) allow join=TRUE</p><p class="s9" style="padding-left: 17pt;text-indent: 0pt;text-align: left;">// 2) matches the stack profile that the app is using</p><p class="s9" style="padding-left: 17pt;text-indent: 0pt;text-align: left;">// 3) matches the extended PAN ID passed in unless &quot;0&quot; is passed</p><p class="s9" style="padding-left: 31pt;text-indent: -14pt;line-height: 107%;text-align: left;">// Once a beacon match is found, emberJoinNetwork is called. joinZigbeeNetwork(EMBER_ROUTER, EMBER_ALL_802_15_4_CHANNELS_MASK,</p><p class="s9" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">-1, (int8u*) extendedPanId);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The utility <span class="s9">emberFindandRejoinNetwork() </span>is used on devices that have lost contact with their network and need to scan and rejoin.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s8" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark10">Packet Buffers</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The EmberZNet PRO stack provides a full set of functions for managing memory. This memory is statically allocated at link time, but dynamically used during run time. This is a valuable mechanism because it allows you to use statically linked, buffers for variable-length messages. This also gives you a better idea of how much RAM your software will require during run time. Procedures differ depending on the SDK version.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l7"><li><p class="s8" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark11">SDK version 6.7.x and earlier</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Common functions include allocating buffers with predefined content, copying to/from existing buffers, and freeing allocated buffers. A typical procedure to complete buffer usage is:</p><ol id="l8"><li><p style="padding-top: 2pt;padding-left: 42pt;text-indent: -8pt;text-align: left;">Allocate a new buffer large enough for length bytes, copy length bytes from dataArray, and check to see that the allocation succee- ded:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">buffer = emberFillLinkedBuffers(dataArray, length); if (buffer == EMBER_NULL_MESSAGE_BUFFER) {</p><p class="s9" style="padding-left: 22pt;text-indent: 0pt;text-align: left;">// the allocation failed! Do not proceed!</p><p class="s9" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 39pt;text-indent: 0pt;text-align: left;"/></li><li><p style="padding-top: 6pt;padding-left: 34pt;text-indent: -10pt;text-align: left;">Copy length bytes from buffer into dataArray, starting at index 0:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">emberCopyFromLinkedBuffers(buffer, 0, dataArray, length);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/></li><li><p style="padding-top: 6pt;padding-left: 34pt;text-indent: -10pt;text-align: left;">Return all memory used by buffer so it can be re-used:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">emberReleaseMessageBuffer(buffer);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Many functions are available for copying or appending data between packet buffers and arrays. Stack buffers, linked buffers, and mes- sage buffers all refer to the same type of data structure. The naming varies depending on the expected usage of the individual func- tions. See the packet buffer API documentation at stack/include/packet-buffer.h for a full listing as well as details about each function.</p></li></ol></li><li><p class="s8" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark12">SDK version 6.8.0 and later</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The system used to manage EmberZNet PRO buffer memory was changed in SDK version 6.8.0. In the new system, a &quot;Buffer&quot; allo- cates variable sized contiguous blocks which are managed by a mark/sweep garbage collector. Any consumer holding a reference to a Buffer must provide a marking function which will call the <span class="s9">emMarkBuffer() </span>callback on each buffer reference. Any buffers not marked by any marker function will be released. Note that the buffers are compacted during garbage collection so the consumer must not ac- cess the buffer by any pointer outside of the same scope in which <span class="s9">emGetBufferPointer() </span>is called. Also note that extending any buffer other than the most recently allocated can also cause the buffer to move. Buffers must be passed by reference to any function which may call <span class="s9">emberAppendToLinkedBuffers()</span>.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Typical EmberZNet PRO applications do not use the buffer system directly so no changes should be needed. For applications that do use buffers directly, the only required porting should be to add the necessary marking function. All of the EmberMessageBuffer APIs are supported through the legacy-packet-buffer.h header file. For detailed information on the new functions, refer to util/silicon_labs/ silabs_core/buffer_manager/buffer-management.h.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s8" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark13">Address Table or Binding Table Management</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The address table is maintained by the network stack and contains IEEE addresses and network short addresses of other devices in the network. Messages can be sent using the address table by specifying the type as EMBER_OUTGOING_VIA_ADDRESS_TABLE in commands such as <span class="s9">emberSendUnicast()</span>. More details on the address table are in message.h.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The binding table can also be used for sending messages. The binding code is within a library, so flash space is not used if the applica- tion does not use binding. Refer to binding-table.h for more details.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark14">Sending and Receiving Messages</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Refer to message.h for more details on sending or receiving messages.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l9"><li><p class="s8" style="padding-top: 5pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark15">Sending Messages</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Sending messages is simple:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">// To send to a device previously entered in the address table: status = emberSendUnicast(EMBER_OUTGOING_VIA_ADDRESS_TABLE,</p><p class="s9" style="padding-left: 129pt;text-indent: 0pt;line-height: 107%;text-align: left;">destinationAddressTableIndex, &amp;apsFrame,</p><p class="s9" style="padding-left: 129pt;text-indent: 0pt;text-align: left;">buffer, &amp;sequenceNum);</p><p class="s9" style="padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">// To send to a device via its 16-bit address (if known): status = emberSendUnicast(EMBER_OUTGOING_DIRECT,</p><p class="s9" style="padding-left: 129pt;text-indent: 0pt;line-height: 107%;text-align: left;">destinationId, &amp;apsFrame,</p><p class="s9" style="padding-left: 129pt;text-indent: 0pt;text-align: left;">buffer, &amp;sequenceNum);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In both cases the apsFrame contains the unicast message options, such as retry or enable route discovery, the buffer contains the message, and the sequence number argument provides a pointer to the APS sequence number returned by the stack when the mes- sage is queued. In the case of EMBER_OUTGOING_VIA_ADDRESS_TABLE, the destinationAddressTableIndex should contain the index of the previously stored address table entry.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Broadcast messages are sent in a similar way:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">// To send a broadcast message:</p><p class="s9" style="padding-left: 85pt;text-indent: -82pt;line-height: 107%;text-align: left;">status = emberSendBroadcast(DESTINATION //one of 3 ZigBee broadcast addresses &amp;apsFrame,</p><p class="s9" style="padding-left: 85pt;text-indent: 0pt;text-align: left;">radius, // 0 for EMBER_MAX_HOPS</p><p class="s9" style="padding-left: 138pt;text-indent: 0pt;text-align: left;">buffer, &amp;sequenceNum);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The return code should always be checked to see if the stack will attempt delivery.</p><p class="s8" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Note: <span class="p">An EMBER_SUCCESS return code does NOT mean that the message was successfully delivered; it only means that the Em- berZNet PRO stack has accepted the message for delivery. If RETRY is specified on a unicast message, emberMessageSentHandler() will be called to inform the application about the delivery results.</span></p></li><li><p class="s8" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark16">Receiving Messages</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Incoming messages are received through the <span class="s9">emberIncomingMessageHandler(), </span>a handler function that is called by the EmberZNet PRO stack and implemented by the application. The parameters passed to the function are:</p><ul id="l10"><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Message Type: for example, UNICAST, BROADCAST</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">APS Frame</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Message buffer containing the data contents of the message</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Several functions are only available within the context of the <span class="s9">emberIncomingMessageHandler() </span>function:</p></li><li><p class="s9" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">emberGetLastHopLqi(): <span class="p">returns the incoming LQI of the last hop transmission of this message</span></p></li><li><p class="s9" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">emberGetLastHopRssi(): <span class="p">returns the incoming RSSI of the last hop transmission of this message</span></p></li><li><p class="s9" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">emberGetSender(): <span class="p">gets the sender’s 16-bit network address</span></p></li><li><p class="s9" style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">emberGetSenderEui64(): <span class="p">gets the sender’s 64-bit IEEE address</span></p><p class="s8" style="padding-top: 5pt;padding-left: 36pt;text-indent: 0pt;text-align: left;">Note: <span class="p">This is available only if the sender included the 64-bit address—see the API reference for more information.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">emberSendReply(): <span class="p">allows a message to be sent in reply to an incoming unicast message.</span></p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark17">Source Routes and Large Networks</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">Aggregation routes (also called “many-to-one routes”) are used to efficiently create network-wide routes to the gateway device(s). Source routes are then used from these gateway devices to send messages back to devices in the network. The source route is speci- fied in the message network header, reducing the route-related memory requirements on intermediate devices. The functions <span class="s9">emberSendManyToOneRouteRequest(), emberAppendSourceRouteHandler(), emberIncomingRouteRecordHandler(), emberIncomingManyToOneRouteRequestHandler(), emberIncomingRouteErrorHandler() </span>are all used during source routing.</p></li><li><p class="s8" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark18">Key Aggregation-Related APIs</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The application of the concentrator uses the following new API call to establish the inbound routes, typically on a periodic basis:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: center;">EmberStatus emberSendManyToOneRouteRequest(int16u concentratorType,</p><p class="s9" style="padding-left: 23pt;text-indent: 0pt;text-align: center;">int8u radius);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The <span class="s9">concentratorType </span>is <span class="s9">EMBER_HIGH_RAM_CONCENTRATO</span>R or <span class="s9">EMBER_LOW_RAM_CONCENTRATOR</span>.</p><ul id="l11"><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">For a High Ram Concentrator, nodes send in route records only until they hear a source routed message from the concentrator, or until a new many-to-one discovery happens.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">For a Low Ram Concentrator, route records are sent before every APS message.</p></li></ul><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Devices wishing to communicate with the concentrator should create an address table entry including the short address of the concen- trator. The application should avoid initiating address discovery or other kinds of broadcasts to the concentrator for scalability. Instead, the necessary information should be obtained through broadcasts or multicasts from the concentrator. Also, when sending APS uni- casts to the concentrator, the discover route option should be off. If using the binding table rather than the address table, the binding should be of type <span class="s9">EMBER_AGGREGATION_BINDING</span>, which tells the stack not to initiate route or address discovery for that binding.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">From the application&#39;s point of view, one of the key aspects of the API is the need to manage the source route information on the con- centrator. By defining <span class="s9">EMBER_APPLICATION_USES_SOURCE_ROUTING </span>in the configuration header, the following two callbacks (normally stubbed out when this define is absent) are exposed to the application:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 22pt;text-indent: 0pt;text-align: left;">/** @description Reports the arrival of a route record command frame</p><ul id="l12"><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">to the application. The application must</p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">define EMBER_APPLICATION_USES_SOURCE_ROUTING in its</p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">configuration header to use this.</p><p class="s9" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">*/</p><p class="s9" style="padding-left: 22pt;text-indent: 0pt;text-align: left;">void emberIncomingRouteRecordHandler(EmberNodeId source,</p><p class="s9" style="padding-left: 202pt;text-indent: 0pt;line-height: 107%;text-align: left;">int8u relayCount, EmberMessageBuffer header int8u relayListIndex);</p><p class="s9" style="padding-left: 22pt;text-indent: 0pt;text-align: left;">/** @description The application can implement this callback to</p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">supply source routes to outgoing messages. The application</p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">must define EMBER_APPLICATION_USES_SOURCE_ROUTING in its</p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">configuration header to use this. It uses the supplied</p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">destination to look up a source route. If available, it</p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">appends the source route to the supplied header using the</p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">proper frame format, as described in section 3.4.1.9</p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">&quot;Source Route Subframe Field&quot; of the ZigBee specification.</p><p class="s9" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">*</p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">@param destination: The network destination of the message.</p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">@param header: The message buffer containing the partially</p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">complete packet header. The application appends the source</p></li><li><p class="s9" style="padding-left: 36pt;text-indent: -9pt;text-align: left;">route frame to this header.</p></li></ul><p class="s9" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">*/</p><p class="s9" style="padding-left: 22pt;text-indent: 0pt;text-align: left;">void emberAppendSourceRouteHandler(EmberNodeId destination,</p><p class="s9" style="padding-left: 158pt;text-indent: 0pt;text-align: left;">EmberMessageBuffer header);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The first callback supplies the recorded routes, which can be stored in a table. The second callback is invoked by the network layer for every outgoing unicast (including APS acknowledgements), and it is up to the application to supply a source route or not. The source route adds (#relays + 1) * 2 bytes to the network header frame, which therefore reduces the maximum application payload available for that packet.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The files app/util/source-route.c and app/util/source-route.h implements these callbacks and can be used as-is by node applications wishing to be a concentrator.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">For EZSP host applications, EZSP library calls pass incoming route records to the host through the incomingRouteRecordHandler frame. Supplying a source route for outgoing messages works a little bit differently. The host needs to call the setSourceRoute com- mand immediately prior to sending the unicast.</p></li></ol></li><li><p class="s8" style="padding-top: 8pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark19">End Devices</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">EmberZNet PRO provides two types of end devices, Sleepy End Devices (Sleepy ZED) and Mobile End Devices (Mobile ZED). Mobile ZEDs are expected to move, so information on these devices is not saved in parent devices. Sleepy ZEDs are expected to maintain the same parent device except in cases where the parent is lost.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For ZEDs, the APIs provide sleep and wake, parent polling, and parent status functions. For parent routers (including the coordinator), the APIs provide child polling event notification and child management functionality.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Refer to child.h for more details on these functions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-top: 5pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark20">Security and Trust Center</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Security policies for the network are established by the trust center when the network is formed. Devices joining a network must use the existing security policies or they will not be allowed to join. See <i>UG103.2: Zigbee Fundamentals </i>and <i>UG103.5: Security Fundamentals </i>for detailed discussions of Zigbee and EmberZNet PRO security settings, respectively. Details are also included in /stack/include/secur- ity.h.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-left: 46pt;text-indent: -22pt;text-align: left;"><a name="bookmark21">Event Scheduling</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The Event Scheduling macros implement an event abstraction that allows the application to schedule code to run after some specified time interval. Events are also useful for when an ISR needs to initiate an action that should run outside of the ISR context.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">While custom event-handling code can be written by the application, Silicon Labs recommends that developers consider using this sys- tem first before consuming additional flash and RAM, which duplicates its functionality. Refer to event.h for more details.</p></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><a name="bookmark22">Application Design</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">This chapter discusses several advanced design issues that affect the use of EmberZNet PRO when developing an application without using Simplicity Studio AppBuilder and the application framework. After a review of the basics of application design and application design requirements, this chapter discusses the basic application tasks requirements, and goes into detail on Zigbee network rejoin strategies, and how to implement Zigbee messaging.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l13"><li><p class="s8" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark23">The ABCs of Application Design</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Before you begin to code your application you must complete some vital preliminary tasks. These include network design and system design. However, you cannot design your system or network until you understand the scope of requirements and capabilities in a basic node application. This section describes the task-based features that your application must include.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Design is an iterative process. Each iteration has a ripple effect throughout the system and network designs. In this iterative process, the network design is the first step. Different network topologies have their own strengths and weaknesses. Some topologies may be totally unsuitable for your product, while some may be marginally acceptable for one reason or another. Only by understanding the best network topology for your product can you proceed to the next step: system design.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Your system design must include all the functional requirements needed by your final product. These must include hardware-based requirements, network functionality, security, and other issues. The question of whether or not you will seek Zigbee Certification for your product is another important factor in your system design because it will impose specific functional and design requirements on your application code. Only once you have a fully defined set of requirements and a system design that implements these requirements can you proceed to the next step in the process: application coding.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Golden Rules</p><ul id="l14"><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Your network will probably be either a sensor-type or a control-type network, or maybe have elements of both.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">The potential network bandwidth and latency are topology-dependent.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">The best solutions to certain challenges encountered by everyone are likely to be application-specific.</p></li></ul><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Your application software implements your system design. It will also use the EmberZNet PRO stack software to provide the basic func- tionality needed to create your Zigbee Wireless Personal Area Network (WPAN) product. Testing follows completion of your application software to confirm that it functions as intended. And, as in most design environments, you will repeat the design/test cycle many times before completing your product design.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark24">Basic Application Design Requirements</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The typical EmberZNet PRO embedded networking application must accomplish certain generic tasks. The following figure summarizes these tasks in relation to other responsibilities managed by the stack itself.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 157pt;text-indent: 0pt;text-align: left;"><span><img width="363" height="246" alt="image" src="ug105-adv-app-programming/Image_004.jpg"/></span></p><p class="s8" style="padding-top: 8pt;padding-left: 141pt;text-indent: 0pt;text-align: center;">Figure 3.1.  Generic Application Tasks</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Note: <span class="p">While the EmberZNet PRO stack fulfills the duties noted in the “EmberZNet/Zigbee” layer above, your application may still need to provide configuration or other guidance about how some of those tasks should be handled.</span></p></li><li><p class="s8" style="padding-top: 8pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark25">Basic Application Task Requirements (Scratch-Built)</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">If you choose to develop your own application from scratch, the following sections provide general design guidelines for you to follow. The figure above describes five major tasks that the generic networking application must perform in a Zigbee environment. In this sec- tion we examine each of these tasks in more detail.</p><ol id="l15"><li><p class="s8" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark26">Define Endpoints, Callbacks, and Global Variables</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The main source file for your application must begin with defining some important parameters. These parameters involve endpoints, callbacks, and some specific global variables.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Endpoints are required to send and receive messages, so any device (except a basic network relay device) will need at least one of these. How many and what kind is up to you. The following table lists endpoint-related global variables that must be defined in your application. <i>UG103.2: Zigbee Fundamentals </i>contains information on endpoints, endpoint descriptors, cluster IDs, profiles, and related concepts.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 141pt;text-indent: 0pt;text-align: center;">Table 3.1.  Required Endpoint Stack Globals</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:215pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Endpoint</p></td><td style="width:333pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:19pt"><td style="width:215pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">int8u emberEndpointCount</p></td><td style="width:333pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Variable that defines how many user endpoints we have on this node.</p></td></tr><tr style="height:40pt"><td style="width:215pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 10pt;text-indent: 0pt;text-align: left;">EmberEndpointDescription PGM endpointDescrip- tion</p></td><td style="width:333pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 6pt;text-indent: 0pt;text-align: left;">Typical endpoint descriptor; can be named anything. Note that the PGM keyword is just used to inform the compiler that these descriptions live in flash because they don’t change over the life of the device and aren’t accessed much.</p></td></tr><tr style="height:40pt"><td style="width:215pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">EmberEndpoint emberEndpoints[ ]</p></td><td style="width:333pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 14pt;text-indent: 0pt;text-align: left;">A global array accessed by the EmberZNet PRO stack that defines how these endpoints are enumerated; each entry in the array is made up of the “identifier” field of each EmberEndpoint struct.</p></td></tr></table><p class="s8" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Note: <span class="p">The above global variables do not apply in EZSP-based host architectures. Instead the endpoint configuration should be set up by the host during the Configuration phase of the network coprocessor (NCP) using the “AddEndpoint” EZSP command (ezspAddEnd- point() in the provided EZSP driver code).</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;"><a href="https://www.silabs.com/" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;" target="_blank">Required callback handlers are listed in the following table. Full descriptions of each function can be found in the API documentation for your Silicon Labs product at </a>silabs.com<span style=" color: #000;">.</span></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In this table and throughout this document any stack symbols or API with “X/Y” notation refer to the SoC and NCP variants, respective- ly, where variants exist.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 141pt;text-indent: 0pt;text-align: center;">Table 3.2.  Required Callback Handlers</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:30pt"><td style="width:216pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;padding-right: 24pt;text-indent: 0pt;text-align: left;">Callback Handler (SoC function / EZSP host function if different)</p></td><td style="width:332pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:40pt"><td style="width:216pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 8pt;text-indent: 0pt;text-align: left;">emberMessageSentHandler( ) / ezspMessageSen- tHandler()</p></td><td style="width:332pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;text-align: left;">Called when a message has completed transmission. A status argument indicates whether the transmission was successful (acknowledged within the expected timeout) or not.</p></td></tr><tr style="height:40pt"><td style="width:216pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 6pt;text-indent: 0pt;text-align: left;">emberIncomingMessageHandler( ) / ezspIncoming- MessageHandler()</p></td><td style="width:332pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 12pt;text-indent: 0pt;text-align: left;">Called whenever an incoming Zigbee message arrives for the application. (Not called for incoming Ember Standalone Bootloader frames or Zigbee frames that are dropped or relayed.)</p></td></tr><tr style="height:51pt"><td style="width:216pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 3pt;text-indent: 0pt;text-align: left;">emberStackStatusHandler( ) / ezspStackStatusHan- dler()</p></td><td style="width:332pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 3pt;text-indent: 0pt;text-align: left;">Called whenever the stack status changes. A switch structure is usually used to initiate the appropriate response to the new stack status. The application can also utilize the emberStackIsUp() and emberNetworkState() functions to inquire about the current stack state at will.</p></td></tr><tr style="height:40pt"><td style="width:216pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 5pt;text-indent: 0pt;text-align: left;">emberScanCompleteHandler( ) / ezspScanComple- teHandler()</p></td><td style="width:332pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 3pt;text-indent: 0pt;text-align: left;">Not required if linking in the Form &amp; Join utilities library (from app/util/common/ form-and-join.c) for use in network search and setup. Called when a network scan has been completed.</p></td></tr><tr style="height:51pt"><td style="width:216pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 24pt;text-indent: 0pt;text-align: left;">emberNetworkFoundHandler( ) / ezspNetwork- FoundHandler()</p></td><td style="width:332pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 15pt;text-indent: 0pt;text-align: justify;">Not required if linking in the Form &amp; Join utilities library (from app/util/common/ form-and-join.c) for use in network search and setup. Called when a network is found during an active networks scan (initiated by emberStartScan() with scan- Type of EMBER_ACTIVE_SCAN / EZSP_ACTIVE_SCAN).</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Optional but recommended callback handlers are listed in the following table.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 4pt;padding-left: 141pt;text-indent: 0pt;text-align: center;">Table 3.3.  Recommended Optional Callback Handlers</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:254pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Callback Handler</p></td><td style="width:301pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:51pt"><td style="width:254pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">emberUnusedPanIdFoundHandler( )</p></td><td style="width:301pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 4pt;text-indent: 0pt;text-align: left;">Only required if linking in the Form &amp; Join utilities library (from app/util/ common/form-and-join.c) for use in network search and setup. Use with emberScanForUnusedPanId( ). Notifies the application of the PAN ID and channel returned from the scan.</p></td></tr><tr style="height:51pt"><td style="width:254pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">emberJoinableNetworkFoundHandler( )</p></td><td style="width:301pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 4pt;text-indent: 0pt;text-align: left;">Only required if linking in the Form &amp; Join utilities library (from app/util/ common/form-and-join.c) for use in network search and setup. Used with emberScanForJoinableNetwork. Once a network matching the arguments is found, this function notifies the application about the network identified.</p></td></tr><tr style="height:30pt"><td style="width:254pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">emberScanErrorHandler( )</p></td><td style="width:301pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 14pt;text-indent: 0pt;text-align: left;">Used with emberScanXXX functions. If an error occurs while scanning, the function returns information about the error in a status parameter.</p></td></tr><tr style="height:62pt"><td style="width:254pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 5pt;text-indent: 0pt;text-align: left;">emberFragmentMessageSentHandler( ) / ezspFragmentMes- sageSentHandler()</p></td><td style="width:301pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;text-align: left;">Only required if linking in the Fragmentation utilities library (from app/util/ zigbee-framework/fragment.c or fragment-host.c) for use in network search and setup. Used when sending a long message that must be bro- ken up in fragments. A status parameter indicates either that the message has been sent, or that a network problem has been detected.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark27">Set Up Main Program Loop</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The main program loop is central to the execution of your application. The following figure describes a typical EmberZNet PRO applica- tion main loop.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 146pt;text-indent: 0pt;text-align: left;"><span><img width="398" height="341" alt="image" src="ug105-adv-app-programming/Image_005.jpg"/></span></p><p class="s8" style="padding-top: 8pt;padding-left: 141pt;text-indent: 0pt;text-align: center;"><a name="bookmark38">Figure 3.2.  Main Loop State Machine</a></p><p class="s8" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Initialization</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Among the initialization tasks, any serial ports (SPI, UART, debug or virtual) must be initialized. It is also important to call <span class="s9">emberInit()/ezspInit() </span>before any other stack functions (except initializing the serial port so that any errors have a way to be repor- ted). Additional tasks include the following.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Prior to calling <span class="s9">emberInit()/ezspInit()</span>:</p><ul id="l16"><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Initialize the HAL.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Turn on interrupts.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">After calling <span class="s9">emberInit()/ezspInit()</span>:</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Initialize serial ports as needed to print diagnostic information about reset info and <span class="s9">emberInit()/ezspInit() </span>results.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Initialize state machines pertaining to any utility libraries, such as <span class="s9">securityAddressCacheInit() </span>and <span class="s9">emberCommandReaderInit</span>.</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Try to re-associate to a network if previously connected.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Initialize the application state (in this case a sensor interface).</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Set any status or state indicators to initial state.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Event Loop</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark38" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;">The example in </a><span style=" color: #049;">Figure 3.2 Main Loop State Machine on page 13 </span>is based on the sensor.c sample application. In that application, join- ing the network requires a button press to initiate the process; your application may use a scheduled event instead. The network state is checked once during each circuit of the event loop. If the state indicates &quot;joined,&quot; then the <span class="s9">applicationTick() </span>function is executed. Otherwise, the execution flow skips over to checking for control events.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">This application uses buttons for data input that are handled as a control event. State indicators are simply LEDs in this application, but could be an alphanumeric display or some other state indicator.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">The <span class="s9">applicationTick() </span>function provides services in this application to check for timeouts, check for control inputs, and change any indicators (like a heartbeat LED). Note that <span class="s9">applicationTick() </span>is only executed here if the network is joined.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The function <span class="s9">emberTick()/ezspTick() </span>is a part of EmberZNet PRO. It is a periodic tick routine that should be called:</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">In the application&#39;s main event loop</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">After <span class="s9">emberInit()/ezspInit()</span></p></li></ul><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Single chip (SoC) platforms have a watchdog timer that should be reset once during each circuit through the event loop. If it times out, a reset will be triggered. By default, the watchdog timer is set for 2 seconds.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark28">Manage Network Associations</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The application is responsible for managing network associations. The tasks involved include:</p><ul id="l17"><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Detecting a network</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Joining a network</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Forming a new network</p></li></ul><p class="s8" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Extended PAN IDs</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">EmberNetworkParameters struct contains an 8 byte extended PAN ID in addition to the 2-byte PAN ID.</p><p class="s8" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">CAUTION: <span class="p">Your application must set this value, if only to zero it out. Otherwise, it is likely to be initialized with random garbage, which will lead to unexpected behavior.</span></p><p class="s9" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">emberFormNetwork() <span class="p">stores the extended PAN ID to the node data token. If a value of all zeroes is passed, a random value is used. In production applications Silicon Labs recommends that the random extended PAN ID is used. Using a fixed value (such as the EUI64 of the coordinator) can easily lead to extended PAN ID conflicts if another network running the same application is nearby or if the coordi- nator is used to commission two different neighboring networks.</span></p><p class="s9" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">emberJoinNetwork() <span class="p">joins to a network based on the supplied Extended PAN ID.. if an Extended PAN ID of all zeroes is supplied it joins based on the short PAN ID, and the Extended PAN ID of the network is retrieved from the beacon and stored to the node data token.</span></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The API call for <span class="s9">emberJoinNetwork() </span>is as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 21pt;text-indent: 0pt;text-align: left;"><span class="s10" style=" background-color: #D8D8D8;"> EmberStatus emberJoinNetwork(EmberNodeType nodeType, EmberNetworkParameters *parameters)                        </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">The new API function to retrieve the Extended PAN ID is:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 21pt;text-indent: 0pt;text-align: justify;"><span class="s10" style=" background-color: #D8D8D8;"> void emberGetExtendedPanId(int8u *resultLocation);                                                              </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Detecting a Network</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Detecting a network is handled by the stack software using a process called Active Scan, but only if requested by the application. To do so, the application must use the function <span class="s9">emberStartScan() </span>with a scantype parameter of EMBER_ACTIVE_SCAN. This function starts a scan and returns EMBER_SUCCESS to signal that the scan has successfully started. It may return one of several error values that are listed in the online API documentation.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Active Scanning walks through the available channels and detects the presence of any networks. The function <span class="s9">emberScanCompleteHandler()/ ezspScanCompleteHandler() </span>is called to indicate success or failure of the scan results. Successful results are accessed through the <span class="s9">emberNetworkFoundHandler() / ezspNetworkFoundHandler() </span>function that reports the information shown in the following table.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 141pt;text-indent: 0pt;text-align: center;">Table 3.4.  emberNetworkFoundHandler() Parameters</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Function Parameter</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">channel</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">The 802.15.4 channel on which the network was found.</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">panId</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">The PAN ID of the network.</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">extendedPanId</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">The Extended PAN ID of the network.</p></td></tr><tr style="height:30pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">expectingJoin</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 4pt;text-indent: 0pt;text-align: left;">Whether the node that generated this beacon is allowing addition- al children to join to its network.</p></td></tr><tr style="height:30pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">stackProfile</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 4pt;text-indent: 0pt;text-align: left;">The Zigbee stack profile number of the network. 0=private. 1=Zig- bee. 2=ZigbeePro.</p></td></tr></table><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">To obtain a subset of these results filtered down to just the networks that allow for joining, the application can use the <span class="s9">emberScanForJoinableNetwork() </span>function provided in app/util/common/form-and-join.h. This triggers callbacks to the <span class="s9">emberJoinableNetworkFoundHandler() / ezspJoinableNetworkFoundHandler() </span>as each joinable network result is found.</p><p class="s8" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Joining a Network</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">To join a network, a node must generally follow a process like the one illustrated in the following figure.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 196pt;text-indent: 0pt;text-align: left;"><span><img width="254" height="345" alt="image" src="ug105-adv-app-programming/Image_006.jpg"/></span></p><p class="s8" style="padding-top: 5pt;padding-left: 141pt;text-indent: 0pt;text-align: center;">Figure 3.3.  Joining a Network</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l18"><li><p style="padding-left: 41pt;text-indent: -8pt;text-align: left;">New ZR or ZED scans channels to discover all local (1-hop) ZR or ZC nodes that are join candidates.</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -8pt;text-align: left;">Scanning device chooses a responding device and submits a join request.</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -8pt;text-align: left;">If accepted, the new device receives a confirmation that includes the network address.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -8pt;text-align: left;">Once joined, the node must be authenticated by the network’s trust center and must await delivery of the network key from the trust center before the stack is considered “up”.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Joining a network involves calling the <span class="s9">emberJoinNetwork() </span>function. It causes the stack to associate with the network using the speci- fied network parameters. It can take ~200 ms for the stack to associate with the local network, although security authentication can extend this.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">CAUTION: Do not send messages until a call to the <span class="s9">emberStackStatusHandler() </span>/ <span class="s9">ezspStackStatusHandler </span>callback informs you that the stack is up.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Rejoining a network is done using a different function: <span class="s9">emberFindAndRejoinNetwork()</span>. The application may call this function when contact with the network has been lost (due to a weak/missing connection between parent and child, changed PAN ID, changed net- work key, or changed channel). The most common usage case is when an end device can no longer communicate with its parent and wishes to find a new one.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The stack calls <span class="s9">emberStackStatusHandler() / ezspStackStatusHandler() </span>to indicate that the network is down, then try to re-es- tablish contact with the network by performing an active scan, choosing a parent, and sending a Zigbee network rejoin request. A sec- ond call to the <span class="s9">emberStackStatusHandler() / ezspStackStatusHandler </span>callback indicates either the success or the failure of the attempt. The process takes approximately 150 ms to complete.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">This function is also useful if the device may have missed a network key update and thus no longer has the current network key.</p><p class="s8" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Creating a Network</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">To create a network, a node must act as a coordinator (ZC) while gathering other devices into the network. The process generally fol- lows a pattern shown in the following figure.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 206pt;text-indent: 0pt;text-align: left;"><span><img width="253" height="355" alt="image" src="ug105-adv-app-programming/Image_007.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 141pt;text-indent: 0pt;text-align: center;">Figure 3.4.  Creating a Network</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l19"><li><p style="padding-left: 41pt;text-indent: -8pt;text-align: justify;">ZC starts the network by choosing a channel and unique two-byte PAN-ID and extended PAN-ID (see the above figure, step 1). This is done by first scanning for a quiet channel by calling <span class="s9">emberStartScan() </span>with an argument of <span class="s9">EMBER_ENERGY_SCAN</span>. This identifies which channels are noisiest so that ZC can avoid them. Then <span class="s9">emberStartScan() </span>is called again with an argument of <span class="s9">EMBER_ACTIVE_SCAN</span>. This provides information about PAN IDs already in use and any other coordinators running a conflicting net- work. (If another coordinator is found, the application could have the two coordinators negotiate the conflict, usually by allowing the second coordinator to join the network as a router.) The ZC application should do whatever it can to avoid PAN ID conflicts. So, the ZC selects a quiet channel and an unused PAN ID and starts the network by calling <span class="s9">emberFormNetwork()</span>. The argument for this function is the parameters that define the network. (Refer to the online API documentation for additional information.) The applica- tion’s selection of an unused PAN ID on a given channel can be simplified by using the <span class="s9">emberScanForUnusedPanId() </span>call from the Form &amp; Join utilities API from app/util/common/form-and-join.h.</p><p class="s8" style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">Note: <span class="p">The ZC’s application software must, at compile time, specify the required stack profile and application profile for the end- points implemented. The stack is selected through the EMBER_STACK_PROFILE global definition. This may have an impact on interoperability. The EmberZNet PRO libraries support stack profiles 2 (Zigbee PRO feature set) and 0 (proprietary, non-standard stack variant).</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-left: 41pt;text-indent: -8pt;text-align: justify;">ZR or ZED joins the ZC (see the above figure, step 2).</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -8pt;text-align: justify;">ZR or ZED joins the ZR (see the above figure, step 3).</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -8pt;text-align: justify;">This results in a network with established parent/child relationships between end device nodes and the router/coordinator devices through which they joined. (Note that routers don’t establish any parent/child relationship with other routers or the coordinator, though neighboring routers may be placed in the local device’s neighbor table for use in future route creations.)</p></li></ol><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Once the new network has been formed, it is necessary to direct the stack to allow others to join the network. This is defined by the function <span class="s9">emberPermitJoining()</span>. The same function can be used to close the network to joining.</p></li></ol></li><li><p class="s8" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark29">Message Handling</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Many details and decisions are involved in message handling, but they all resolve into two major tasks:</p><ul id="l20"><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Create a message</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Process incoming messages</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The EmberZNet PRO stack software takes care of most of the low level work required in message handling. The following figure illus- trates where the application interacts with the system in message handling. However, while the APS Layer handles the APS frame structure, it is still the responsibility of the application to set up the APS Header on outbound messages, and to parse the APS header on inbound messages.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 142pt;text-indent: 0pt;text-align: left;"><span><img width="400" height="283" alt="image" src="ug105-adv-app-programming/Image_008.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 141pt;text-indent: 0pt;text-align: center;">Figure 3.5.  Application/System Relationship During Message Handling</p><p class="s8" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Sending a Message</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Three basic types of messages can be sent:</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Unicast — sent to a specific node ID based on an address table entry (the node ID can also be supplied manually by the application if necessary).</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Broadcast — sent to all devices, all non-sleepy devices or all non-ZEDs.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Multicast — sent to all devices sharing the same Group ID.</p></li></ul><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Before sending a message you must construct a message. The message frame varies according to message type and security levels. Since much of the message frame is generated outside of the application, the key factor that must be considered is the maximum size of the message payload originating in your application.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Take a few moments and study the structure of the API functions shown in the following table.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 141pt;text-indent: 0pt;text-align: center;">Table 3.5.  API Messaging Functions</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Function</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:78pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 124pt;text-indent: 0pt;text-align: left;">emberSendUnicast ( EmberOutgoingMessageType <i>type</i>, int16u <i>indexOrDestination</i>, EmberApsFrame * <i>apsFrame</i>, EmberMessageBuffer <i>message</i></p><p class="s12" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">)</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 35pt;text-indent: 0pt;line-height: 182%;text-align: left;">Sends a unicast message as per the Zigbee specification. Parameters:</p><p class="s12" style="padding-left: 2pt;padding-right: 15pt;text-indent: 0pt;text-align: left;">type Specifies the outgoing message type. Must be one of EM- BER_OUTGOING_DIRECT, EMBER_OUTGOING_VIA_AD- DRESS_TABLE, or EMBER_OUTGOING_VIA_BINDING.</p></td></tr><tr style="height:41pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;text-align: left;">indexOrDestination Depending on the type of addressing used, this is either the EmberNodeId of the destination, an index into the address table, or an index into the binding table.</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">apsFrame The APS frame which is to be added to the message.</p></td></tr><tr style="height:20pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">message Contents of the message.</p></td></tr><tr style="height:118pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 124pt;text-indent: 0pt;text-align: left;">ezspSendUnicast ( EmberOutgoingMessageType <i>type</i>, int16u <i>indexOrDestination</i>, EmberApsFrame *<i>apsFrame</i>,</p><p class="s12" style="padding-left: 2pt;padding-right: 177pt;text-indent: 0pt;text-align: left;">int8u messageTag, int8u messageLength,</p><p class="s12" style="padding-left: 2pt;padding-right: 165pt;text-indent: 0pt;text-align: left;">int8u *messageContents, int8u *sequence</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">)</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 35pt;text-indent: 0pt;line-height: 182%;text-align: left;">Sends a unicast message as per the Zigbee specification. Parameters:</p><p class="s12" style="padding-left: 2pt;padding-right: 15pt;text-indent: 0pt;text-align: left;">type Specifies the outgoing message type. Must be one of EM- BER_OUTGOING_DIRECT, EMBER_OUTGOING_VIA_AD- DRESS_TABLE, or EMBER_OUTGOING_VIA_BINDING.</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;text-align: left;">indexOrDestination Depending on the type of addressing used, this is either the EmberNodeId of the destination, an index into the address table, or an index into the binding table.</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">messageTag A host-specified value used to refer to the message.</p></td></tr><tr style="height:30pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 3pt;text-indent: 0pt;text-align: left;">messageLength The length of the messageContents parameter in bytes.</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">*messageContents Content of the message.</p></td></tr><tr style="height:30pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 15pt;text-indent: 0pt;text-align: left;">*sequence Sequence number to be used when the message is transmitted.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Function</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:88pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 139pt;text-indent: 0pt;text-align: left;">emberSendBroadcast ( EmberNodeId <i>destination</i>, EmberApsFrame * <i>apsFrame</i>, int8u <i>radius</i>, EmberMessageBuffer <i>message</i></p><p class="s12" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">)</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 6pt;text-indent: 0pt;text-align: left;">Sends a broadcast message as per the Zigbee specification. The message will be delivered to all nodes within radius hops of the sender. A radius of zero is converted to EMBER_MAX_HOPS.</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Parameters:</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;padding-right: 11pt;text-indent: 0pt;text-align: left;">destination The destination to which to send the broadcast. This must be one of three Zigbee broadcast addresses.</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">apsFrame The APS frame data to be included in the message.</p></td></tr><tr style="height:30pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 21pt;text-indent: 0pt;text-align: left;">radius The maximum number of hops the message will be re- layed.</p></td></tr><tr style="height:20pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">message The actual message to be sent.</p></td></tr><tr style="height:107pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 146pt;text-indent: 0pt;text-align: left;">ezspSendBroadcast ( EmberNodeId <i>destination</i>, EmberApsFrame * <i>apsFrame</i>, int8u <i>radius</i>,</p><p class="s12" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">int8u <i>messageTag,</i></p><p class="s12" style="padding-left: 2pt;padding-right: 165pt;text-indent: 0pt;text-align: left;">int8u messageLength, int8u *messageContents, in8u *sequence</p><p class="s12" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">)</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 6pt;text-indent: 0pt;text-align: left;">Sends a broadcast message as per the Zigbee specification. The message will be delivered to all nodes within radius hops of the sender. A radius of zero is converted to EMBER_MAX_HOPS.</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Parameters:</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;padding-right: 11pt;text-indent: 0pt;text-align: left;">destination The destination to which to send the broadcast. This must be one of three Zigbee broadcast addresses.</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">apsFrame The APS frame data to be included in the message.</p></td></tr><tr style="height:30pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 21pt;text-indent: 0pt;text-align: left;">radius The maximum number of hops the message will be re- layed.</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">messageTag A host-specified value used to refer to the message.</p></td></tr><tr style="height:30pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 3pt;text-indent: 0pt;text-align: left;">messageLength The length of the messageContents parameter in bytes.</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">messageContents The message to be sent.</p></td></tr><tr style="height:30pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 15pt;text-indent: 0pt;text-align: left;">*sequence Sequence number to be used when the message is transmitted.</p></td></tr><tr style="height:88pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 146pt;text-indent: 0pt;text-align: left;">emberSendMulticast ( EmberApsFrame * <i>apsFrame</i>, int8u <i>radius</i>,</p><p class="s12" style="padding-left: 2pt;padding-right: 139pt;text-indent: 0pt;text-align: left;">int8u <i>nonmemberRadius</i>, EmberMessageBuffer <i>message</i></p><p class="s12" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">)</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 10pt;text-indent: 0pt;text-align: left;">Sends a multicast message to all endpoints that share a specific multicast ID and are within a specified number of hops of the sender.</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Parameters:</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;padding-right: 8pt;text-indent: 0pt;text-align: left;">apsFrame The APS frame for the message. The multicast will be sent to the groupId in this frame.</p></td></tr><tr style="height:41pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 4pt;text-indent: 0pt;text-align: left;">radius The message will be delivered to all nodes within this num- ber of hops of the sender. A value of zero is converted to EM- BER_MAX_HOPS.</p></td></tr><tr style="height:41pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 8pt;text-indent: 0pt;text-align: justify;">nonmemberRadius The number of hops that the message will be forwarded by devices that are not members of the group. A value of 7 or greater is treated as infinite.</p></td></tr><tr style="height:20pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">message A message.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Function</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:91pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 146pt;text-indent: 0pt;text-align: left;">ezspSendMulticast ( EmberApsFrame * <i>apsFrame</i>, int8u <i>hops</i>,</p><p class="s12" style="padding-left: 2pt;padding-right: 165pt;text-indent: 0pt;text-align: left;">int8u <i>nonmemberRadius</i>, int8u <i>messageTag,</i></p><p class="s12" style="padding-left: 2pt;padding-right: 165pt;text-indent: 0pt;text-align: left;">int8u messageLength, int8u *messageContents, in8u *sequence )</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 10pt;text-indent: 0pt;text-align: left;">Sends a multicast message to all endpoints that share a specific multicast ID and are within a specified number of hops of the sender.</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Parameters:</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;padding-right: 8pt;text-indent: 0pt;text-align: left;">apsFrame The APS frame for the message. The multicast will be sent to the groupId in this frame.</p></td></tr><tr style="height:38pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 1pt;padding-left: 2pt;padding-right: 4pt;text-indent: 0pt;text-align: left;">radius The message will be delivered to all nodes within this num- ber of hops of the sender. A value of zero is converted to EM- BER_MAX_HOPS.</p></td></tr><tr style="height:41pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 8pt;text-indent: 0pt;text-align: justify;">nonmemberRadius The number of hops that the message will be forwarded by devices that are not members of the group. A value of 7 or greater is treated as infinite.</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">messageTag A host-specified value used to refer to the message.</p></td></tr><tr style="height:30pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 3pt;text-indent: 0pt;text-align: left;">messageLength The length of the messageContents parameter in bytes.</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">messageContents The message to be sent.</p></td></tr><tr style="height:30pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 15pt;text-indent: 0pt;text-align: left;">*sequence Sequence number to be used when the message is transmitted.</p></td></tr></table><p class="s8" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Note: <span class="p">Please keep in mind that the online API documentation is more extensive than that shown here. Always refer to the online API documentation for definitive information.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In every case illustrated above, message buffer contains the message. Normally, the application allocates memory for this buffer (as some multiple of 32 bytes). But how big can this buffer be? Or: How big a message can be sent? The answer is: you don’t necessarily know, but you can find out dynamically. The function emberMaximumApsPayloadLength(void) returns the maximum size of the payload that the Application Support sub-layer will accept, depending on the security level in use. This means that:</p><ol id="l21"><li><p style="padding-top: 2pt;padding-left: 41pt;text-indent: -8pt;text-align: left;">Constructing your message involves supplying the arguments for the appropriate message type’s emberSend/ezspSend... function.</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -8pt;text-align: left;">You can use emberMaximumApsPayloadLength(void)to determine how big your message can be.</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -8pt;text-align: left;">Executing the emberSend/ezspSend... function causes your message to be sent.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Normally, the emberSend/ezspSend... function returns a value. Check the online API documentation for further information.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">It should become clear that the task of sending a message is a bit complex, but it is also very consistent. The challenge in designing your application is keeping track of the argument values and the messages to be sent. Some messages may have to be sent in partial segments and some may have to be resent if an error occurs. Your application must deal with the consequences of these possibilities.</p><p class="s8" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Receiving Messages</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Unlike sending messages, receiving messages is a more open-ended process. The application is notified when a message has been received, but the application must decide what to do with it and how to respond to it.</p><p class="s8" style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Note: <span class="p">The stack doesn’t detect or filter duplicate packets in the APS layer. Nor does it guarantee in-order message delivery. These mechanisms need to be implemented by the application.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In the case of the SoC platform, the stack deals with the mechanics of receiving and storing a message. But in the case of the EZSP host platform, the message is passed directly to the host. The host must deal with receiving and storing the message in addition to reacting to the message contents.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In all cases, the application must parse the message into its constituent parts and decide what to do with the information. Because this varies based on the system design, we can only discuss it in general terms.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Messages generally can be divided into two broad categories: command or data messages. Command messages involve the operation of the target as a functional member of the network (including housekeeping commands). Data messages are informational to the appli- cation, although they may deal with the functionality of a device with which the node is interfaced, such as a temperature sensor.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">When a message is received, the function <span class="s9">emberIncomingMessageHandler()/ezspIncomingMessageHandler() </span>is a callback invoked by the EmberZNet PRO stack. This function contains the following arguments:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Function</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:102pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 124pt;text-indent: 0pt;text-align: left;">emberIncomingMessageHandler ( EmberIncomingMessageType type, EmberApsFrame * apsFrame, EmberMessageBuffer message</p><p class="s12" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">)</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">type The type of the incoming message. One of the following:</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;padding-right: 24pt;text-indent: 0pt;text-align: left;">EMBER_INCOMING_UNICAST EMBER_INCOMING_UNICAST_REPLY EMBER_INCOMING_MULTICAST EMBER_INCOMING_MULTICAST_LOOPBACK EMBER_INCOMING_BROADCAST EMBER_INCOMING_BROADCAST_LOOPBACK EMBER_INCOMING_MANY_TO_ONE_ROUTE_REQUEST</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">apsFrame The APS frame from the incoming message.</p></td></tr><tr style="height:20pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">message The message that was sent.</p></td></tr><tr style="height:124pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 124pt;text-indent: 0pt;text-align: left;">ezspIncomingMessageHandler( EmberIncomingMessageType type, EmberApsFrame *apsFrame,</p><p class="s12" style="padding-left: 2pt;padding-right: 178pt;text-indent: 0pt;text-align: left;">int8u lastHopLqi, int8s lastHopRssi, EmberNodeId sender, int8u bindingIndex, int8u addressIndex,</p><p class="s12" style="padding-left: 2pt;padding-right: 167pt;text-indent: 0pt;text-align: left;">int8u messageLength, int8u *messageContents</p><p class="s12" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">)</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 67pt;text-indent: 0pt;text-align: left;">Type EMBER_INCOMING_UNICAST EMBER_INCOMING_UNICAST_REPLY EMBER_INCOMING_MULTICAST EMBER_INCOMING_MULTICAST_LOOPBACK, EMBER_INCOMING_BROADCAST EMBER_INCOMING_BROADCAST_LOOPBACK</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">apsFrame The APS frame from the incoming message.</p><p class="s12" style="padding-top: 8pt;padding-left: 2pt;padding-right: 21pt;text-indent: 0pt;text-align: left;">lastHopLqi The link quality from the node that last relayed the message.</p></td></tr><tr style="height:27pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 1pt;padding-left: 2pt;padding-right: 13pt;text-indent: 0pt;text-align: left;">lastHopRssi The energy level (in units of dBm) observed during the reception.</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">sender The sender of the message</p></td></tr><tr style="height:30pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 5pt;text-indent: 0pt;text-align: left;">bindingIndex The index of a binding that matches the message or 0xFF if there is no matching binding.</p></td></tr><tr style="height:41pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 7pt;text-indent: 0pt;text-align: left;">addressIndex The index of the entry in the address table that matches the sender of the message or 0xFF if there is no match- ing entry.</p></td></tr><tr style="height:30pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;padding-right: 3pt;text-indent: 0pt;text-align: left;">messageLength The length of the messageContents parameter in bytes.</p></td></tr><tr style="height:20pt"><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:270pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">messageContents The incoming message.</p></td></tr></table><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">While more than the three message types previously discussed may be returned, the others are simply specialized variations of the three basic types.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The application message handling code must deal with all three arguments of <span class="s9">emberIncomingMessageHandler()/ ezspIncomingMessageHandler()</span>. Certain message types may have special handling options. The message itself must be parsed into its constituent parts and each part reacted to accordingly. This usually involves a switch statement and varies in detail with every appli- cation. The sample applications (in &lt;install-dir&gt;/app) are a good place to look for detailed examples of incoming message handlers.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">For incoming broadcasts, the destination broadcast ID will be in the groupId field of the APS struct.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">One additional function can only be called from within <span class="s9">emberIncomingMessageHandler()</span>. This extracts the source EUI64 from the net- work frame of the message, but only if EMBER_APS_OPTION_SOURCE_EUI64 is set.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;line-height: 107%;text-align: left;">EmberStatus emberGetSenderEui64(EmberEUI64 senderEui64 ); ezspIncomingSenderEui64Handler()</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p class="s8" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Note: <span class="p">For EZSP host applications, all relevant information about the incoming message is passed to the host by the NCP at the time that the ezspIncomingMessageHandler() callback is triggered. In cases where the incoming message provides source EUI64 data, and additional callback of ezspIncomingSenderEui64Handler(senderEui64) is provided just prior to ezspIncomingMessageHandler().</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">Message Acknowledgement</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">When a message is received, it is good network protocol to acknowledge receipt of the message. This is done automatically in the stack software at the MAC layer with a Link ACK, requiring no action by the application. This is illustrated in the following figure (1) where node A sends a message to node D. However, if the sender requests an end-to-end acknowledgement, the application may want to add something as payload to the end-to-end ACK message (see the following figure (2)). While adding a payload is possible, it is not compliant with the Zigbee specification. If this is of interest, please contact Silicon Labs support. support for further information.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 168pt;text-indent: 0pt;text-align: left;"><span><img width="340" height="248" alt="image" src="ug105-adv-app-programming/Image_009.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 141pt;text-indent: 0pt;text-align: center;">Figure 3.6.  Link ACK and End-to-End ACK</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">Note: <a href="#bookmark39" style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;">Additional information on message handling can be found in section </a><span class="s7">3.5 Zigbee Messaging</span><span class="p">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s8" style="padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark30">Housekeeping Tasks</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">A variety of housekeeping tasks must be included in the application. Some of these tasks are application-dependent, but some are re- quired by every application. These universally required tasks are the subject of this section.</p><p class="s8" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Processor Maintenance</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In the case of the SoC platform, one unique task is required of all applications running on that platform. You must call <span class="s9">emberTick() </span>on a regular basis. <span class="s9">emberTick() </span>acts as a link between the stack state machine and the application state machine. When executed, <span class="s9">emberTick() </span>allows the stack to deal with several tasks that have collected since the last time <span class="s9">emberTick() </span>was called. A variety of callbacks can result from each call to <span class="s9">emberTick()</span>, generally to get input from the application for resolving a stack task. As mentioned in Section A.3.2, Set Up Main Program Loop, <span class="s9">emberTick() </span>is called in the application&#39;s main event loop and after calling <span class="s9">emberInit()</span>.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The application’s main loop must perform the following tasks:</p><ul id="l22"><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Manage I/O functions.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Reset the watchdog timer.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Maintain buffer and memory (including calling emberSerialBufferTick() if using buffered serial mode).</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Process errors.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Include debugging features/strategies.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 5pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Host I/O Maintenance</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">In the case of EZSP network coprocessor [NCP] designs, the host must perform the following additional tasks:</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Check for callbacks regularly in the main event loop.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Process errors.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Perform bootloading (if implemented).</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Include debugging features/strategies.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 5pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Network Maintenance</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">A key group of housekeeping tasks involve network maintenance. All applications must generally deal with the following tasks (based on the complexity of the system/application design):</p></li><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Joining a network.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Rejoining a network.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Dealing with interference (that is, being able to adapt to degrading network conditions) (optional).</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Tasks for an End Device (ZED) include:</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Dealing with loss of connectivity (that is, polling for a lost parent).</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Checking in with parent after emerging from a sleep or hibernation state.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">For Mobile ZEDs, keeping their connection to their parent alive by regularly polling that link. Otherwise they need to call emberRe- joinNetwork() whenever they wish to communicate with the network.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Tasks for a Coordinator (ZC) or Router (ZR) include:</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Forming a network.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Commissioning a network or accepting a new device on the network.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Dealing with new or replaced nodes.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">And, if sleepy ZEDs are included in the network, tasks include:</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">ZED power consumption (managing sleeping or waiting end devices).</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">Acting as a parent, dealing with ZED alarms, and reacting to child join/leaves.</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s8" style="padding-top: 5pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark31">Zigbee Network Rejoin Strategies</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">End devices (ZED) that have lost contact with their parent or any node that does not have the current network key should call the API function shown below.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 21pt;text-indent: 0pt;text-align: justify;"><span class="s10" style=" background-color: #D8D8D8;"> EmberStatus emberFindAndRejoinNetwork(boolean haveCurrentNetworkKey,int32u channelMask);                        </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">The haveCurrentNetworkKey variable determines if the stack performs a secure network rejoin (haveCurrentNetworkKey = TRUE) or an insecure network rejoin (haveCurrentNetworkKey = FALSE). The insecure network rejoin only works if using the Commercial Securi- ty Library. In that case the current network key is sent to the rejoining node encrypted at the APS Layer with that device&#39;s link key.</p></li><li><p class="s8" style="padding-top: 8pt;padding-left: 41pt;text-indent: -17pt;text-align: left;"><a name="bookmark32">Zigbee Messaging</a><a name="bookmark39">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l23"><li><p class="s8" style="padding-top: 5pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark33">Address Table</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">EUI64 values to network ID mappings are kept in an address table. The stack updates the node IDs as new information arrives. It will not change the EUI64s.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 12pt;text-indent: 0pt;line-height: 107%;text-align: left;">EmberStatus emberSetAddressTableRemoteEui64(int8u addressTableIndex, EmberEui64 eui64); void emberSetAddressTableRemoteNodeId(int8u addressTableIndex, EmberNodeId id);</p><p class="s9" style="padding-left: 12pt;text-indent: 0pt;line-height: 107%;text-align: left;">void emberGetAddressTableRemoteEui64(int8u addressTableIndex, EmberEui64 eui64); EmberNodeId emberGetAddressTableRemoteNodeId(int8u addressTableIndex);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The size of the table can be set by defining EMBER_ADDRESS_TABLE_SIZE before including ember-configuration.c.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The binding table has its own remote ID table. Four reserved node ID values are used with the address and binding tables, described in the following table.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 141pt;text-indent: 0pt;text-align: center;">Table 3.6.  Bindings Remote ID Table Functions</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Function</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:40pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">EMBER_TABLE_ENTRY_UNUSED_NODE_ID (0xFFFF)</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 8pt;text-indent: 0pt;text-align: left;">Used when setting or getting the remote node ID in the address table or getting the remote node ID from the binding table. It indi- cates that address or binding table entry is not in use.</p></td></tr><tr style="height:40pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">EMBER_MULTICAST_NODE_ID (0xFFFE)</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 7pt;text-indent: 0pt;text-align: justify;">Returned when getting the remote node ID from the binding table and the given binding table index refers to a multicast binding en- try.</p></td></tr><tr style="height:51pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">EMBER_UNKNOWN_NODE_ID (0xFFFD)</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 4pt;text-indent: 0pt;text-align: left;">Used when getting the remote node ID from the address or bind- ing tables. It indicates that the address or binding table entry is currently in use but the node ID corresponding to the EUI64 in the table is currently unknown.</p></td></tr><tr style="height:40pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">EMBER_DISCOVERY_ACTIVE_NODE_ID (0xFFFC)</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 8pt;text-indent: 0pt;text-align: left;">Used when getting the remote node ID from the address or bind- ing tables. It indicates that the address or binding table entry is currently in use and network address discovery is underway.</p></td></tr></table><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The following function function validates that a given node ID is valid and not one of the reserved values.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 21pt;text-indent: 0pt;text-align: left;"><span class="s10" style=" background-color: #D8D8D8;"> boolean emberIsNodeIdValid(EmberNodeId id);                                                                      </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Two additional functions can be used to search through all the relevant stack tables (address, binding, neighbor, child) to map a long address to a short address, or vice versa.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">EmberNodeId emberLookupNodeIdByEui64(EmberEUI64 eui64);</p><p class="s9" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">EmberStatus emberLookupEui64ByNodeId(EmberNodeId nodeId, EmberEUI64 eui64Return);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Since end device children cannot be identified by their short ID, two functions allow the application to set and read the flag that increa- ses the interval between APS retry attempts.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">boolean emberGetExtendedTimeout(EmberEUI64 remoteEui64);</p><p class="s9" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">void emberSetExtendedTimeout(EmberEUI64 remoteEui64, boolean extendedTimeout);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/></li><li><p class="s8" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark34">Sending Messages</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The destination address for a unicast can be obtained from the address or binding tables, or passed as an argument. An enumeration is used to indicate which is to be used for a particular message. The same enumeration is used with <span class="s9">emberMessageSent() / ezspMessageSentHandler()</span>; EMBER_OUTGOING_BROADCAST and EMBER_OUTGOING_MULTICAST cannot be passed to <span class="s9">emberSendUnicast()/ezspSendUnicast()</span>.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Use of the address or binding table allows the stack to perform address discovery by setting the EMBER_APS_OPTION_ENABLE_AD- DRESS_DISCOVERY option.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 12pt;text-indent: 0pt;text-align: left;">enum {</p><p class="s9" style="padding-left: 22pt;text-indent: 0pt;line-height: 107%;text-align: left;">EMBER_OUTGOING_DIRECT, EMBER_OUTGOING_VIA_ADDRESS_TABLE, EMBER_OUTGOING_VIA_BINDING,</p><p class="s9" style="padding-left: 22pt;text-indent: 0pt;line-height: 107%;text-align: left;">EMBER_OUTGOING_BROADCAST, // only for emberMessageSent() EMBER_OUTGOING_MULTICAST // only for emberMessageSent()</p><p class="s9" style="padding-left: 12pt;text-indent: 0pt;text-align: left;">};</p><p class="s9" style="padding-left: 12pt;text-indent: 0pt;text-align: left;">typedef int8u EmberOutgoingMessageType;</p><p class="s9" style="padding-left: 12pt;text-indent: 0pt;text-align: left;">EmberStatus emberSendUnicast(EmberOutgoingMessageType type,</p><p class="s9" style="padding-left: 153pt;text-indent: 0pt;line-height: 107%;text-align: left;">int16u indexOrDestination, EmberApsFrame *apsFrame, EmberMessageBuffer message);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">EMBER_OUTGOING_VIA_BINDING uses only the binding&#39;s address information. The rest of the binding&#39;s information (cluster ID, end- points, profile ID) can be retrieved using <span class="s9">emberGetBinding() </span>and <span class="s9">emberGetEndpointDescription()</span>. This allows the application to re- use an existing binding for additional clusters or endpoints besides the one provided during the binding’s creation.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The next snippet of example code shows how a message might be sent using a binding. The options in the example are the ones Sili- con Labs recommends using for unicast transmissions to a non-many-to-one binding, where the destination is not a concentrator. When sending to a network concentrator, route and address discovery should not be enabled as the concentrator will handle this itself by Many-to-one Route Requests. For more information about concentrators see document <i>UG103.3: Software Design Fundamentals</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 22pt;text-indent: -9pt;line-height: 107%;text-align: left;">EmberApsFrame apsFrame = { profileId,</p><p class="s9" style="padding-left: 22pt;text-indent: 0pt;line-height: 107%;text-align: left;">clusterId, sourceEndpoint, destinationEndpoint, EMBER_APS_OPTION_RETRY</p><p class="s9" style="padding-left: 31pt;text-indent: 0pt;text-align: left;">| EMBER_APS_OPTION_ENABLE_ROUTE_DISCOVERY</p><p class="s9" style="padding-left: 31pt;text-indent: 0pt;text-align: left;">| EMBER_APS_OPTION_ENABLE_ADDRESS_DISCOVERY</p><p class="s9" style="padding-left: 31pt;text-indent: 0pt;text-align: left;">| EMBER_APS_OPTION_DESTINATION_EUI64</p><p class="s9" style="padding-left: 12pt;text-indent: 0pt;text-align: left;">};</p><p class="s9" style="padding-left: 12pt;text-indent: 0pt;text-align: left;">emberSendUnicast(EMBER_OUTGOING_VIA_BINDING,</p><p class="s9" style="padding-left: 95pt;text-indent: 0pt;line-height: 107%;text-align: left;">bindingIndex, &amp;apsFrame, message);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p class="s9" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">emberSendReply()/ezspSendReply() <span class="p">can be used to send a reply (as payload accompanying the APS ACK) to any retried APS mes- sages. Replies are a nonstandard extension to Zigbee and may not be accepted by non-Silicon Labs devices. Note that the use of </span>ezspSendReply() <span class="p">by EZSP host applications is only permissible when the EZSP_UNICAST_REPLIES_POLICY has been configured as EZSP_HOST_WILL_SUPPLY_REPLY; otherwise, the NCP will generate the APS ACK (without any accompanying payload) auto- matically upon receiving the retried APS unicast.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 21pt;text-indent: 0pt;text-align: left;"><span class="s10" style=" background-color: #D8D8D8;">   EmberStatus emberSendReply(int16u clusterId, EmberMessageBuffer reply);                                       </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Multicasts get an APS frame plus radii. The groupId is specified in the APS frame. The nonMemberRadius specifies how many hops the message should be forwarded by devices that are not members of the group. A value of 7 or greater is treated as infinite.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 12pt;text-indent: 0pt;text-align: left;">EmberStatus emberSendMulticast(EmberApsFrame *apsFrame,</p><p class="s9" style="padding-left: 163pt;text-indent: 0pt;text-align: left;">int8u radius,</p><p class="s9" style="padding-left: 163pt;text-indent: 0pt;line-height: 107%;text-align: left;">int8u nonMemberRadius, EmberMessageBuffer message);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">A multicast table is provided to track group multicast membership for the local device. The size is EMBER_MULTICAST_TABLE_SIZE and defaults to 8. Multicast table entries should be created and modified manually by the application; just index into the array.</p><p class="s8" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Note: <span class="p">The multicast table entries are stored in RAM on the device and are therefore not preserved across resets of the processor. For non-volatile storage of multicast group membership data, use binding table entries with “type” set to EMBER_MULTICAST_BINDING.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 12pt;text-indent: 0pt;text-align: left;">EmberMulticastTableEntry *emberMulticastTable;</p><p class="s9" style="padding-left: 12pt;text-indent: 0pt;text-align: left;">/** @brief Defines an entry in the multicast table.</p><ul id="l24"><li><p class="s9" style="padding-left: 27pt;text-indent: -9pt;text-align: left;">@description A multicast table entry indicates that a particular</p></li><li><p class="s9" style="padding-left: 27pt;text-indent: -9pt;text-align: left;">endpoint is a member of a particular multicast group. Only devices</p></li><li><p class="s9" style="padding-left: 27pt;text-indent: -9pt;text-align: left;">with an endpoint in a multicast group will receive messages sent to</p></li><li><p class="s9" style="padding-left: 27pt;text-indent: -9pt;text-align: left;">that multicast group.</p></li></ul><p class="s9" style="padding-left: 17pt;text-indent: 0pt;text-align: left;">*/</p><p class="s9" style="padding-left: 12pt;text-indent: 0pt;text-align: left;">typedef struct {</p><p class="s9" style="padding-left: 22pt;text-indent: 0pt;line-height: 107%;text-align: left;">/** The multicast group ID. */ EmberMulticastId multicastId;</p><p class="s9" style="padding-left: 22pt;text-indent: 0pt;text-align: left;">/** The endpoint that is a member, or 0 if this entry is not in use</p><p class="s9" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">* (the ZDO is not a member of any multicast groups).</p><p class="s9" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">*/</p><p class="s9" style="padding-left: 22pt;text-indent: 0pt;text-align: left;">int8u endpoint;</p><p class="s9" style="padding-left: 12pt;text-indent: 0pt;text-align: left;">} EmberMulticastTableEntry;</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;">Since Zigbee has three different broadcast addresses (everyone, rx-on-when-idle only, routers only), broadcasting requires specifying a destination address. On the receiver, this can be read out of the groupId field in the apsFrame.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 12pt;text-indent: 0pt;text-align: left;">#define EMBER_BROADCAST_ADDRESS 0xFFFC</p><p class="s9" style="padding-left: 12pt;text-indent: 0pt;line-height: 107%;text-align: left;">#define EMBER_RX_ON_WHEN_IDLE_BROADCAST_ADDRESS 0xFFFD #define EMBER_SLEEPY_BROADCAST_ADDRESS 0xFFFF</p><p class="s9" style="padding-left: 12pt;text-indent: 0pt;text-align: left;">EmberStatus emberSendBroadcast(EmberNodeId destination,</p><p class="s9" style="padding-left: 163pt;text-indent: 0pt;line-height: 107%;text-align: left;">EmberApsFrame *apsFrame, int8u radius, EmberMessageBuffer message);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-top: 4pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark35">Message Status</a></p><p class="s9" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">emberMessageSent() /ezspMessageSent() <span class="p">should be called for all outgoing messages. The type of message is given by the enumer- ation of outgoing message types. Call </span>emberMessageSent()/ezspMessageSent()<span class="p">:</span></p><ul id="l25"><li><p style="padding-top: 2pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">For retried unicasts, when an ACK arrives or the message times out.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">For non-retried unicasts, when the MAC receives an ACK from the next hop or the MAC retries are exhausted.</p></li><li><p style="padding-top: 3pt;padding-left: 36pt;text-indent: -9pt;text-align: left;">For broadcasts and multicasts, when the message is removed from the retry queue (not the broadcast table).</p></li></ul><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The indexOrAddress argument is the destination address for direct unicasts, broadcasts, and multicasts. For unicasts sent through the address or binding tables, it is the index into the relevant table. The following table summarizes the status arguments for broadcasts and multicasts.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 141pt;text-indent: 0pt;text-align: center;">Table 3.7.  Status Argument for Broadcasts and Multicasts</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24pt" cellspacing="0"><tr style="height:19pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Status Argument</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#797777"><p class="s11" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">EMBER_DELIVERY_FAILED</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">if the message was never transmitted.</p></td></tr><tr style="height:30pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">EMBER_DELIVERY_FAILED</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;padding-right: 6pt;text-indent: 0pt;text-align: left;">if radius is greater than 1 and we don&#39;t hear at least one neighbor relay the message.</p></td></tr><tr style="height:19pt"><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">EMBER_SUCCESS</p></td><td style="width:270pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s12" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">otherwise.</p></td></tr></table><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Example code:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 12pt;text-indent: 0pt;text-align: left;">void emberMessageSent(EmberOutgoingMessageType type,</p><p class="s9" style="padding-left: 119pt;text-indent: 0pt;line-height: 107%;text-align: left;">int16u indexOrDestination, EmberApsFrame *apsFrame, EmberMessageBuffer message, EmberStatus status);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s8" style="padding-top: 4pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark36">Disable Relay</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">If EMBER_DISABLE_RELAY is defined in the app configuration header (or if EZSP_CONFIG_DISABLE_RELAY is set to 0x01 in EZSP), the node will not relay unicasts, route requests, or route replies. It can still generate route requests and replies, so that it can be the source or destination of network messages. This is intended for use in a gateway.</p></li><li><p class="s8" style="padding-top: 8pt;padding-left: 49pt;text-indent: -25pt;text-align: left;"><a name="bookmark37">Binding</a></p></li></ol></li></ol></li></ol><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The binding table is now used only in support of provisioning. The idea is that a provisioning tool will use the ZDO to discover the serv- ices available on a device and to add entries to the device&#39;s binding table. Other than the ZDO, no use is made of the binding table within Zigbee. It is up to the application to make use of the information in the table how it sees fit.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Messages use an address table to establish the message destination (unless a binding already exists to reference the destination). Since the binding table exists as a separate library, applications can conserve flash by omitting this library in cases where only the address table is used to preserve destination information, such as when the application has its own method for non-volatile destination data storage.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 17pt;text-indent: 0pt;text-align: left;">Smart. Connected. Energy-Friendly.</h4><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="text-indent: 0pt;line-height: 9pt;text-align: center;">Products</p><p style="text-indent: 0pt;text-align: center;"><a href="http://www.silabs.com/products" class="s15">www.silabs.com/products</a></p><p class="s14" style="text-indent: 0pt;line-height: 9pt;text-align: center;">Quality</p><p style="text-indent: 0pt;text-align: center;"><a href="http://www.silabs.com/quality" class="s15">www.silabs.com/quality</a></p><p class="s14" style="text-indent: 0pt;line-height: 9pt;text-align: center;">Support and Community</p><p class="s16" style="text-indent: 0pt;text-align: center;">community.silabs.com</p><p style="padding-left: 64pt;text-indent: 0pt;text-align: left;"><span style=" color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt;">		</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="767" height="695" alt="image" src="ug105-adv-app-programming/Image_010.png"/></span></p><p class="s17" style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Disclaimer</p><p class="s18" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Silicon Labs intends to provide customers with the latest, accurate, and in-depth documentation of all peripherals and modules available for system and software implementers using or intending to use the Silicon Labs products. Characterization data, available modules and peripherals, memory sizes and memory addresses refer to each specific device, and &quot;Typical&quot; parameters provided can and do vary in different applications. Application examples described herein are for illustrative purposes only. Silicon Labs reserves the right to make changes without further notice to the product information, specifications, and descriptions herein, and does not give warranties as to the accuracy or completeness of the included information. Without prior notification, Silicon Labs may update product firmware during the manufacturing process for security or reliability reasons. Such changes will not alter the specifications or the performance of the product. Silicon Labs shall have no liability for the consequences of use of the information supplied in this document. This document does not imply or expressly grant any license to design or fabricate any integrated circuits. The products are not designed or authorized to be used within any FDA Class III devices, applications for which FDA premarket approval is required, or Life Support Systems without the specific written consent of Silicon Labs. A &quot;Life Support System&quot; is any product or system intended to support or sustain life and/or health, which, if it fails, can be reasonably expected to result in significant personal injury or death. Silicon Labs products are not designed or authorized for military applications. Silicon Labs products shall under no circumstances be used in weapons of mass destruction including (but not limited to) nuclear, biological or chemical weapons, or missiles capable of delivering such weapons. Silicon Labs disclaims all express and implied warranties and shall not be responsible or liable for any injuries or damages related to use of a Silicon Labs product in such unauthorized applications.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Trademark Information</p><p class="s18" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Silicon Laboratories Inc.®, Silicon Laboratories®, Silicon Labs®, SiLabs® and the Silicon Labs logo®, Bluegiga®, Bluegiga Logo®, ClockBuilder®, CMEMS®, DSPLL®, EFM®, EFM32®, EFR, Ember®, Energy Micro, Energy Micro logo and combinations thereof, &quot;the world’s most energy friendly microcontrollers&quot;, Ember®, EZLink®, EZRadio®, EZRadioPRO®, Gecko®, Gecko OS, Gecko OS Studio, ISOmodem®, Precision32®, ProSLIC®, Simplicity Studio®, SiPHY®, Telegesis, the Telegesis Logo®, USBXpress® , Zentri, the Zentri logo and Zentri DMS, Z- Wave®, and others are trademarks or registered trademarks of Silicon Labs. ARM, CORTEX, Cortex-M3 and THUMB are trademarks or registered trademarks of ARM Holdings. Keil is a registered trademark of ARM Limited. Wi-Fi is a registered trademark of the Wi-Fi Alliance. All other products or brand names mentioned herein are trademarks of their respective holders.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="152" height="75" alt="image" src="ug105-adv-app-programming/Image_011.png"/></span></p><p class="s17" style="padding-left: 168pt;text-indent: 0pt;text-align: left;">Silicon Laboratories Inc. 400 West Cesar Chavez Austin, TX 78701</p><p class="s17" style="padding-left: 168pt;text-indent: 0pt;text-align: left;">USA</p><p style="padding-top: 5pt;padding-left: 168pt;text-indent: 0pt;text-align: left;"><h2 href="http://www.silabs.com/">http://www.silabs.com</h2></p></body></html>
