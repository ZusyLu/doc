<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>UG391: Zigbee Application Framework Developer&#39;s Guide</title><meta name="author" content="Silicon Labs"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 h1 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 24pt; }
 .s1 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 6pt; }
 .s2 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s3 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s4 { color: #D71E2A; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 h3 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 .s5 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .p, p { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; margin:0pt; }
 .s6 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .a { color: #049; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s7 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s8 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s9 { color: #00F; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 9pt; }
 .s10 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s11 { color: black; font-family:"Cambria Math", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; }
 .s12 { color: black; font-family:"Cambria Math", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s13 { color: black; font-family:"Cambria Math", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: 5pt; }
 .s14 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s16 { color: black; font-family:"Cambria Math", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: -6pt; }
 .s17 { color: black; font-family:"Cambria Math", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s18 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s20 { color: #FFF; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s21 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 h2 { color: #FFF; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 20pt; }
 .s23 { color: #FFF; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 h4 { color: #D91E2A; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s24 { color: #4D4D4F; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s25 { color: #4D4D4F; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s26 { color: #4D4D4F; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 7pt; }
 .s27 { color: #4D4D4F; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s28 { color: #D91E2A; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 7pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 li {display: block; }
 #l2 {padding-left: 0pt;counter-reset: d1 1; }
 #l2> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 #l3 {padding-left: 0pt;counter-reset: d2 1; }
 #l3> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l3> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l4 {padding-left: 0pt;counter-reset: e1 1; }
 #l4> li>*:first-child:before {counter-increment: e1; content: counter(e1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l4> li:first-child>*:first-child:before {counter-increment: e1 0;  }
 #l5 {padding-left: 0pt;counter-reset: f1 1; }
 #l5> li>*:first-child:before {counter-increment: f1; content: counter(f1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l5> li:first-child>*:first-child:before {counter-increment: f1 0;  }
 #l6 {padding-left: 0pt; }
 #l6> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l7 {padding-left: 0pt;counter-reset: d2 1; }
 #l7> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l7> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l8 {padding-left: 0pt;counter-reset: d3 1; }
 #l8> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l8> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l9 {padding-left: 0pt;counter-reset: d2 1; }
 #l9> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l9> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l10 {padding-left: 0pt;counter-reset: d3 2; }
 #l10> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l10> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l11 {padding-left: 0pt;counter-reset: d4 1; }
 #l11> li>*:first-child:before {counter-increment: d4; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)"."counter(d4, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l11> li:first-child>*:first-child:before {counter-increment: d4 0;  }
 #l12 {padding-left: 0pt;counter-reset: d2 1; }
 #l12> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l12> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l13 {padding-left: 0pt;counter-reset: d2 1; }
 #l13> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l13> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l14 {padding-left: 0pt;counter-reset: d3 1; }
 #l14> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l14> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l15 {padding-left: 0pt;counter-reset: d2 1; }
 #l15> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l15> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l16 {padding-left: 0pt;counter-reset: d3 1; }
 #l16> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l16> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l17 {padding-left: 0pt;counter-reset: d3 1; }
 #l17> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l17> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l18 {padding-left: 0pt; }
 #l18> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l19 {padding-left: 0pt;counter-reset: d2 1; }
 #l19> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l19> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l20 {padding-left: 0pt; }
 #l20> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l21 {padding-left: 0pt;counter-reset: d3 1; }
 #l21> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l21> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l22 {padding-left: 0pt;counter-reset: d3 1; }
 #l22> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l22> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l23 {padding-left: 0pt;counter-reset: d2 1; }
 #l23> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l23> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l24 {padding-left: 0pt;counter-reset: h1 1; }
 #l24> li>*:first-child:before {counter-increment: h1; content: counter(h1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l24> li:first-child>*:first-child:before {counter-increment: h1 0;  }
 #l25 {padding-left: 0pt;counter-reset: i1 1; }
 #l25> li>*:first-child:before {counter-increment: i1; content: counter(i1, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l25> li:first-child>*:first-child:before {counter-increment: i1 0;  }
 #l26 {padding-left: 0pt;counter-reset: d3 1; }
 #l26> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l26> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l27 {padding-left: 0pt;counter-reset: d2 1; }
 #l27> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l27> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l28 {padding-left: 0pt;counter-reset: j1 1; }
 #l28> li>*:first-child:before {counter-increment: j1; content: counter(j1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l28> li:first-child>*:first-child:before {counter-increment: j1 0;  }
 #l29 {padding-left: 0pt; }
 #l29> li>*:first-child:before {content: "* "; color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l30 {padding-left: 0pt;counter-reset: d3 1; }
 #l30> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l30> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l31 {padding-left: 0pt;counter-reset: l1 1; }
 #l31> li>*:first-child:before {counter-increment: l1; content: counter(l1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l31> li:first-child>*:first-child:before {counter-increment: l1 0;  }
 #l32 {padding-left: 0pt;counter-reset: m1 1; }
 #l32> li>*:first-child:before {counter-increment: m1; content: counter(m1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l32> li:first-child>*:first-child:before {counter-increment: m1 0;  }
 #l33 {padding-left: 0pt;counter-reset: n1 1; }
 #l33> li>*:first-child:before {counter-increment: n1; content: counter(n1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l33> li:first-child>*:first-child:before {counter-increment: n1 0;  }
 #l34 {padding-left: 0pt;counter-reset: d2 1; }
 #l34> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l34> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l35 {padding-left: 0pt;counter-reset: d3 1; }
 #l35> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l35> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l36 {padding-left: 0pt; }
 #l36> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l37 {padding-left: 0pt;counter-reset: d3 1; }
 #l37> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l37> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l38 {padding-left: 0pt;counter-reset: d2 1; }
 #l38> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l38> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l39 {padding-left: 0pt;counter-reset: o1 15; }
 #l39> li>*:first-child:before {counter-increment: o1; content: counter(o1, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l39> li:first-child>*:first-child:before {counter-increment: o1 0;  }
 #l40 {padding-left: 0pt;counter-reset: o2 2; }
 #l40> li>*:first-child:before {counter-increment: o2; content: counter(o1, decimal)"."counter(o2, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l40> li:first-child>*:first-child:before {counter-increment: o2 0;  }
 #l41 {padding-left: 0pt;counter-reset: o3 1; }
 #l41> li>*:first-child:before {counter-increment: o3; content: counter(o1, decimal)"."counter(o2, decimal)"."counter(o3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l41> li:first-child>*:first-child:before {counter-increment: o3 0;  }
 #l42 {padding-left: 0pt;counter-reset: o4 1; }
 #l42> li>*:first-child:before {counter-increment: o4; content: counter(o1, decimal)"."counter(o2, decimal)"."counter(o3, decimal)"."counter(o4, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l42> li:first-child>*:first-child:before {counter-increment: o4 0;  }
 #l43 {padding-left: 0pt;counter-reset: o4 1; }
 #l43> li>*:first-child:before {counter-increment: o4; content: counter(o1, decimal)"."counter(o2, decimal)"."counter(o3, decimal)"."counter(o4, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l43> li:first-child>*:first-child:before {counter-increment: o4 0;  }
 #l44 {padding-left: 0pt;counter-reset: p1 1; }
 #l44> li>*:first-child:before {counter-increment: p1; content: counter(p1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l44> li:first-child>*:first-child:before {counter-increment: p1 0;  }
 #l45 {padding-left: 0pt;counter-reset: d3 1; }
 #l45> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l45> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l46 {padding-left: 0pt; }
 #l46> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l47 {padding-left: 0pt; }
 #l47> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l48 {padding-left: 0pt;counter-reset: d2 1; }
 #l48> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l48> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l49 {padding-left: 0pt;counter-reset: q1 1; }
 #l49> li>*:first-child:before {counter-increment: q1; content: counter(q1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l49> li:first-child>*:first-child:before {counter-increment: q1 0;  }
 #l50 {padding-left: 0pt;counter-reset: q2 1; }
 #l50> li>*:first-child:before {counter-increment: q2; content: counter(q2, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l50> li:first-child>*:first-child:before {counter-increment: q2 0;  }
 #l51 {padding-left: 0pt;counter-reset: q2 1; }
 #l51> li>*:first-child:before {counter-increment: q2; content: counter(q2, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l51> li:first-child>*:first-child:before {counter-increment: q2 0;  }
 #l52 {padding-left: 0pt;counter-reset: d3 1; }
 #l52> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l52> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l53 {padding-left: 0pt;counter-reset: r1 1; }
 #l53> li>*:first-child:before {counter-increment: r1; content: counter(r1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l53> li:first-child>*:first-child:before {counter-increment: r1 0;  }
 #l54 {padding-left: 0pt;counter-reset: r2 1; }
 #l54> li>*:first-child:before {counter-increment: r2; content: counter(r2, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l54> li:first-child>*:first-child:before {counter-increment: r2 0;  }
 #l55 {padding-left: 0pt;counter-reset: r2 1; }
 #l55> li>*:first-child:before {counter-increment: r2; content: counter(r2, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l55> li:first-child>*:first-child:before {counter-increment: r2 0;  }
 #l56 {padding-left: 0pt;counter-reset: r3 1; }
 #l56> li>*:first-child:before {counter-increment: r3; content: counter(r3, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l56> li:first-child>*:first-child:before {counter-increment: r3 0;  }
 #l57 {padding-left: 0pt;counter-reset: d4 1; }
 #l57> li>*:first-child:before {counter-increment: d4; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)"."counter(d4, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l57> li:first-child>*:first-child:before {counter-increment: d4 0;  }
 #l58 {padding-left: 0pt;counter-reset: s1 1; }
 #l58> li>*:first-child:before {counter-increment: s1; content: counter(s1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l58> li:first-child>*:first-child:before {counter-increment: s1 0;  }
 #l59 {padding-left: 0pt;counter-reset: d4 1; }
 #l59> li>*:first-child:before {counter-increment: d4; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)"."counter(d4, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l59> li:first-child>*:first-child:before {counter-increment: d4 0;  }
 #l60 {padding-left: 0pt;counter-reset: d4 1; }
 #l60> li>*:first-child:before {counter-increment: d4; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)"."counter(d4, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l60> li:first-child>*:first-child:before {counter-increment: d4 0;  }
 #l61 {padding-left: 0pt;counter-reset: d3 1; }
 #l61> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l61> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l62 {padding-left: 0pt; }
 #l62> li>*:first-child:before {content: "* "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l63 {padding-left: 0pt; }
 #l63> li>*:first-child:before {content: "* "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l64 {padding-left: 0pt; }
 #l64> li>*:first-child:before {content: "* "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l65 {padding-left: 0pt; }
 #l65> li>*:first-child:before {content: "* "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l66 {padding-left: 0pt; }
 #l66> li>*:first-child:before {content: "* "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l67 {padding-left: 0pt;counter-reset: w1 1; }
 #l67> li>*:first-child:before {counter-increment: w1; content: counter(w1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l67> li:first-child>*:first-child:before {counter-increment: w1 0;  }
 #l68 {padding-left: 0pt;counter-reset: d3 1; }
 #l68> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l68> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l69 {padding-left: 0pt;counter-reset: x1 1; }
 #l69> li>*:first-child:before {counter-increment: x1; content: counter(x1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l69> li:first-child>*:first-child:before {counter-increment: x1 0;  }
 #l70 {padding-left: 0pt; }
 #l70> li>*:first-child:before {content: "* "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l71 {padding-left: 0pt; }
 #l71> li>*:first-child:before {content: "* "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l72 {padding-left: 0pt; }
 #l72> li>*:first-child:before {content: "* "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l73 {padding-left: 0pt; }
 #l73> li>*:first-child:before {content: "* "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l74 {padding-left: 0pt; }
 #l74> li>*:first-child:before {content: "* "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l75 {padding-left: 0pt; }
 #l75> li>*:first-child:before {content: "* "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l76 {padding-left: 0pt; }
 #l76> li>*:first-child:before {content: "* "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l77 {padding-left: 0pt;counter-reset: d2 1; }
 #l77> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l77> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l78 {padding-left: 0pt;counter-reset: f1 1; }
 #l78> li>*:first-child:before {counter-increment: f1; content: counter(f1, decimal)". "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l78> li:first-child>*:first-child:before {counter-increment: f1 0;  }
 #l79 {padding-left: 0pt; }
 #l79> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l80 {padding-left: 0pt;counter-reset: d3 1; }
 #l80> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l80> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 table, tbody {vertical-align: top; overflow: visible; }
</style></head><body><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span><img width="127" height="62" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_001.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-top: 11pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">UG391: Zigbee Application Framework Developer’s Guide</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 22pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="728" height="1" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_002.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="208" height="1" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_003.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-top: 4pt;padding-bottom: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">KEY POINTS</p><p style="padding-left: 10pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="210" height="1" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_004.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l1"><li><p class="s2" style="padding-left: 20pt;text-indent: -7pt;text-align: left;">Provides a reference for all aspects of the Application Framework, including callbacks, plugins, the API, and the CLI.</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 20pt;text-indent: -7pt;text-align: left;">Discusses extending the ZCL (Zigbee Cluster Library).</p></li><li><p class="s2" style="padding-top: 3pt;padding-left: 20pt;text-indent: -7pt;text-align: left;">Offers guidelines for designing an appli- cation in AppBuilder.</p></li></ul><p style="text-indent: 0pt;text-align: left;"/><p class="s3" style="padding-top: 17pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework is a body of embedded C code that can be configured by AppBuilder to implement any Zigbee Cluster Library (ZCL) application. Beginning with version 2.6.0 of the EmberZNet SDK, the Zigbee application framework replaces Application Framework V2. This guide covers the structure and usage of the Zigbee application framework.</p><p class="s4" style="padding-bottom: 2pt;text-indent: 0pt;text-align: right;">Introduction</p><p style="padding-left: 22pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="724" height="1" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_005.png"/></span></p><ol id="l2"><li><h3 style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;"><a name="bookmark0">Introduction</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l3"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark1">Purpose</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework (also known as the ZCL application framework) is a body of embedded C code that can be configured by the AppBuilder tool to implement any Zigbee Cluster Library (ZCL) application. The application framework is located in the app/frame- work directory.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">This guide covers the structure and usage of the Zigbee application framework.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark2">Building an Application</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">An application is created in several steps using the Zigbee application framework.</p><ol id="l4"><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;">Create Zigbee application framework configuration files using Simplicity Studio’s AppBuilder. The configuration files as well as the project files for your platform of choice are generated by AppBuilder. An overview of using AppBuilder and how it relates to the Zigbee application framework is provided in <i>UG103.02: Zigbee Fundamentals</i>. More detailed information on how to use AppBuilder can be found in the AppBuilder Help (Simplicity Studio &gt; Help &gt; Help Contents &gt; Simplicity Studio AppBuilder) in Simplicity Studio 4 and in the Simplicity Studio 5 User’s Guide.</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;"><a href="#bookmark16" class="s7">Write the specifics of your application into the callback functions generated along with your configuration files. Use the Zigbee appli- cation framework API to do things like interact with attributes, and send, receive, and respond to commands on the Zigbee network. For more detailed information on the Zigbee application framework API, see section </a><a href="#bookmark16" class="a">5 The Application Framework API</a><a href="#bookmark16" class="s7">.</a></p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;">Open the generated project file into the IDE of your chosen chip, compile your application, and load it onto your development kit hardware.</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;"><a name="bookmark3">Run your application and interact with it using the Simplicity Studio console window and the application’s command line interface. More information on how to use Simplicity Studio is available in the online help in Simplicity Studio (Help &gt; Help Contents) in Simplicity Studio 4 and the Simplicity Studio 5 User’s Guide.</a></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;">Porting an Application</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For information regarding porting an application from Application Framework v2 to the current Zigbee Application Framework in Simplicity Studio, see the Knowledge Base Article <i>Migrating Projects from Application Framework V2 to the Zigbee Application Framework in Sim- plicity Studio’s AppBuilder</i>.</p><p class="s4" style="padding-bottom: 2pt;text-indent: 0pt;text-align: right;">Application Framework Architecture</p><p style="padding-left: 22pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="724" height="1" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_006.png"/></span></p></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;"><a name="bookmark4">Application Framework Architecture</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework sits on top of the Zigbee stack, consumes the stack “handler” interfaces, and exposes its own more highly abstracted and application-specific interface to the developer.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">One of the main features of the Zigbee application framework is the separation of user-created and Silicon Labs-created code. While Silicon Labs provides all of the source code for the Zigbee application framework, user-created code should live outside the framework and should interact with the framework through the Zigbee application framework API exposed by the framework utilities and callbacks. The block diagram in the following figure shows a high-level overview of the Zigbee application framework architecture and how the two code bases are separated.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 105pt;text-indent: 0pt;text-align: left;"><span><img width="503" height="329" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_007.gif"/></span></p><p class="s5" style="padding-top: 5pt;padding-left: 28pt;text-indent: 0pt;text-align: center;">Figure 2-1. Application Framework Architecture</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">The “Simple Main” Plugin included in app/framework/plugin consumes the Zigbee Stack handler interface and ties the Zigbee application framework into the EmberZNet PRO stack. In addition, two main files are located in the app/framework/util directory, one (af-main-soc.c) for a System-on-Chip (SoC) and the other (af-main-host.c) for a host micro-paired with a Network Co-Processor (NCP).</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The af-main-soc and af-main-host files implement the <span class="s8">emberIncomingMessageHandler() </span>and pass all incoming messages off to the Zigbee application framework for command processing. Once incoming messages are processed they are either passed off to the appropriate cluster for handling, or passed directly to cluster-specific callbacks generated by AppBuilder. A significant portion of the command processing code is generated directly from the ZCL XML documents included in app/zcl/.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">All of the code and header files generated from the ZCL XML documents are generated into &lt;user workspace directory&gt;/&lt;application name&gt;/ alongside the application header and callbacks file among others.</p><p class="s4" style="padding-bottom: 2pt;padding-left: 376pt;text-indent: 0pt;text-align: left;">Application Framework Directory Structure</p><p style="padding-left: 22pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="724" height="1" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_008.png"/></span></p></li><li><h3 style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;"><a name="bookmark5">Application Framework Directory Structure</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">When you generate a project, it is generated by default into your workspace directory, in a folder named with the project name. The other directories named in this section may be found in the Simplicity Studio Zigbee protocol SDK folder (\SiliconLabs\SimplicityStudio\&lt;ver- sion&gt;\developer\sdks\gecko_sdk_suite\&lt;version&gt;\protocol\zigbee).</p><p class="s5" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">tool/appbuilder: <span class="p">Configuration and template files used by AppBuilder</span></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">When you point AppBuilder at a stack installation, it looks into this directory to load XML descriptions of the most current ZCL implemen- tation as of the release of that stack.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">You may load your custom cluster .xml files into your project on the “Zigbee Stack” Tab in AppBuilder. For more information about creating custom clusters, see Simplicity Studio 4 AppBuilder Help at Help | Help Contents | Simplicity Studio AppBuilder | Creating custom clusters or the Simplicity Studio 5 User’s Guide.</p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">app/framework: <span class="p">All of the Zigbee application framework code is located in app/framework. Major portions of the code have been broken out into their own directories.</span></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">app/framework/cli: <span class="p">Code related to the application framework’s implementation of the Command Line Interface.</span></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 107%;text-align: left;">Core code for the CLI is included in app/util/serial/command-interpreter2.c. The CLI includes data type checking and command usage feedback among other things. As a result:</p><ol id="l5"><li><p style="padding-top: 2pt;padding-left: 37pt;text-indent: -13pt;text-align: left;">All commands require ALL arguments associated with that command. If an argument is missing, the CLI will provide user feedback as to the particular command’s usage.</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">Arguments passed with the CLI must be in one of the following formats:</p></li></ol><p style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">&lt;int&gt;: 123(decimal) or 0x1ABC(hex)</p><p style="padding-left: 38pt;text-indent: 0pt;text-align: left;">&lt;string&gt;: &quot;foo&quot;(string) or {0A 1B 2C}(array of bytes)</p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">app/framework/include: <span class="p">All of the external APIs for the Zigbee application framework.</span></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">This directory mirrors the use of the include directory in the stack. It is intended to be the single location for all externally facing application interfaces.</p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">app/framework/plugin: <span class="p">All Silicon Labs-created ZCL cluster code</span></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">This directory contains all of the cluster code created by the Silicon Labs team for handling cluster commands. This code optionally can be included in an application by selecting the plugin from AppBuilder’s Plugin Tab. If you choose not to include a plugin, you are respon- sible for implementing the callbacks for all of the required cluster commands.</p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">app/framework/scenarios: <span class="p">All sample application scenarios which use the application framework</span></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">These sample scenarios may be opened within AppBuilder by starting a new project, , selecting a framework, and then selecting a sample application.” AppBuilder requests a new application name for the given scenario instance and copies the sample callback code into a directory of the same name within app/builder. See <i>QSG106: </i>Zigbee EmberZNet PRO Quick-Start Guide for a detailed description on building and flashing sample applications.</p><p class="s5" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 183%;text-align: left;">app/framework/security: <span class="p">All utility code related to Zigbee Security. Code related to key establishment is located in app/framework/cluster.</span></p><p class="s5" style="padding-left: 23pt;text-indent: 0pt;line-height: 10pt;text-align: left;">app/framework/util: <span class="p">The application&#39;s mains, message processing, and any other utility code used by the Zigbee application framework.</span></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">This directory contains the guts of the Zigbee application framework. Attribute storage files that manage attributes for multiple endpoint support are included in this directory. In addition, the API used for accessing, reading, and writing attributes is included in the file attribute- table.h, and attribute-storage.h.</p></li><li><h3 style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;"><a name="bookmark6">Designing an Application with AppBuilder</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">AppBuilder is a tool for generating Zigbee-compliant applications. AppBuilder is made up of two parts: the Zigbee application framework or other application framework and a graphical tool for configuring the included source code. The AppBuilder graphical tool is both a stand-alone application and a Simplicity Studio plug-in. AppBuilder gives you an interface for turning on or off embedded clusters and features in the code compiled into a finished application.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">AppBuilder is intended to meet the following goals:</p><ul id="l6"><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Quickly create Zigbee-compliant applications for Silicon Labs wireless platforms.</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;"><a name="bookmark7">Enable rapid development and decrease customer time-to-market by providing standard example applications.</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l7"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;">ZCL Concepts</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l8"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark8">Definitions</a></p><p class="s5" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Zigbee Application Profiles</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Zigbee application profiles specify generic settings (such as security, join parameters, and poll rate) for all devices within an application group. Application profiles also specify exactly what clusters (protocols) must be supported for each device in the application group.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">AppBuilder currently supports six Zigbee application profiles:</p></li></ol></li></ol></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Zigbee 3.0</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Home Automation (HA)</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Smart Energy (SE, formerly AMI or Automated Meter-reading Infrastructure)</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Commercial Building Automation (CBA)</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Zigbee Light Link (ZLL)</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Health Care (HC)</p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Clusters</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Each Zigbee cluster defines an application-level protocol. A set of these protocols (or clusters) defines the functionality of a particular Zigbee device. Anyone with a networking background can think of a cluster as an application protocol that has been encapsulated within the Zigbee specification.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 106%;text-align: justify;">The Zigbee Cluster Library (ZCL) is a document that specifies the clusters used by Zigbee devices. The original ZCL document had 30 clusters, most of which were specified as required or optional by at least one device in the Zigbee HA application profile. The SE appli- cation profile uses some of the clusters specified in the ZCL but also specifies new clusters that are unique to SE.</p><p class="s5" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Devices</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">A Zigbee device can be thought of as a collection of clusters. For example, an on/off light switch and an on/off light are two of the 31 devices in the HA profile. All of the devices within a profile must use the same sort of security. There are recommendations on polling rates, start-up parameters, what kind of ZDO messages should be implemented, and so on, with the idea being that these devices must interoperate on the same network. If devices have different security settings, they cannot join together. If a user buys an HA device from company A and buys an HA device from company B, because they use the same application profile one of the devices should be able to join the other device.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">If two Zigbee devices are on a certified Zigbee stack, they can route for each other. In other words, they can exchange messages at the application level. Interoperability at the application level is not guaranteed until they use an application profile. These standard application profiles enable AppBuilder to generate compliant Zigbee applications.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">The HA on/off light has the following implementations:</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Identify server (required by all)</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Groups server</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Scenes server</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">On/Off server</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The HA on/off light switch has the following implementations:</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Identify client</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Groups client</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Scenes client</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">On/Off client</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The on/off light switch can send an on/off or toggle message that the on/off light is required to understand and abide.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l9"><ol id="l10"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark9">More About Clusters and Attributes</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Clusters specify two things: attributes and commands. Attributes are well-defined pieces of data that are stored on a device and can be read (and sometimes written) by external devices. Commands specify over-the-air messages that are exchanged. Each command defined by the ZCL is unidirectional in the sense that it is sent by one side (either the client or server) and received by the other. A device can implement only one side of a cluster, or it can implement both sides of a cluster.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For instance, an “HA on/off Light” implements the server side of the “on/off” cluster, while the “HA on/off Light Switch” implements the client side of the “on/off” cluster. This defines that the Light Switch sends “on”, “off”, and “toggle” commands that the Light can receive (and understand). It also defines that the Light stores a Boolean attribute called “on/off” representing the current state of the device.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 60pt;text-indent: -36pt;text-align: left;">Note: <span class="p">Zigbee often uses the terms “in-cluster-list” and “out-cluster-list” instead of server and client. An “in-cluster-list” is the list of supported server clusters, and the “out-cluster-list” is the list of supported client clusters.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 107%;text-align: justify;">In most cases, the server side of a cluster contains all the attributes, and the client side is the side that initiates an over-the-air exchange. For the most part, the client sends a message, and the server answers that message.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l11"><li><p class="s6" style="padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark10">Example: The Identify Cluster</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">The client/server interaction defined by the ZCL is illustrated in the Identify example shown in the following figure.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 154pt;text-indent: 0pt;text-align: left;"><span><img width="372" height="233" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_009.gif"/></span></p><p class="s5" style="padding-top: 6pt;padding-left: 28pt;text-indent: 0pt;text-align: center;">Figure 4-1. Cluster Example: Identify</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Like many clusters, the Identify cluster is a fairly simple cluster. The lower right corner shows the single attribute, identify time.</p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Identify cluster use case:</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">A user is provisioning a network of 12 lights in one room and must connect 6 of those lights to a single switch. The MAC address of each light is used to associate it with the switch. The MAC addresses for all 12 lights can be discovered by using a provisioning tool and a low power broadcast or by using a token (set when they were installed) on each light indicating room or location. The “Identify” functionality can be used to figure out which six MAC addresses correspond to the six physical lights that the user wants bound to a switch. Using the Identify cluster, the user can tell each light individually to “identify” itself (for example, blink so that it can be seen).</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Identify cluster defines the protocol for how devices are put into and taken out of identify mode. In the above example, the provisioning tool implements the client side of the identify cluster, and the light or the device that needs to be identified implements the server side.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">When the client wants to tell a device to “start identifying,” it sends the “Identify” command and specifies a period of time in seconds for which to continue identifying. The device stops identifying when the identify time attributes (decremented each second) reaches 0, or if the device receives an “Identify” command with identify time value of 0.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The first message in Figure A 1 turns on “identify.” When identify is turned on, a time period is also included in the message. For example, suppose identify is turned on for 30 seconds. The second message shows the client (provisioning device) querying the server (light) to find out how much time is left in the identify process.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Because a query message can be sent to a group, it is possible to put a device into a mode where it is identifying, and then use a PC or provisioning tool and figure out which device in the group is identifying. This is useful if a device supports a physical cue to start identifying. Then a device can be poked (button press, magnet wand, and so on) to start identifying, and a group message can be sent to map the MAC address to the physical device.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s6" style="padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark11">Example: The Temperature Measurement Cluster</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The following figure illustrates another example of a cluster. This example shows temperature measurement.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 164pt;text-indent: 0pt;text-align: left;"><span><img width="344" height="216" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_010.gif"/></span></p><p class="s5" style="padding-top: 7pt;padding-left: 28pt;text-indent: 0pt;text-align: center;">Figure 4-2. Cluster example: Temperature measurement</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Notice that this cluster has no commands—it only has attributes. In this case, the device implements measurements of temperature, such as a thermostat. This example includes a measured value, a minimum measured value, and a maximum measured value. With no com- mands, this cluster relies on the global commands defined in the ZCL. The global commands define messages for reading, writing, discovering, and reporting attributes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 60pt;text-indent: -36pt;text-align: justify;">Note: <span class="p">Fourteen global commands read attributes, write attributes, configure attribute reporting, discover attributes, and report attribute values. Clusters that only include attributes are simple to understand and simple to implement, because the global commands are already implemented.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 106%;text-align: justify;">In order to read the value of an attribute of this cluster, a global read attributes command is used. This message contains the attribute ID of the attribute to read. In combination, the cluster and the attribute ID provide unique identification. On the embedded side, this makes it possible to centralize all the attributes in a single table. All of the code for those attributes is generic, shared code.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">As a result, for example, when adding four of the temperature-measuring-sensing clusters, the impact on flash is minimal, because there are no additional commands. The impact on RAM depends on the number of attributes added per cluster.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The application level protocol provided by the Zigbee Cluster Library makes it possible for two companies to develop products separately and have them work together without having to test them together.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li></ol><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark12">AppBuilder and the Application Framework Architecture</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">AppBuilder is a GUI tool which is part of the Simplicity Studio desktop application and is used to configure the Zigbee application frame- work code. AppBuilder reads configuration data out of the installed stack directory. The .properties and .xml files located in tool/appbuilder tell AppBuilder everything it needs to know about the associated stack. By interpreting these configuration files within the stack, AppBuilder is able to generate the appropriate configuration data and project files necessary for a complete Zigbee application.</p></li></ol></li></ul></li><li><h3 style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;"><a name="bookmark13">Generated Application Configuration Files</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework uses the same preprocessor directives to configure the code to be included and excluded from the framework. In addition to the main app header file, AppBuilder also generates an &quot;endpoint configuration&quot; header file with the suffix endpoint_configuration.h.</p><p class="s5" style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">&lt;DeviceName&gt;_endpoint_configuration.h</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The generated file that configures the Zigbee application framework&#39;s static data structures. This allows attribute metadata to be shared across endpoints, and each endpoint to have its own space for attribute storage. The #defines in the &lt;DeviceName&gt;_endpoint_config.h file are used by the app/framework/util/attribute-storage.c file to configure all of the application’s attribute-related data.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The file must be re-generated each time you modify your application configuration in AppBuilder. Silicon Labs recommends that you do not edit the &lt;DeviceName&gt;_endpoint_config.h file by hand as each of the macro definitions in the file has a complex relationship.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;"><a href="#bookmark45" class="s7">The role of the endpoint configuration file is described in more detail in section </a><a href="#bookmark45" class="a">9.1 ZCL Attribute Configuration</a><a href="#bookmark45" class="s7">.</a></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;DeviceName&gt;.h</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">The main header file for your application. It includes all of the #defines that turn on the features you require within the framework.</p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;DeviceName&gt;_callbacks.c</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">A generated stub callback file containing default implementations of all callbacks you have selected to include in your project. This is where your code goes. You are not restricted to using this one file for your code. You can include other files provided you add them to your generated project file so that they can be found by the compiler.</p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;DeviceName&gt;.hwconf</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 107%;text-align: justify;">The generated peripheral configuration file for your part. Simplicity Studio offers a user-friendly interface for modifications to the peripheral configurations. See <i>AN1115: Configuring Peripherals for 32-Bit Devices in Simplicity Studio </i>for more information.</p><p class="s5" style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">&lt;DeviceName&gt;_tokens.h</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">If you are including any attributes in tokens (persistent memory) for a platform that supports tokens, this file is generated by AppBuilder to configure your token storage.</p><p class="s5" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">&lt;DeviceName&gt;.ewp, eww, .xip, .xiw, .mak</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Generated project files for your application. AppBuilder only generates the project files that match the platform you have chosen. These files may be loaded into your IDE and edited to build out the rest of your project.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l12"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark14">Application Framework Files</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 107%;text-align: justify;">In addition to device specific files, Application Framework files are also generated by AppBuilder into the &lt;User Workspace&gt;/&lt;Device- Name&gt; directory.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The number of files generated varies based on what plugins are supported and what is required for those plugins. The Zigbee application framework files that are generated include but are not limited to the following:</p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">af-structs.h: <span class="p">Definitions of structures used by the Zigbee application framework for the parsing of data sent over the air.</span></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">att-storage.h: <span class="p">Defines used in the attribute storage mechanism within the Zigbee application framework.</span></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 107%;text-align: justify;">attribute-id.h: <span class="p">All attribute ids defined by the Zigbee Cluster Library specifications for all profiles loaded into the Zigbee application framework.</span></p><p class="s5" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">attribute-size.h: <span class="p">Size in bytes for attribute types used in the Zigbee Cluster Library specification.</span></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">attribute-type.h: <span class="p">Defines to represent over the air values for data types used in the Zigbee Cluster Library specification.</span></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">call-command-handler.c: <span class="p">Command handling code for all non-general commands received over the air. This generated code marshals cluster commands from their over the air format off to the callback interface. It also handles the commands if no callbacks are implemented for them.</span></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">call-command-handler.h: <span class="p">Header file for the call-command-handler c code. This file provides definitions for all of the functions imple- mented in call-command-handler.c.</span></p><p class="s5" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">callback-stub.c: <span class="p">Provides stubs for custom callbacks implemented by the Zigbee application framework. The callback stubs are only compiled in if they are not separately defined by the customer’s application.</span></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">callback.h: <span class="p">Provides definitions for ALL callbacks that can possibly be implemented within the Zigbee application framework or the users application. This defines the ENTIRE callback interface which is the main interface used by the Zigbee application framework when communicating with the user application.</span></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">znet-cli.c: This file provides all the generated handlers for the Command Line Interface.</p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">znet-cli.h: <span class="p">This file is used only by the documentation engine doxygen to document general application framework cli commands; it has no other purpose.</span></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">client-command-macro.h: <span class="p">Macros that are provided as a convenience as part of the Zigbee application framework interface in the filling of packet buffers that will be sent over the air. Each command supported by the Zigbee Cluster Library as configured in the user’s Application Configuration is represented here with a macro that will make the appropriate calls into the Zigbee application framework to fill a packet buffer to send that command over the air.</span></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 182%;text-align: left;">cluster-id.h: <span class="p">Defines provided for all cluster ids loaded into the Zigbee application framework from the Zigbee Cluster Library. </span>command-id.h: <span class="p">Defines provided for all command ids loaded into the Zigbee application framework from the Zigbee Cluster Library. </span>debug-printing-test.h: <span class="p">Defines used to turn on debug printing within the Zigbee application framework.</span></p><p class="s5" style="padding-left: 23pt;text-indent: 0pt;line-height: 10pt;text-align: left;">debug-printing.h: <span class="p">Macros used for debug printing within the Zigbee application framework.</span></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">enums.h<span class="p">: Provides definitions for all Zigbee Cluster Library related enums used in the Zigbee application framework.</span></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">print-cluster.h: <span class="p">Defines used to turn on printing on a per cluster basis within the Zigbee application framework.</span></p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">stack-handler-stub.c: <span class="p">Stubs for all stack handlers which are available to be overridden within the Zigbee application framework.</span></p><p class="s4" style="padding-bottom: 2pt;text-indent: 0pt;text-align: right;">The Application Framework API</p><p style="padding-left: 22pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="724" height="1" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_011.png"/></span></p></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;"><a name="bookmark15">The Application Framework API</a><a name="bookmark16">&zwnj;</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework’s API is provided in app/framework/include/af.h. This interface file is consistent with the way the Em- berZNet PRO API is exposed by the stack. The <i>Application Framework API Reference </i><a href="https://docs.silabs.com/" class="s7" target="_blank">is provided with your installation as well as online at </a><a href="https://docs.silabs.com/" class="s9" target="_blank">https://docs.silabs.com/</a><a href="https://docs.silabs.com/" class="s7" target="_blank">.</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Many of the functions in the Zigbee application framework include a passed one-byte endpointId. This is particularly true for functions like cluster initialization, cluster ticks, and attribute management. For instance, the function zclUtilReadAttribute is located in app/frame- work/util/attribute-table.c, and the signature of the function takes the endpointId as its first argument.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Some examples of the Zigbee application framework include:</p><p class="s10" style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: justify;">boolean emberAfContainsCluster(int8u endpoint, EmberAfClusterId clusterId); boolean emberAfContainsServer(int8u endpoint, EmberAfClusterId clusterId); boolean emberAfContainsClient(int8u endpoint, EmberAfClusterId clusterId);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">All of the Zigbee application framework APIs intended to be used by the customer application include the “emberAf” prefix.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">APIs for getting information about endpoints and attributes are included in app/framework/util/attribute-storage.h. For instance, to deter- mine if an endpoint contains a certain attribute, use the function emberAfContainsAttribute(int8u endpoint, ClusterId, AttributeId at- tributeId). It returns a Boolean indicating if the requested attribute and cluster are implemented on the specific endpoint.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 60pt;text-indent: -36pt;text-align: left;">Note: <span class="p">The read and write attribute needs an endpoint. If you do not include one, the compiler returns a warning that the function is declared implicitly, but not a compiler error. Therefore, pay attention to warnings.</span></p></li><li><h3 style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;"><a name="bookmark17">Application Framework Callback Interface</a><a name="bookmark25">&zwnj;</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;"><a href="https://www.silabs.com/support" class="s7" target="_blank">The Zigbee application framework callbacks are intended to be used as a means to remove all customer code from the Zigbee application framework. If any of your application code needs to be put into the Zigbee application framework, Silicon Labs views this as a bug with the Zigbee application framework, because it means that a callback that would satisfy your application requirement is missing. In this case, please open a ticket through the Contact Support link at </a><a href="https://www.silabs.com/support" class="s9" target="_blank">https://www.silabs.com/support</a><a href="https://www.silabs.com/support" class="s7" target="_blank">.</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Generally, when a callback is called the Zigbee application framework is giving the application code a first crack at some incoming message or requesting some piece of application data. Within the callback API, some callbacks return a Boolean value indicating that the message has been handled and no further processing should be done. If you are doing something that conflicts with the Zigbee application framework’s handling of a particular message, return TRUE to indicate that the message was complete. This ensures that the Zigbee application framework does not interfere with your handling of the message.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l13"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark18">Callback Generation</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 107%;text-align: justify;">AppBuilder has the ability to generate a stub callback file for you. By default, AppBuilder chooses not to generate the callback stub file if it finds that the file already exists in the generation directory. You must specifically tell the application to overwrite an existing file.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">When you regenerate files in the future, AppBuilder protects your generated callbacks file from being overwritten by asking if you want to overwrite it. By default, AppBuilder will not overwrite any previously created callbacks file. If you choose to overwrite the file, AppBuilder backs up the previous version to the file &lt;appname&gt;_callbacks.bak.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 60pt;text-indent: -36pt;text-align: justify;">Note: <span class="p">You can implement your callbacks wherever you want; they do not need to be implemented in the generated callbacks file. However, if you implement them in a different location, clear them out of the generated callback file so that your linker won’t complain about duplicate definitions for the callback functions.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark19">Non-Cluster-Related Callbacks</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The callback interface is divided up into sections within the AppBuilder GUI for ease of use. The first section, Non-Cluster-Related Callbacks, is made up of callbacks that are described in the callbacks.xml document located at tool/appbuilder/callbacks.xml. These callbacks have been manually inserted into the Zigbee application framework code in locations where customers have indicated that they wish to receive information about the function of the Zigbee application framework.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">All global commands fall into this category. The Zigbee application framework contains handling code for global commands. If any global command callback returns TRUE, this indicates that the command has been handled by the application and no further command handling should take place. If the callback returns FALSE, then the Zigbee application framework continues to process the command normally.</p><p class="s5" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Example</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The pre-command received callback (<span class="s8">emberAfPreCommandReceivedCallback(EmberAfClusterCommand* cmd, boolean isInterpan</span>) is called after a ZCL command has been received but has not yet been processed by the Zigbee application framework’s command handling code. The command is parsed into a useful struct <span class="s8">EmberAfClusterCommand</span>, which provides an easy way to access relevant data about the command including its <span class="s8">EmberApsFrame</span>, message type, source, buffer, length, and any relevant flags for the command. This callback also returns a Boolean value indicating if the command has been handled. If the callback returns TRUE, then it is assumed that the command has been handled by the application and no further action is taken.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark20">Cluster-Specific Command Handling Callbacks</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The cluster-related callbacks are generated by the Zigbee application framework to allow receipt of a pre-parsed command coming over the air. Generally, a one-to-one relationship exists between ZCL commands and the cluster-specific callbacks.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The cluster-specific command callbacks all return a Boolean value. This return value allows you to short-circuit command handling in- cluded in the application framework. If you implement a cluster-specific command callback and it returns a value of TRUE to the Zigbee application framework, the framework assumes that the command has been handled outside the framework and that any required com- mand or default response has been sent. If the cluster-specific command returns FALSE, the framework assumes that the application code did not understand the command and sends a default response with a status of ‘unsupported cluster command’.</p><ol id="l14"><li><p class="s5" style="padding-top: 7pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark21">Command Callback Context</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">All command-related callbacks are called from within the context of the emberIncomingMessageHandler. This means that Zigbee APIs that are available to the application within that context are available within the command handling callbacks as well. These APIs are listed in the stack API file located at stack/include/message.h. The stack APIs that are available in the command callbacks are listed in the stack message header located at stack/include/message.h and include:</p><p class="s10" style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">emberGetLastHopLqi() emberGetLastHopRssi() emberGetSender() emberGetSenderEui64() emberGetBindingIndex()</p><p class="s10" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">emberSendReply() (for incoming APS retried unicasts only) emberSetReplyBinding()</p><p class="s10" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">emberNoteSendersBinding()</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark22">Array Handling in Command Callbacks</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Any Zigbee message that contains an array of arguments is passed as an int8u* pointer to the beginning of the array. This is done even when the framework knows that the arguments in the array may be of another type, such as an int16u or int32u, because of byte alignment issues on the various processors on which the framework may run. Developers implementing the callback must parse the array and cast its elements appropriately for their hardware.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark23">Global Command Callbacks</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Zigbee global commands are also covered in the Zigbee application framework callback interface. These callbacks can be used to receive responses to global commands. For instance, if your device sends a global read attribute command to another device, it can process the command response by implementing the emberAfReadAttributesResponseCallback.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark24">Callback Flow</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The following figure shows how a message received by the application framework’s implementation of emberIncomingMessageHandler is processed and flows through the framework code and out to the application implemented callbacks.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 65pt;text-indent: 0pt;text-align: left;"><span><img width="611" height="379" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_012.gif"/></span></p><p class="s5" style="padding-top: 8pt;padding-left: 28pt;text-indent: 0pt;text-align: center;">Figure 6-1. Incoming Message Flow</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Once the incoming message is determined to be an incoming global command, it is passed off to the global command handling for processing, as shown in the following figure.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 87pt;text-indent: 0pt;text-align: left;"><span><img width="557" height="482" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_013.gif"/></span></p><p class="s5" style="padding-top: 8pt;padding-left: 28pt;text-indent: 0pt;text-align: center;">Figure 6-2. Global Command Handling</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Otherwise, if it is found to be a cluster specific command, it is passed off to the cluster-specific command processing, as shown in the following figure.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;"><span><img width="552" height="562" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_014.gif"/></span></p><p class="s5" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Figure 6-3. Cluster-Specific Command Processing</p><p class="s4" style="padding-bottom: 2pt;text-indent: 0pt;text-align: right;">Time Handling</p><p style="padding-left: 22pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="724" height="1" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_015.png"/></span></p></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;"><a name="bookmark26">Time Handling</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework provides a single API for accessing the current time on the system (<span class="s8">int32u emberAfGetCur- rentTime()</span>), which is described in app/framework/util/time-util.h. This section describes how the function is implemented in app/frame- work/util/time-util.c.:</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">If the ZCL time cluster server is implemented on the system, then this function retrieves the time from the server through the function call (<span class="s8">int32u emberAfTimeClusterServerGetCurrentTime()</span>), in which case the time is read from the time cluster server’s time attribute and returned. If the time cluster server is not implemented, then <span class="s8">emberAfGetCurrentTime </span>calls <span class="s8">emberAfGetCur- rentTimeCallback</span>.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">If your device needs to know the current time but does not implement the time cluster server plugin, it is responsible for maintaining its own time somewhere on the system and returning that time through the <span class="s8">emberAfGetCurrentTimeCallback </span>when it is requested. This is especially important for SE devices that do not implement the time cluster server, like an in-premise display (IPD). Essentially the IPD is on its own when it comes to time management. It would be outside the specification (as currently interpreted) for a non-Energy Service Portal to implement the time cluster server. Therefore, the IPD must maintain its own knowledge of time and provide it to the framework when requested through the <span class="s8">emberAfGetCurrentTimeCallback</span>.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">If your application includes the time cluster server, the time cluster server code always tries to initialize and update the time server’s time attribute through the <span class="s8">emberAfGetCurrentTimeCallback</span>. If the <span class="s8">emberAfGetCurrentTimeCallback </span>returns 0, then the time cluster server increments the stored attribute once per second. Thus you can use the time cluster server to store and maintain real time on the system without implementing the <span class="s8">emberAfGetCurrentTimeCallback</span>, if the actual time value can be synced from another device on the system and written into the time server’s time attribute. For more information on how time is handled by the bundled implementation of the time cluster server see app/framework/plugin/time-server/time-server.c.</p></li><li><h3 style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;"><a name="bookmark27">Events</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework and its associated cluster code use the Zigbee Stack event mechanism to schedule events on both the SoC and the host. Use of the Zigbee event mechanism saves code and RAM, and works better with sleepy devices.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">At a high level, the event mechanism provides a central location where all periodic actions taken by the device can be activated and deactivated based on either some user input, an over-the-air command or device initialization. The event mechanism is superior to the constant tick mechanism it replaces because it allows the Zigbee application framework to know precisely when the next action is going to occur on the device. This is extremely important for sleeping devices that need to know exactly when they must wake up to take some action - or more importantly that they cannot go to sleep because some event is in progress. The Zigbee application framework has two types of events: custom events and cluster events. Custom events are created by the Zigbee application framework user and can be used for any purpose within the application. Cluster events are specifically related to the cluster implementations in the Zigbee application framework’s plugins.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l15"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark28">Creating a Custom Event</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 107%;text-align: justify;">The Zigbee application framework uses the Zigbee standard event mechanism to control and run “custom” application events within the Zigbee application framework. The stack’s event mechanism is documented in the event.h header file located at stack/include/event.h.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;"><a name="bookmark29">The Zigbee application framework and AppBuilder provide a helpful interface for creating and adding custom events to your application. To create a custom event in AppBuilder, open the “Includes” tab in your AppBuilder configuration file. In the “Event Configuration” section click </a><b>Add new</b>. This adds an event to the list of events that will be run by the Zigbee application framework, as well as stubs for your custom event to the “callbacks” file generated by AppBuilder.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l16"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;">Event Function and Event Control</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">A custom event consists of two parts: The event function, called when the event fires, and the EmberEventControl struct, which is used to schedule the event. The framework’s event mechanism must know about each of these items so that it can both keep track of when the next event will occur for the purposes of sleeping and also so that it knows what function to call when the event fires. Further docu- mentation on creating an event is provided in the event.h header file located at stack/include/event.h.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark30">Custom Event Example</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Z3Light sample application uses a custom event to manage its state. The event consists of two parts: the EmberEventControl struct called commissioningLedEventControl, and the event function which is called each time the event fires. The event function is called the commissioningLedEventHandler. The event and event controls are included in the Z3Light_callbacks.c file shipped with the sample ap- plication. Documentation for the Z3Light application can be found in the Description field of the “General” tab in AppBuilder when creating a new application based on this sample scenario.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark31">How Cluster Events Are Created</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Every cluster includes a server and a client “tick” callback. AppBuilder generates an event table with a single event for each cluster server or client on each endpoint. The actual event table is generated into the &lt;DeviceName&gt;_endpoint_config.h header, which is included and used in the Zigbee application framework’s event code in app/framework/util/af-event.c.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 60pt;text-indent: -36pt;text-align: justify;">Note: <span class="p">The event table is created at compile time and is static. Thus, events cannot be randomly added or removed from the event table at runtime. The event table entry must be present, and then the code can manage its schedule so that it is either active and waiting to be called or deactivated and waiting to be activated and scheduled.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark32">How Cluster Events Are Scheduled</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The plugin or application code can manage cluster-related events in the event table by using the Zigbee application framework’s event management API. This API consists of two functions, <span class="s8">emberAfScheduleClusterTick </span>and <span class="s8">emberAfDeactivateCluster- Tick</span>.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">A <i>tick </i>is the basic unit of time used in the event system. The duration of a tick depends on the platform that is being used. Using the current Zigbee platform, 1 tick is approximately equal to</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 173pt;text-indent: 0pt;text-align: center;">(𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚 𝑝𝑝𝑚𝑚𝑝𝑝 𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚)</p><p style="padding-left: 157pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="145" height="1" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_016.png"/></span></p><p class="s11" style="padding-left: 173pt;text-indent: 0pt;text-align: center;">𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀_𝑇𝑇𝑀𝑀𝑀𝑀𝑇𝑇𝑀𝑀_𝑃𝑃𝑀𝑀𝑃𝑃_𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀</p><p class="s12" style="padding-top: 7pt;text-indent: 0pt;line-height: 12pt;text-align: left;">= <span class="s13">100</span><span class="s11">0  </span>= .9765625 𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚 𝑝𝑝𝑚𝑚𝑝𝑝 𝑡𝑡𝑚𝑚𝑚𝑚𝑡𝑡<span class="p">,</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="20" height="1" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_017.png"/></span></p><p class="s11" style="padding-left: 9pt;text-indent: 0pt;line-height: 6pt;text-align: left;">1024</p><p class="s14" style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;"><span class="p">where </span><span class="s6">MILLISECOND_TICKS_PER_SECOND </span><span class="p">is the number of clock ticks per second. Therefore, when </span><span class="s8">emberAfScheduleClus- terTick </span>is called with a value of <i>t </i>for the <i>delayMs </i>argument, the event will be run in no less than</p><p style="text-indent: 0pt;text-align: left;"><span><img width="140" height="1" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_018.png"/></span></p><p class="s16" style="padding-top: 9pt;padding-left: 159pt;text-indent: 0pt;line-height: 65%;text-align: left;">�<span class="s17">𝑡𝑡 ∗ �      </span><span class="s11">(𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚 𝑝𝑝𝑚𝑚𝑝𝑝 𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚𝑚)</span></p><p class="s11" style="padding-left: 181pt;text-indent: 0pt;line-height: 7pt;text-align: left;">𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀_𝑇𝑇𝑀𝑀𝑀𝑀𝑇𝑇𝑀𝑀_𝑃𝑃𝑀𝑀𝑃𝑃_𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="text-indent: 0pt;text-align: left;">�� = ⌈𝑡𝑡 ∗ .<span class="s12">9765625 </span>⌉ <span class="s14">milliseconds.</span></p><p class="s14" style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Of course, the empirical error in this value depends on the reliability of the clock source.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l17"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark33">emberAfScheduleClusterTick</a></p><p class="s8" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">emberAfScheduleClusterTick <span class="p">uses the endpoint, cluster id, and client/server identity to find the associated event in the event table. The event table entry is generated by AppBuilder into </span>&lt;DeviceName&gt;_endpoint_config.h<span class="p">. If it cannot find the event table entry, </span>emberAfScheduleClusterTick <span class="p">returns the EmberStatus EMBER_BAD_ARGUMENT to the caller. If it finds the event table entry, then it schedules the event to take place in the number of milliseconds requested by the caller, and it returns EMBER_SUCCESS.</span></p><p class="s10" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">EmberStatus emberAfScheduleClusterTick( int8u endpoint,</p><p class="s10" style="padding-left: 240pt;text-indent: 0pt;text-align: justify;">int16u clusterId, boolean isClient, int32u timeMs,</p><p class="s10" style="padding-left: 240pt;text-indent: 0pt;text-align: justify;">EmberAfEventSleepControl sleepControl);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">The EmberAfEventSleepControl argument allows the caller to indicate what the device may do while the event is active in the event table. This value is only relevant for sleepy devices; it has no effect for devices that do not go to sleep. The possible values for EmberAfE- ventSleepControl are enumerated in app/framework/include/af-types.h, as follows:</p><ul id="l18"><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: justify;">EMBER_AF_OK_TO_HIBERNATE means that the application may go into prolonged deep sleep until the event needs to be called. Use this sleep control value if the scheduling code does not care what the device does up to the point when the event is called.</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: justify;">EMBER_AF_OK_TO_NAP means that the device should sleep for the nap period and should wake up to poll between naps until the event is called. Use this sleep control value if the scheduling code wants the device to poll periodically until the event is called. This is particularly useful if the scheduled event is a timeout waiting for some reply from another device on the network. If the event is a timeout, you don’t want the device to go into hibernation until the timeout is called, because it will never hear the message it is waiting for, thereby guaranteeing that the timeout will be called.</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: justify;">EMBER_AF_STAY_AWAKE means that the device should not sleep at all but should stay awake until the event is called. Use this event if you are scheduling a very frequent event and don’t want the device to nap for a very short period of time since the device will poll each time it wakes up. If the device is held out of sleep entirely, it will poll once per second.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark34">emberAfDeactivateClusterTick</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The deactivation function is used to turn off an event. This function should be called when the scheduled event is called to ensure that the event code does not continue to call the event. It may also be called before the event is called if the event is no longer necessary.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 60pt;text-indent: -36pt;text-align: justify;"><b>Note: </b>In the Zigbee application framework <span class="s8">emberAfDeactivateClusterTick </span>is automatically called before the event fires to ensure that the event will not continue to be called on every tick. You can see the call to <span class="s8">emberAfDeactivateCluster- Tick </span>in the generated event table output from AppBuilder as of version 2.1.50.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 107%;text-align: justify;">DeactivateClusterTick is similar to ScheduleClusterTick in that it takes most of the same arguments, since it also has to locate the clus- terTick in the event table before shutting it off.</p><p class="s10" style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">EmberStatus emberAfDeactivateClusterTick(int8u endpoint,</p><p class="s10" style="padding-left: 245pt;text-indent: -5pt;text-align: center;">int16u clusterId, boolean isClient);</p></li></ol></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;"><a name="bookmark35">Attribute Management</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l19"><li><p class="s5" style="padding-top: 10pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark36">ZCL Attribute Configuration</a><a name="bookmark45">&zwnj;</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">In the Zigbee application framework , attribute storage is managed by two .c files (app/framework/util attribute-storage.c and attribute- table.c) as well as a single header file (&lt;appname&gt;_endpoint_config.h), which AppBuilder generates from the application configuration. The endpoint configuration header file sets up the attribute metadata and the actual attribute storage.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">You have several options for attribute storage:</p><ul id="l20"><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">External Attributes</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Persistent Memory Storage</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Singleton</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Attribute Bounding</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Attribute Reporting</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l21"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark37">Attribute Storage Endianness</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">All attributes that are not a ZCL string type are expected to be stored with the same endianness as the platform on which the application is being run. On the EFR32, this means that attributes with a non-string type are expected to be stored with the least significant byte first (LSB, little endian).</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark38">Implications of Attribute Storage Endianness</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Zigbee protocol demands that all values that are not a string or byte array type be sent over the air in a Little Endian or LSB format. The implication of this for the EFR32 and other little-endian platforms is that no byte swapping needs to be done with attributes when they are pulled from attribute storage and sent over the air. Conversely, when the Zigbee application framework is run a big-endian processor, like certain UNIX host systems for EZSP-UART, it will perform byte swapping on integer type attributes before they are sent over the air so that they are sent in the LSB format.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The previous section says that attributes are expected to be stored in the proper format because no byte swapping is done on local writes into the attribute table from native types or from byte arrays. Therefore, it is up to the user to ensure that byte arrays which represent Zigbee integer types but do not map directly to a native type like the int16u or int32u are represented in the byte order of the application platform.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">If you are writing an application that may be run on several platforms with different endianness, you may check the endianness of the platform by using the #define BIGENDIAN_CPU provided by the HAL shipped with the Zigbee stack.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Example: Consider the simple-meter-server plugin’s test code located at app/framework/plugin/simple-metering-server/simple-metering- test.c. This test code pulls the simple metering daily summation attribute from the attribute table, updates it, and puts it back into the attribute table. Unfortunately, the daily summation is a Zigbee 48-bit unsigned integer, which is not a native data type.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Zigbee HAL for the EFR32 family of processors has no native data type like an int48u into which the daily summation attribute can be read and simply manipulated. As a result, the attribute must be read into a byte array and the byte array must be manipulated before it is written back into the attribute table. During this manipulation it is important for the developer to remember that on the EFR32 the attribute is stored LSB, so the manipulation must be done LSB. Otherwise the value will be stored and sent over the air in the wrong format when it is read by another device on the network.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 60pt;text-indent: -36pt;text-align: left;">Note: <span class="p">For EZSP host applications, since all attributes are stored on the host processor in an NCP + Host design, it is the endianness of the host that counts for attribute storage.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark39">External Attributes (E)</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">You may wish to store the values for some attributes in a location external to the Zigbee application framework. This type of storage makes the most sense for attributes that must be read from the hardware each time they are requested. In a case like this, no real reason exists to store a copy of the attribute in some wasted RAM space within the Zigbee application framework.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Mark an attribute as externally located by clicking on the “E” checkbox next to the attribute in the AppBuilder GUI. The attribute’s metadata will be tagged to indicate that the Zigbee application framework should not reserve memory for the storage of that attribute. Instead, when</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">that attribute is to be read or written, the Zigbee application framework accesses it by calling emberAfExternalAttributeReadCallback and emberAfExternalAttributeWriteCallback.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 60pt;text-indent: -36pt;text-align: left;">Note: <span class="p">Once you designate a single attribute as “External” these two callbacks are automatically included in your generated callback.c file.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">The application is expected to respond to the request immediately. No state machine is currently associated with accessing external attributes that would be able to, for example, start a read and then callback again in a minute to see how the data read is going.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Any attribute that cannot be returned or updated in a timely manner is not currently a candidate for externalization. For attributes of this type, Silicon Labs suggests that you include Zigbee application framework storage and update the value in the Zigbee application frame- work on a specific interval within the emberAfMainTickCallback.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark40">Persistent Memory Storage (F)</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Silicon Labs System-on-Chip (SoC) chips can store attributes in persistent memory (SIMEEPROM or NVM3). In these cases, mark the attribute for persistent storage by clicking on the “F” checkbox next to the attribute in the AppBuilder GUI. This automatically adds the necessary header file code to the generated &lt;appname&gt;_tokens.h file and marks the attribute as persisted in flash within the attribute’s metadata.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Because each host chip has its own way of storing persistent data, the Zigbee application framework and AppBuilder do not have a way of persisting attributes on the host. However, you can mark any attribute you wish to persist as ‘External’ and then handle the data persistence yourself within emberAfExternalAttributeReadCallback and emberAfExternalAttributeWriteCallback.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark41">Singleton (S)</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">While ZCL clusters and attributes can be spread across multiple endpoints, it does not make sense to have multiple instances of many of these attributes. For instance, the Basic Cluster may be implemented on three different endpoints, but it doesn’t make sense to store three versions of the mandatory ‘ZCL Version’ attribute, since each endpoint will likely have the same version. Mark attributes like this by clicking on the checkbox marked “S” next to the attribute in AppBuilder. As a convenience, the Zigbee application framework provides a default ‘Singleton’ modifier for many of the obvious cases. This default modifier can be overridden if you choose.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Attributes marked as singleton are stored in a special singleton storage area in memory. A read or write to any endpoint for one of these attributes resolves to an access of the same location in memory.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark42">Attribute Bounding (B)</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Attributes which contain min and max values defined by the Zigbee ZCL specification can be bounded within the Zigbee application framework. When an attribute is bounded, the min and max values defined by the ZCL specification are included in the generated &lt;ap- pname&gt;_endpoint_config.h file. When the application attempts to write one of these attributes, the attribute write succeeds only if its value falls within the bounds defined by the ZCL specification.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li></ul></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark43">Interacting with ZCL Attributes</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework attributes table exposes several APIs that help you do things like read, write, and verify that certain attributes are included on a given endpoint. The prototypes for functions used to interact with the attribute tables are conveniently located in app/framework/include/af.h. The API includes:</p><p class="s8" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">emberAfLocateAttributeMetadata: <span class="p">Retrieves the metadata for a given attribute</span></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Use this function to determine if the attribute exists or is implemented on a given endpoint. You can use the emberAfAttributeMetadata pointer returned to access more information about the attribute in question including its type, size, defaultValue and any internal settings for the attribute contained in its mask.</p><p class="s10" style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">EmberAfAttributeMetadata *emberAfLocateAttributeMetadata(int8u endpoint, EmberAfClusterId cluster, EmberAfAttributeId attribute);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework stores metadata for all of the attributes that it contains in CONST memory. It does this for all attributes, including those that may have values stored externally or singletons.</p><ol id="l22"><li><p class="s5" style="padding-top: 7pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark44">ZCL String Attributes</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The String data type is a special case in the ZCL. All strings are MSB with the first byte being the length byte for the string. There is no null terminator or similar concept in the ZCL. Therefore a 5-byte string is actually 6 bytes long, with the first byte indicating the length of the proceeding string. For example, “05 68 65 6C 6C 6F” is a ZCL string that says “hello.”</p></li></ol></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;"><a name="bookmark46">Command Handling and Generation</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l23"><li><p class="s5" style="padding-top: 10pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark47">Sending Commands and Command Responses</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework API includes many useful macros for sending and responding to ZCL commands. All of the macros are defined in the file client-command-macro.h. This file is generated for each project. For example, after building project Z3Light the file can be found in &lt;user workspace&gt;/Z3Light/client-command-macro.h.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">To send a command, do the following:</p><p class="s5" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Sending a command:</p><ol id="l24"><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Construct a command using a fill macro from client-command-macro.h file:</p><p style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;text-align: justify;">For example:</p><p class="s8" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">emberAfFillCommandIdentifyClusterIdentify(identifyTime);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 38pt;text-indent: 0pt;text-align: justify;">identifyTime is an int16u defined in the spec as the number of seconds the device should continue to identify itself. This macro fills the command buffer with the appropriate values.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">Retrieve a pointer to the command EmberApsFrame and populate it with the appropriate source and destination endpoints for your command. Other values in the ApsFrame such as sequence number are handled by the framework, so you don’t need to worry about them.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">Once the command has been constructed, the command can be sent as a unicast, multicast, or broadcast using one of the following functions</p></li></ol><p class="s8" style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">EmberStatus emberAfSendCommandMulticast(int16u multicastId);</p><p class="s8" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">EmberStatus emberAfSendCommandUnicast(EmberOutgoingMessageType type, int16u indexOrDes- tination);</p><p class="s8" style="padding-left: 38pt;text-indent: 0pt;line-height: 11pt;text-align: left;">EmberStatus emberAfSendCommandBroadcast(int16u destination);</p><p class="s5" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Sending a response to an incoming command:</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Use a similar mechanism to send a response to an incoming command.</p><ol id="l25"><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">Fill the response command buffer using the command response macros included in app/framework/gen/client-command-macro.h such as:</p><p class="s8" style="padding-top: 7pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">emberAfFillCommandIdentifyClusterIdentifyQueryResponse(timeout)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 38pt;text-indent: 0pt;text-align: justify;">Timeout is an int16u representing the number of seconds the device will continue to identify itself.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">You don’t need to worry about the endpoints set in the response EmberApsFrame since these are handled by the framework.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Send the response command by calling <span class="s18">emberAfSendResponse</span>().</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-top: 10pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark48">ZCL Command Processing</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">When the Zigbee application framework receives a ZCL command, it is passed off for command processing inside the utility function emberAfProcessMessage, located within app/framework/util/util.c. The process message function parses the command and populates a local struct of the type EmberAfClusterCommand. Once this struct is populated, it is assigned to the global pointer emAfCurrentCommand so that it is available to every function called during command processing.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">EmberAfProcessMessage first calls emberAfPreCommandReceivedCallback to give the application a chance to handle the command. If the command is a global command, it is passed to process-global-message.c for processing; otherwise, it is passed to process-cluster- message.c for processing.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 60pt;text-indent: -36pt;text-align: left;">Note: <a href="#bookmark25" class="s7">For more information on command processing flow, please see the message flow charts included in section </a><a href="#bookmark25" class="a">6 Application Frame- work Callback Interface</a><a href="#bookmark25" class="s7">.</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l26"><li><p class="s5" style="padding-top: 8pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark49">app/framework/util/process-global-message.c</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Process-global-message.c handles all global commands, such as reading and writing attributes. Global commands do not currently have associated command callbacks the way cluster-specific commands do.</p></li><li><p class="s5" style="padding-top: 7pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark50">app/framework/util/process-cluster-message.c</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Process-cluster-message.c handles all cluster-specific commands. Most cluster-specific commands are in turn passed to the generated file call-command-handler.c located at app/framework/gen/call-command-handler.c. This generated file parses the command’s parame- ters and optionally calls the associated cluster-specific callback.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The generated file call-command-handler.c currently does not handle key establishment. Command handling was deemed too complex for the current command handler generator. Commands for key establishment are passed directly to the cluster code for processing in app/framework/cluster/key-establishment.c.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 60pt;text-indent: -36pt;text-align: left;">Note: <span class="p">Since the cluster-specific command callbacks are called within the command handling context, all of the metadata associated with any command handled in one of these callbacks is available from the global pointer emAfCurrentCommand.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Always access the global pointer emAfCurrentCommand by using the convenience macro provided in app/framework/include/af.h called emberAfCurrentCommand().</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark51">Sending a Default Response</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework does not automatically send a default response for command callbacks implemented by the application. In order to improve system reliability and flexibility, Silicon Labs have handed all the default response handling over to the application. This means that, while you now have complete control over sending default responses for commands that you handle, you also are responsible for sending default responses for all those commands. A default response must be sent for any unicast message that does not have a specific response and is not itself a default response. For more information on when default response should and should not be sent, please refer to the Zigbee documentation.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Zigbee-created plugins handle sending default responses for all of the commands that they handle. Any commands that the plugins do not handle automatically return EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND, or something like it. Your application needs to do the same for all of the commands it handles that do not themselves have a specific command response.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Silicon Labs has created a default response API to make this is simple as possible. The emberAfSendDefaultResponse command takes two arguments: the current command, and the status byte. The current command can be retrieved from the Zigbee application framework using emberAfCurrentCommand(). The ZCL status bytes used for default response are enumerated in app/framework/gen/enum.h.</p><p class="s10" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">void emberAfSendDefaultResponse(EmberAfClusterCommand *cmd, EmberAfStatus status);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">A typical use of this function looks like:</p><p class="s10" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">emberAfSendDefaultResponse( emberAfCurrentCommand(), EMBER_ZCL_STATUS_SUCCESS );</p></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;"><a name="bookmark52">The Command Line Interface (CLI)</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework includes a command line interface (CLI) that implements many common commands and cluster-spe- cific commands. For instance, commands related to common functionality, like network formation and attribute read and write, are imple- mented by the CLI.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;line-height: 106%;text-align: justify;">The Zigbee application framework CLI can take integer arguments as both decimal and hexadecimal notation. If an argument includes the 0x prefix, it is assumed to be hexadecimal, otherwise decimal. In addition, arrays of integers may be passed within curly braces, and strings may be passed inside quotations.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">A command line reference may be found in the <i>Zigbee Application Framework API Reference</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l27"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: justify;"><a name="bookmark53">Extending the Command Line Interface</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The process for extending the command line interface is as follows:</p><ol id="l28"><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">In the “Includes” tab in AppBuilder, add a macro entitled EMBER_AF_ENABLE_CUSTOM_COMMANDS. This enables the inclusion of a command array called emberAfCustomCommands in the file /app/framework/cli/custom-cli.h that is extern’d in that file. You must now provide a definition for the emberAfCustomCommands array to satisfy the requirements of the linker at compile time.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">Define an array of type EmberCommandEntry called emberAfCustomCommands in your application.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">The example below adds two commands, “form” and “join.” These commands each take four arguments described in the short hand form “uvsh.” The shorthand used to describe arguments to a command is described in the next section.</p><p class="s8" style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;line-height: 106%;text-align: left;">// The table of network commands. EmberCommandEntry networkCommands[] = {</p><p class="s8" style="padding-left: 50pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{ &quot;form&quot;, formCommand, &quot;uvsh&quot; },</p><p class="s8" style="padding-left: 50pt;text-indent: 0pt;text-align: left;">{ &quot;join&quot;, joinCommand, &quot;uvsh&quot; },</p><p class="s8" style="padding-left: 50pt;text-indent: 0pt;text-align: left;">...</p><p class="s8" style="padding-left: 50pt;text-indent: 0pt;text-align: left;">{ NULL }</p><p class="s8" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">};</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">All of the commands that you define are of the type EmberCommandEntry. The type EmberCommandEntry is documented in the stack’s API reference. Basically, they are of the form “&lt;string&gt; command”, &lt;function&gt;, “&lt;string&gt; args”, where the arguments are a string of characters indicating underlying types of the passed arguments. The definition for EmberCommandEntry from /app/util/se- rial/command-interpreter2.h is included below.</p></li></ol><p class="s10" style="padding-top: 7pt;padding-left: 64pt;text-indent: 0pt;text-align: left;">typedef PGM struct { #endif</p><p class="s10" style="padding-left: 75pt;text-indent: 0pt;line-height: 10pt;text-align: left;">/** Use letters, digits, and underscores, &#39;_&#39;, for the command name.</p><p class="s10" style="padding-left: 80pt;text-indent: 0pt;line-height: 10pt;text-align: left;">* Command names are case-sensitive.</p><p class="s10" style="padding-left: 80pt;text-indent: 0pt;line-height: 10pt;text-align: left;">*/</p><p class="s10" style="padding-left: 75pt;text-indent: 0pt;line-height: 10pt;text-align: left;">PGM_P name;</p><p class="s10" style="padding-left: 75pt;text-indent: 0pt;line-height: 10pt;text-align: left;">/** A reference to a function in the application that implements the</p><ul id="l29"><li><p class="s10" style="padding-left: 97pt;text-indent: -16pt;line-height: 10pt;text-align: left;">command.</p></li><li><p class="s10" style="padding-left: 97pt;text-indent: -16pt;line-height: 10pt;text-align: left;">If this entry refers to a nested command, then action field</p></li><li><p class="s10" style="padding-left: 97pt;text-indent: -16pt;line-height: 10pt;text-align: left;">has to be set to NULL.</p><p class="s10" style="padding-left: 80pt;text-indent: 0pt;line-height: 10pt;text-align: left;">*/</p><p class="s10" style="padding-left: 75pt;text-indent: 0pt;line-height: 10pt;text-align: left;">CommandAction action;</p><p class="s10" style="padding-left: 75pt;text-indent: 0pt;line-height: 10pt;text-align: left;">/**</p></li><li><p class="s10" style="padding-left: 91pt;text-indent: -10pt;line-height: 10pt;text-align: left;">In case of normal (non-nested) commands, argumentTypes is a</p></li><li><p class="s10" style="padding-left: 91pt;text-indent: -10pt;line-height: 10pt;text-align: left;">string that specifies the number and types of arguments the</p></li><li><p class="s10" style="padding-left: 97pt;text-indent: -16pt;line-height: 10pt;text-align: left;">command accepts. The argument specifiers are:</p></li><li><p class="s10" style="padding-left: 97pt;text-indent: -16pt;line-height: 10pt;text-align: left;">- u: one-byte unsigned integer.</p></li><li><p class="s10" style="padding-left: 97pt;text-indent: -16pt;line-height: 10pt;text-align: left;">- v: two-byte unsigned integer</p></li><li><p class="s10" style="padding-left: 97pt;text-indent: -16pt;line-height: 10pt;text-align: left;">- w: four-byte unsigned integer</p></li><li><p class="s10" style="padding-left: 97pt;text-indent: -16pt;line-height: 10pt;text-align: left;">- s: one-byte signed integer</p></li><li><p class="s10" style="padding-left: 97pt;text-indent: -16pt;line-height: 10pt;text-align: left;">- b: string. The argument can be entered in ascii by using</p></li><li><p class="s10" style="padding-left: 134pt;text-indent: -54pt;line-height: 10pt;text-align: left;">quotes, for example: &quot;foo&quot;. Or it may be entered</p></li><li><p class="s10" style="padding-left: 134pt;text-indent: -54pt;line-height: 10pt;text-align: left;">in hex by using curly braces, for example: { 08 A1 f2 }.</p></li><li><p class="s10" style="padding-left: 134pt;text-indent: -54pt;line-height: 10pt;text-align: left;">There must be an even number of hex digits, and spaces</p></li><li><p class="s10" style="padding-left: 134pt;text-indent: -54pt;line-height: 10pt;text-align: left;">are ignored.</p></li><li><p class="s10" style="padding-left: 97pt;text-indent: -16pt;line-height: 10pt;text-align: left;">- *: zero or more of the previous type.</p></li><li><p class="s10" style="padding-left: 134pt;text-indent: -54pt;line-height: 10pt;text-align: left;">If used, this must be the last specifier.</p></li><li><p class="s10" style="padding-left: 97pt;text-indent: -16pt;line-height: 10pt;text-align: left;">- ?: Unknown number of arguments. If used this must be the only</p></li><li><p class="s10" style="padding-left: 134pt;text-indent: -54pt;text-align: left;">character. This means, that command interpreter will not</p></li><li><p class="s10" style="padding-top: 7pt;padding-left: 134pt;text-indent: -54pt;line-height: 10pt;text-align: left;">perform any validation of arguments, and will call the</p></li><li><p class="s10" style="padding-left: 134pt;text-indent: -54pt;line-height: 10pt;text-align: left;">action directly, trusting it that it will handle with</p></li><li><p class="s10" style="padding-left: 134pt;text-indent: -54pt;line-height: 10pt;text-align: left;">whatever arguments are passed in.</p></li><li><p class="s10" style="padding-left: 97pt;text-indent: -16pt;line-height: 10pt;text-align: left;">Integer arguments can be either decimal or hexadecimal.</p></li><li><p class="s10" style="padding-left: 97pt;text-indent: -16pt;text-align: left;">A 0x prefix indicates a hexidecimal integer. Example: 0x3ed.</p><p class="s10" style="padding-left: 80pt;text-indent: 0pt;text-align: left;">*</p></li><li><p class="s10" style="padding-top: 3pt;padding-left: 96pt;text-indent: -16pt;text-align: left;">In case of a nested command (action is NULL), then this field</p></li><li><p class="s10" style="padding-top: 3pt;padding-left: 97pt;text-indent: -16pt;line-height: 10pt;text-align: left;">contains a pointer to the nested EmberCommandEntry array.</p></li></ul><p class="s10" style="padding-left: 80pt;text-indent: 0pt;line-height: 10pt;text-align: left;">*/</p><p class="s10" style="padding-left: 75pt;text-indent: 0pt;line-height: 10pt;text-align: left;">PGM_P argumentTypes;</p><p class="s10" style="padding-left: 75pt;text-indent: 0pt;line-height: 10pt;text-align: left;">/** A description of the command.</p><p class="s10" style="padding-left: 80pt;text-indent: 0pt;line-height: 10pt;text-align: left;">*/</p><p class="s10" style="text-indent: 0pt;line-height: 10pt;text-align: right;">PGM_P description;</p><p class="s10" style="text-indent: 0pt;line-height: 10pt;text-align: right;">} EmberCommandEntry;</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark54">CLI Examples</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l30"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark55">Example 1: Creating a network using Zigbee 3.0 Security</a></p><ol id="l31"><li><p style="padding-top: 5pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">Connect to the coordinator of the network using the Simplicity Studio console or a simple telnet program. If the device exposes its CLI on port 1, you can connect to it by telnetting to port 4901. Once connected to the device, use the network creator plugin’s form command to form the network.</p><p class="s8" style="padding-top: 7pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">Device 1&gt; plugin network-creator form 1 0xabcd 10 15</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-left: 42pt;text-indent: -18pt;text-align: left;">Use the network creator security plugin’s open-network command to permit joining, so that new devices can come into the network:</p><p class="s8" style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">Device 1&gt; plugin network-creator-security open-network</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-left: 42pt;text-indent: -18pt;text-align: left;">Connect the second device to the created network using the network steering plugins start command:</p></li></ol><p class="s8" style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">Device 2&gt; plugin network-steering start 0</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark56">Example 2: Creating a network using Zigbee HA Security</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">You can take two devices and start a network using the CLI.</p><ol id="l32"><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">Connect to the coordinator of the network using the Simplicity Studio console or a simple telnet program. If the device exposes its CLI on port 1, you can connect to it by telnetting to port 4901. Once connected to the device, use the network form command to form the network.</p><p class="s8" style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">Device 1&gt; network form 11 2 0x00aa</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-left: 42pt;text-indent: -18pt;text-align: left;">Use the network pjoin command to permit joining, so that new devices can come into the network:</p><p class="s8" style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">Device 1&gt; network pjoin 0xff</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-left: 42pt;text-indent: -18pt;text-align: left;">Connect the second device to the created network using the network join command:</p></li></ol><p class="s8" style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">Device 2&gt; network join 11 2 0x00aa</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark57">Example 3: Sending an attribute read</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Once a network has been formed, you can send messages within the network using the CLI. For example, read the basic cluster’s ZCL version using the global read command.</p><ol id="l33"><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Create the command by populating the Zigbee application framework’s messaging buffer.</p><p class="s8" style="padding-top: 7pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">Device 2&gt; zcl global read 0 0</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 38pt;text-indent: 0pt;text-align: left;">This command writes the global read for cluster id 0, attribute id 0 into the messaging buffer.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Send the global read command to the device using the send command. The send command takes three arguments: the two-byte node ID to which the message should be sent, the sending endpoint, and the destination endpoint.</p></li></ol><p class="s8" style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">Device 2&gt; send 0x0000 1 1</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 38pt;text-indent: 0pt;text-align: left;">This command sends the global read command from Device 2 to Device 1, which is the coordinator of the network and thus has the short node id 0x0000.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark58">Example 4: Sending a cluster command</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Many of the core clusters to the ZCL have CLI commands built into the Zigbee application framework. For instance, the identify command allows you to create a ZCL identify command using the ZCL identify CLI command, and send it using the send command.</p><p class="s8" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Device 2&gt; zcl identify id 30</p><p class="s8" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Device 2&gt; send 0 1 1</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;line-height: 107%;text-align: justify;">This ZCL command uses the Identify cluster. The identify command specifies identify time and abbreviated ID, and it sends a value of 30 seconds, which also goes to the coordinator.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">When you enter this command, it is loaded into a message buffer. When the command is built, the command line interface displays the contents of the message buffer for verification. If you make a mistake in the command, you have the opportunity to re-enter the command before sending it.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">In order to send the ZCL command over the air, use a separate send command provided by the CLI.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The <span class="s8">send </span>command has several additional options and endpoints that you can specify. If it is broadcast, you can send commands in groups.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Whenever you send a message, the node through which the message is sent reports which cluster is being transmitted. Likewise, when- ever you receive a message, it gives a printout of what it receives.</p><p class="s4" style="padding-bottom: 2pt;text-indent: 0pt;text-align: right;">The Debug Printing Interface</p><p style="padding-left: 22pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="724" height="1" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_019.png"/></span></p></li></ol></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;"><a name="bookmark59">The Debug Printing Interface</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework includes a granular debug printing interface. Debug printing, as well as some generic debug printing options like application, core, and custom debug printing, may be controlled on a per-cluster basis. Debug printing for each area can be turned on and off in the AppBuilder interface and is controlled by #define values in the application header.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;line-height: 107%;text-align: left;">Each debug printing option corresponds to a set of macros used for that specific area of debug printing. For instance, if the “Core” debug printing is turned on, the following macros are populated.</p><p class="s5" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 185%;text-align: left;">emberAfCorePrint(…) <span class="p">- prints a single line without a carriage return </span><span class="s10">Example: emberAfCorePrint(“node id: %2x”, nodeId); </span>emberAfCorePrintln(…) <span class="p">- prints a single line with a carriage return </span><span class="s10">Example: emberAfCorePrintln(“node id: %2x”, nodeId); </span>emberAfCoreFlush() <span class="p">- flushes the serial buffer</span></p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 10pt;text-align: left;">This function should be used if a lot of printing is taking place.</p><p class="s10" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Example: emberAfCoreFlush();</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">emberAfCoreDebugExec( x ) <span class="p">- includes x in the code</span></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 185%;text-align: left;">This can be used to wrap code segments like function calls that should only execute when core debug is turned on. <span class="s10">Example: emberAfCoreDebugExec(emAfPrintStatus(&quot;Success&quot;, &quot;Set Failed&quot;, ezspStatus)); </span><b>emberAfCorePrintBuffer( buffer, len, withspace ) </b>– prints a given buffer as a series of hex values</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 184%;text-align: left;">This is a useful print function for printing out the contents of a given buffer. <span class="s10">Example: emberAfCorePrintBuffer(buffer, 0xff, TRUE); </span><b>emberAfCorePrintString( buffer ) </b>– prints a given buffer as a string of characters This is a useful print function for printing out the contents of a given buffer.</p><p class="s10" style="padding-left: 23pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Example: emberAfCorePrintString(buffer);</p></li><li><h3 style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;"><a name="bookmark60">Multi-Network Support</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">The EmberZNet stack supports multiple network configurations (see document <i>AN724: Designing for Multiple Networks on a Single Zigbee Chip</i>, for detailed information on this functionality). The Zigbee application framework builds on this feature and provides additional network management functionality to help customers easily build and deploy multi-network devices. The framework automatically switches between the networks when sending and receiving messages, before calling callbacks, and before triggering event handlers for certain types of events. These features reduce the burden of network switching for customers.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 60pt;text-indent: -36pt;text-align: left;">Note: <span class="p">For EmberZNet PRO 4.7, multi-network support is limited to two networks. More than two networks will be supported in the future.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l34"><li><p class="s5" style="padding-top: 8pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark61">Network Contexts</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The stack has separate network contexts for APIs and for stack handlers. The &quot;current network,&quot; which applies to all stack API calls, is exclusively managed by the application. The &quot;callback network,&quot; which applies to all stack handlers, is exclusively managed by the stack.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The application manages the current network through the use of emberGetCurrentNetwork and emberSetCurrentNetwork. When the application calls any stack API, the stack acts in the context of the current network. For example, calling <span class="s8">emberSetCurrentNet- work(0) </span>followed by <span class="s8">emberGetNodeId() </span>returns the node id of network 0. Once set, the current network remains constant until changed by the application through a subsequent call to <span class="s8">emberSetCurrentNetwork</span>. The current network is never changed by the stack.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Each invocation of a stack handler applies to a particular network. Before calling any stack handler, the stack sets the callback network to the appropriate network. For example, when a message arrives on network 0, the stack sets the callback network before calling <span class="s8">emberIncomingMessageHandler</span>. The application can query the callback network through the use of <span class="s8">emberGetCallback- Network</span>. In this example, in emberIncomingMessageHandler, <span class="s8">emberGetCallbackNetwork() </span>returns 0. The callback network only applies within the context of a stack handler. The application cannot change the callback network.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">At any given time in the lifecycle of the application, the current network and the callback network may be different. The stack leaves management of the network contexts entirely to the application. To reduce the complexities of multi-network devices, Zigbee application framework manages the network contexts on behalf of the application.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l35"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark62">The Callback Network</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In each stack handler it implements, the framework sets the current network to the callback network before performing any of its own processing and before invoking any of its own callbacks. More specifically, at the beginning of each handler, the framework performs an operation equivalent to <span class="s8">emberSetCurrentNetwork(emberGetCallbackNetwork())</span>. In this way, any code called as a result of a stack handler always acts in the context of the handler itself. For example, if the device receives a GetCurrentPrice message on network 0, the stack calls <span class="s8">emberIncomingMessageHandler </span>with the callback network set to 0 and the framework immediately sets the current network to network 0. As a result, when the framework parses the message and ultimately calls <span class="s8">emberAfPriceClus- terGetCurrentPriceCallback </span>to pass it to the application, the network context is set up to match that of the incoming message. This eliminates the need for the application to check and set the current network itself whenever a message is received.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark63">The Current Network</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Because endpoints are central to many of operations performed by a Zigbee device, each endpoint in the application is assigned to a network. Multiple endpoints can be assigned to the same network, but each endpoint belongs to exactly one network. The network assignments are set during configuration in AppBuilder and are not changeable at runtime. When preforming a task on an endpoint, the framework automatically sets the current network to the network of the endpoint.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">When sending a message using any of the emberAfSend APIs, the framework, before submitting the message to the stack, automatically switches to the network of the source endpoint. This enables applications to construct and send messages without the need to check and set the current network. The application cannot override the network on which the message will be sent. Multi-network applications must correctly set the source endpoint for all outgoing messages. Failure to set the proper endpoint results in errors or unexpected behavior.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">As messages are received, the framework first verifies that the destination endpoint belongs to the network from which the message arrived. If there is a mismatch, the message is dropped with no ZCL-level response. This ensures proper segregation between the various networks. Otherwise, as mentioned previously, the framework switches to the incoming network so that all subsequent actions are carried out in the context of the appropriate network.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The framework also sets the current network before cluster, endpoint, or network events are triggered. Cluster events are available to the application and can be used to perform operations that are specific to a particular cluster and endpoint. Endpoint and network events are used in plugins and are intended to be used when the plugin does not implement a ZCL cluster or when it provides some auxiliary function to another cluster plugin. For example, if endpoint 1 is assigned to network 0 and the endpoint implements the Price cluster server, the framework sets the current network to 0 before calling <span class="s8">emberAfPriceClusterServerTickCallback </span>for endpoint 1. By switch- ing networks before triggering these event handlers, applications and plugins are able to immediately begin their processing without the need to check or set the network.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark64">Switching Networks</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The framework maintains active networks in a last in, first out (LIFO) data structure. When it switches networks, the framework actually &quot;pushes&quot; the new network into the LIFO list by calling <span class="s8">emberAfPushCallbackNetworkIndex</span>, <span class="s8">emberAfPushEndpointNet- workIndex</span>, or <span class="s8">emberAfPushNetworkInde</span>x. For example, at the beginning of its implementation of <span class="s8">emberIncomingMes- sageHandler</span>, the framework calls <span class="s8">emberAfPushCallbackNetworkIndex </span>to switch the current network to the callback net- work. Similarly, when sending a message, the framework calls <span class="s8">emberAfPushEndpointNetworkIndex </span>with the source endpoint of the message. After completing its processing, the framework &quot;pops&quot; the most recent network from the LIFO list and switches back to the previous network. This is accomplished by calling <span class="s8">emberAfPopNetworkIndex</span>. For example, at the end of both <span class="s8">emberIncom- ingMessageHandler </span>and <span class="s8">emberAfSendUnicast</span>, the framework calls <span class="s8">emberAfPopNetworkIndex </span>to switch to whichever network was set previously.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">If the framework has to switch network for any reason, it always restores the previous network when it has finished its processing. In this way, the application is assured that the current network remains constant before and after a call to a framework API. The framework relies on the same guarantee, which means that the application and all plugins must exclusively use the <span class="s8">emberAfPush </span>APIs in conjunction with <span class="s8">emberAfPopNetworkIndex </span>when switching networks. Using <span class="s8">emberSetCurrentNetwork </span>directly will bypass the LIFO list and result in errors. Additionally, every successful push must be matched with a corresponding pop. Failure to follow this paradigm will result in errors.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark65">Configuration</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">AppBuilder is used to enable and configure multi-network functionality in framework applications. The steps to configure a multi-network application, which are described in detail below, are as follows:</p><ul id="l36"><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Create one or more networks</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Assign endpoints to networks</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Set the default network</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Configure the Zigbee device type for each network</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">Configure the security profile for each network</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Endpoints are assigned to networks on the &quot;ZCL Clusters&quot; tab in AppBuilder. By default, all endpoints are assigned to a network named “Primary.” To create a new network and assign an endpoint to it, click on the “Add” button in the multi-network configuration area of the Zigbee Stack Tab. A dialog box appears in which a new network can be created by clicking on “Create new network” and providing a unique name in the accompanying text field. To assign an endpoint to an existing network, select “Use network” in the same dialog box and choose the network name from the list of networks. After clicking “OK,” the list of endpoints will reflect the new network assignment.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For ease of use, AppBuilder generates friendly identifiers for each network based on the user-defined name. These identifiers can be used in place of literals in the code. For example, for a network named &quot;SleepyEndDevice,&quot; the application could call emberAfPushEnd- pointNetworkIndex(EMBER_AF_NETWORK_INDEX_SLEEPY_END_DEVICE) to switch to that network.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">An unlimited number of networks can be created using the &quot;ZCL Clusters&quot;, but endpoints may only be assigned to at most two networks. Having more than two active endpoints in an application is an error and AppBuilder will not generate a configuration for such an applica- tion. In addition, as discussed previously, each endpoint belongs to one network and each network can contain multiple endpoints. The endpoint numbers must be unique across the entire device. For example, networks 0 and 1 cannot both contain an endpoint with number identifier 1.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Once a network is created, it can be configured on the &quot;Zigbee Stack&quot; tab in AppBuilder. The Zigbee PRO network configuration widget lists each network and shows whether it is active or inactive. Active networks are shown in black text and are those networks to which endpoints have been assigned. Inactive networks are shown in grey italics and are those networks to which no endpoints have been assigned. Inactive networks also have “(unused)” appended to their name. AppBuilder saves inactive networks in the application config- uration file but it will not generate any code related to such networks. In addition to showing whether a network is active or inactive, the network widget also indicates which network is the default network. The default network is shown in bold and has “(default)” appended to its name. In the framework, the default network is the one used for the initial push. Unless another push occurs, the default network</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">applies to all stack API calls. In addition to an identifier for its friendly name, as previously described, AppBuilder generates EMBER_AF_DEFAULT_NETWORK_INDEX with the index of the default network. To change the default network, select an active net- work and click on the “Make Default” button.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;"><a name="bookmark66">The Zigbee device type and security profile can be configured for each network. To change the Zigbee device type, click in the “Zigbee Device Type” column of the network row, drop down the list and select a device type. To configure the security profile, click in the “Security Type” column of the network row, drop down the list and select a device type. There are limitations to how the Zigbee device type and security profile can be configured for multiple networks, as described below.</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l37"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;">Zigbee Device Types</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In multi-network devices, one network must be configured as a sleepy end device. The other networks may be configured as a coordinator, router, end device, or sleepy end device. This restriction is enforced during configuration in AppBuilder and cannot be changed at runtime. The device type for each network is configured on the &quot;Zigbee Stack&quot; tab in AppBuilder.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The End Device Support plugin supports polling, sleeping, and rejoining for single-network end devices and all multi-network devices. The plugin will short or long poll as appropriate, sleep when possible, and rejoin whenever it finds itself operating without a network.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For single-network devices, the plugin will short-poll when it is expecting data and long-poll otherwise. For multi-network devices, the plugin will short- or long-poll on a per-network basis. For example, if data is expected on network 0 but not on network 1, the plugin will short-poll on network 0 while long-polling on network 1. The plugin allows different polling intervals for each network. For example, network 0 may short-poll every second while network 1 short-polls every other second. The intervals are configurable at runtime through the <span class="s8">emberAfSetShortPollIntervalQsCallback </span>and <span class="s8">emberAfSetLongPollIntervalQsCallback </span>APIs. As with all APIs that affect individual networks, the application should push the appropriate network before calling either API, and afterward pop to restore the previous network.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">With regard to sleeping behavior, the plugin will stay awake, idle, or sleep as appropriate. For multi-network devices, the plugin will only sleep if all networks are sleepy. For example, a device configured as a router on one network and a sleepy end device on the other will not sleep because the router is expected to remain awake. For devices configured as sleepies on all networks, the plugin will sleep when all networks are able to do so. The most restrictive per-network sleep policy determines the per-device sleep policy.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The plugin will attempt to rejoin the network after a series of failed data polls. For multi-network devices, the process is similar, with rejoining being performed on a per-network basis as determined by per-network data polls.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Without the End Device Support plugin or equivalent functionality provided by the application directly, the application will not poll, sleep, or rejoin at all. Because of the complexity of managing polling, sleeping, and rejoining, all customers building single-network end devices and all customers building any multi-network device are strongly encouraged to use the plugin.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark67">Security Configuration</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">While AppBuilder and the Zigbee application framework continue to support the &quot;None&quot; and &quot;Custom&quot; security profiles, only the &quot;Smart Energy&quot; (SE), “Zigbee 3.0” and &quot;Home Automation&quot; (HA) profiles are supported with multiple networks. Each network can have a different security profile, but only the combinations SE/SE, SE/Z3.0 and SE/HA are supported in this release. This restriction is enforced during configuration in AppBuilder and cannot be changed at runtime. The security profile for each network is configured on the &quot;Zigbee Stack&quot; tab in AppBuilder.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Security is primarily handled by the framework, although the application does have control over the initial security settings used when forming and joining devices. Using the new emberAfSecurityInitCallback, the application can override the initial security bitmask and the extended security bitmask on a per-network basis.</p></li></ol></li></ul></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;"><a name="bookmark68">Sleepy Devices</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l38"><li><p class="s5" style="padding-top: 10pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark69">Introduction</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework contains support for sleepy end devices. A sleepy end device is a device on the Zigbee network that spends most of its life powered down and only powers up the processor when it needs to do something specific like interpret a GPIO interrupt or poll its parent to see if there are any messages waiting for it on the network.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark70">Polling</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Sleepy end devices do not receive data directly from other devices on the network. Instead they must poll their parent for data and receive the data from their parent. The parent acts as a surrogate for the sleepy device, staying awake and buffering messages while the child sleeps. As a result, the sleep/wake cycle of the sleepy end device is governed by two important timeouts on the Zigbee network: the APS retry timeout (7.8 seconds) and the End Device Poll timeout (defined by the parent defaults to 5 minutes). These two timeouts correspond to two polling intervals on the sleepy end device: the SHORT_POLL and the LONG_POLL intervals. These intervals are sometimes referred to as the “nap duration” and “hibernation duration” respectively. So when a device is in a state where it is continually sending polls out on the SHORT_POLL interval it is considered to be “napping,” due to the fact that it is continually waking up after a very short period to poll. When a device is sending out polls on the LONG_POLL interval it is said to be “hibernating,” due to the fact that it is sleeping for a longer interval.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">When a device needs to be responsive to messages being sent to it from the network, it goes into a state where it polls its parent on the SHORT_POLL interval (napping). This ensures that any messages received by its parent will immediately be retrieved by the sleepy end device and processed. When the device no longer needs to be as responsive on the network it returns to a state where it polls its parent on the LONG_POLL interval (hibernating) which ensures that the child will remain alive in its parent’s child table but will not be responsive to the network.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The time during which the sleepy end device is polling at an augmented rate based on the SHORT_POLL interval is referred to as the “Short Poll Mode,” “Fast Poll Mode,” or simply “Napping.” All of these terms mean the same thing. The sleepy device is polling its parent faster than the 7.68 seconds allowed for an end devices parent to hold onto a message for the end device. Generally, the SHORT_POLL interval will be something less than 1 second to ensure that all messages sent to the parent are pulled off in an orderly fashion, since the parent is only required to hold onto a single message. If the messages are not retrieved from the parent quickly enough they may be overwritten by other incoming messages for the same child or some other child. For more information on Fast Polling see the section</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 10pt;text-align: justify;"><a href="#bookmark86" class="a">14.2.4 Forcing “Fast Polling”</a><a href="#bookmark86" class="s7">.</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l39"><ol id="l40"><ol id="l41"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: justify;"><a name="bookmark71">The SHORT_POLL Interval</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The short poll interval is the amount of time that an end device may wait before polling its parent when it is in the process of sending or receiving a message. This interval must be shorter than the Indirect Transmission Timeout (standardized at 7.68 seconds for Zigbee PRO networks). This is because the end device must send an APS ACK back to the sending device before the sending device decides to resend the message. The end result is that, in order for sleepy end devices to reliably communicate with other devices on the network, they must know when they are in the process of sending or receiving a message and must wake and poll their parent for data within the short poll interval until the message transaction is complete.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l42"><li><p class="s6" style="padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark72">Setting at Compile Time</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The short poll interval is defined in quarter seconds in the framework by EMBER_AF_SHORT_POLL_INTERVAL. The AppBuilder inter- face has no GUI widget to allow users to manipulate this value. It defaults to one unit which is equal to one quarter-second. If you wish to change the default EMBER_AF_SHORT_POLL_INTERVAL you may add a definition for it in the macros section of the “Includes” tab in the application configuration.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s6" style="padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark73">Setting at Runtime</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Within the application framework, the EMBER_AF_SHORT_POLL_INTERVAL is assigned to a global variable called <span class="s8">emberAfNapDu- ration</span>, which can be modified at runtime using the EMBER_AF_SET_NAP_DURATION (int32u duration) macro.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: justify;"><a name="bookmark74">The LONG_POLL Interval</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The long poll interval is the amount of time that an end device may wait before polling its parent when it is otherwise inactive. This interval should, but is not required to, be shorter than the “End Device Poll Timeout,” which is the amount of time a parent device will wait to hear</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">from its child before removing it from its child tables. The default end device poll timeout for Zigbee devices is 320 seconds or just over 5 minutes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 60pt;text-indent: -36pt;text-align: justify;">Note: <span class="p">The Zigbee protocol does not offer a standard way to timeout entries in a child table. In place of this, several heuristic mecha- nisms exist for aging entries in a child table. For instance, if a parent hears a device that it thinks is its child interacting with another parent or being represented by another parent, it may remove the entry from its child table. Silicon Labs has developed a more deterministic mechanism for child aging called the “End Device Poll Timeout.” A parent expects that children will “check in” with their parents within the end device poll timeout. If they do not, it assumes that they have gone away and removes them from its child tables. The End Device Poll Timeout is defined in stack/include/ember-configuration-defaults.h</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">The end device does not get to configure the end device poll timeout on its parent and there is no agreed upon protocol for communicating the End Device Poll Timeout value between parent and child. In place of this, Silicon Labs has configured an assumed end device poll timeout on both parent and child. This value is defined in stack/include/ember-configuration-defaults.h.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Depending on its sleep characteristics, battery life considerations, the child may wish to sleep past the assumed end device poll timeout. It is free to do this. However, if it does, it must repair the network connection with its parent before interacting with the network again. Generally, a device that is likely to do this should check the state of the network when it wakes up to see if any repair is necessary before sending data. A sleepy device should never wake and assume that its parent is still there, unless it knows for certain that its parent is configured with a mutually agreed upon End Device Poll Timeout that it is obeying. For more information on the end device poll timeout see the configuration header file located at stack/include/ember-configuration-defaults.h.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l43"><li><p class="s6" style="padding-left: 60pt;text-indent: -36pt;text-align: left;"><a name="bookmark75">Setting at Compile Time</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 106%;text-align: justify;">The long poll interval is defined in quarter seconds in the framework by EMBER_AF_LONG_POLL_INTERVAL. The long poll interval can be manipulated within the stack configuration tab. EMBER_AF_LONG_POLL_INTERVAL can also be defined in the “Includes” section of the stack tab.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s6" style="padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark76">Setting at Runtime</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Within the application framework, the EMBER_AF_LONG_POLL_INTERVAL is assigned to a global variable called <span class="s8">emberAfHiber- nateDuration</span>, which can be modified at runtime using the EMBER_AF_SET_HIBERNATE_DURATION(int32u duration) macro.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark77">What Values Should I Set for the Short and Long Poll Intervals?</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Short Poll Interval should be less than the Indirect Transmission Timeout of the parent to prevent lost data/ACKs (&lt; 7.8 s). The Long Poll Interval should be less than the End Device Poll Timeout of the parent (assuming the parent implements an End Device Poll Timeout) to prevent the parent from aging out the end device due to inactivity. By default the Zigbee stack ships with a 5-minute End Device Poll Timeout. The manufacturer can change the End Device Poll Timeout as they wish. There is no standard way for routers to report their chosen End Device Poll Timeout to their children and it is not required for routers to implement child aging in the Zigbee specification. As a result, if a device implements a LONG_POLL_INTERVAL that is slower than 5 minutes, Silicon Labs recommends that the device check its network status before spontaneously sending messages through its parent. You want the device to make sure that the connection to the parent is up before it sends a message. If the network is not up, the device should perform a network rejoin to make sure that it has a parent before sending any message out over the air.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark78">Forcing “Fast Polling”</a><a name="bookmark86">&zwnj;</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Fast Polling is the state during which the stack actively polls its parent device faster than the 7.68 second child message timeout interval. The Zigbee application framework polls at the rate defined by the SHORT_POLL interval when it is in this mode. The Zigbee application framework automatically keeps the stack in the fast poll mode during the sending and ACKing of an APS message. When a device sends a message that is part of a series of application-level request/responses, as is the case in Smart Energy Registration, it must keep the device in fast poll mode until the entire transaction is completed.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework can ensure that the application stays in short poll mode for as long as the application requires by setting a flag in the <span class="s8">emberAfCurrentAppTasks </span>mask. In order to do this, create your own flag for the <span class="s8">emberAfCur- rentAppTasks </span>that fits in with what is available according to the named masks in app/framework/include/af.h. The top 16 bits of the <span class="s8">emberAfCurrentAppTasks </span>mask are reserved for customer use. Once you have chosen a flag for your application, you may use the <span class="s8">emberAfAddToCurrentAppTasks </span>and <span class="s8">emberAfRemoveFromCurrentAppTasks </span>functions to add and remove your flag. If the flag is present in the <span class="s8">emberAfCurrentAppTasks </span>global bitmask, the application does not allow the stack to back into hiberna- tion mode and the stack stays in short poll mode, during which it uses the SHORT_POLL interval to determine how quickly to poll the parent. The usage of this API is also documented in app/framework/include/af.h.</p></li><li><p class="s5" style="padding-top: 7pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark79">Using “Fast Polling” to Complete a Complex Transaction</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Sometimes a sleepy device needs to stay in fast poll mode while sending a complex series of messages that constitute a complete application level transaction with another device. The general strategy for this type of interaction on a sleepy end device is as follows:</p><ol id="l44"><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Sleepy end device A needs to perform a series of messages with device B, called a transaction.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Sleepy end device A creates an event that will serve as a timeout for the application level transaction, called the transaction timeout event.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Sleepy end device A starts the event and sends the first message to device B.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">If the message is an APS message, sleepy end device A will automatically stay in short poll mode until the APS Ack comes back from the responding device.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">If the message is a ZCL command, sleepy end device A will also automatically stay in short poll mode long enough to give device B a chance to send any application level command response required by the ZCL</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Sleepy end device A continues with its series of messages back and forth to device B until the whole transaction is complete.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">When the final message of the transaction is completed with device B, Sleepy end device A removes the flag from emberAfCur- rentAppTasks thereby allowing the device to naturally go back to using the hibernate or LONG_POLL period for sleeping.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">If device A and B are not able to complete their transaction as expected, Sleepy End Device A removes the flag from emberAfCur- rentAppTasks when the transaction timeout event set up in step #1 fires.</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark80">Difference in Polling on SoC and Host+NCP Models</a></p></li></ol></ol></ol><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The requirements of polling result in different sleep patterns for the System-On-Chip (SoC) and the Host + Network Co-Processor (NCP) models. In the Host + NCP model, it is the NCP that is responsible for polling at the SHORT_POLL and LONG_POLL intervals. The only responsibility of the host processor is to tell the NCP how frequently to poll. Other than that, the host may sleep indefinitely or until there is some internal event, a GPIO interrupt, or the NCP receives a message that it passes to the host for processing. Conversely, the SoC itself is responsible for polling its parent, so it must be sure to wake within the SHORT_POLL and LONG_POLL intervals in order to do so. The Zigbee application framework uses the internal event mechanism on the SoC to schedule polling. On the host, it sends a message down to the NCP to tell it when to poll.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark81">Sleeping and the Event Mechanism</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework automatically checks with the event mechanism to see when the next application event is scheduled. The Zigbee application framework never sleeps through an event. The sleep period is always shorter than the amount of time to the next application event within the framework. On the SoC the amount of time that a device will sleep is generally governed by the SHORT_POLL and LONG_POLL intervals, since the polling event is also an event within the Zigbee application framework. On the host, the processor will attempt to sleep until the next application event.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l45"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark82">Never Use Ticks On a Sleepy End Device</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">All application events should be scheduled through the event mechanism using either custom or cluster events on a sleepy end device. This is because the event mechanism provides a central repository for the sleep handling code so that it knows how long it can sleep. If you rely on the <span class="s8">emberAfMainTickCallback </span>to fire frequently enough to handle application events on your sleepy, you will be forced to wake the sleepy on an artificially short interval so that the <span class="s8">emberAfMainTickCallback </span>can be serviced.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark83">End Device Parent Rediscovery</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">If an end device loses contact with its parent it will automatically begin to rejoin the network either with the existing parent or a new parent by calling <span class="s8">emberAfStartMove</span>. The <span class="s8">emberAfStartMove </span>function schedules a “move” event in the Zigbee application framework’s event scheduling mechanism with the following characteristics:</p><ul id="l46"><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: justify;">When the move event fires, the device calls <span class="s8">emberFindAndRejoinNetwork</span>.</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: justify;">The move event is automatically rescheduled so that a network rejoin will be attempted every 10 seconds until EMBER_AF_REJOIN_ATTEMPTS_MAX is reached.</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">If EMBER_AF_REJOIN_ATTEMPTS_MAX is set to 0xff (default) the rejoin will be attempted every 10 seconds until a network is found.</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: justify;">The first attempt to rejoin the network is always performed with security on. Each subsequent attempt is performed with security off.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">This orphan behavior can obviously have an impact on the life of a battery-powered device. If you would like to limit the number of rejoin attempts a device performs before it gives up you can set EMBER_AF_REJOIN_ATTEMPTS_MAX to something other than 0xff by adding an entry in the Additional Macros section of the “Includes” tab within your AppBuilder configuration.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark84">Sleepys and the CLI</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">It is very difficult to interact with a sleepy end device on the Command Line Interface (CLI) when it is sleeping. If you would like your sleepy end device to stay awake when it is not connected to a network you can do so by: Enabling the &quot;Stay awake when NOT joined&quot; option in the Idle/Sleep Utility in the “Plugins” tab within AppBuilder.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The other alternative is to provide a button handler that toggles the device between a default wake and sleep state. A sample implemen- tation is built into the plugin but users can also implement it themselves.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark85">Processor Idling and the Application Framework</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework implements processor idling for sleepy devices. This feature augments power savings for sleepy de- vices by idling the processor during times that there are no events happening. This means that a sleepy device will not continually run through the application’s main loop when it is awake. Instead the processor will idle until it receives an interrupt either from an external line or a scheduled event. Once each event has been handled, it is marked as ready to idle. The processor will then wait until the next internal or external interrupt before running through the application’s main loop again.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Some typical examples of when a sleepy device can save energy by idling include:</p><ul id="l47"><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">While a packet, such as a data poll, is being transmitted from a sleepy device, the CPU is usually just waiting for the transmission to finish and can idle.</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">While waiting for the crystal to stabilize, the CPU eventually runs out of initialization and calibration operations to do, so it can idle.</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: left;">While waiting for the ACK to a transmitted packet. The radio still needs to be on in receive mode, so the processor can&#39;t deep sleep, but can safely idle.</p></li></ul></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 45pt;text-indent: -21pt;text-align: left;"><a name="bookmark87">Application Framework Plugins</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l48"><li><p class="s5" style="padding-top: 10pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark88">Introduction</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Zigbee application framework contains support for plugins. A plugin is an implementation of a piece of functionality within the frame- work through the framework’s callback interface. The Zigbee application framework ships with default implementations of many of the clusters, such as key establishment and price. This section documents a small subset of these plugins..</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark89">Creating Your Own Plugins</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Plugins are encapsulated implementations of the callback interface. If a specific plugin does not satisfy your needs you have two options.</p><ol id="l49"><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;">Implement the associated callbacks directly in your application:</p><ol id="l50"><li><p style="padding-top: 3pt;padding-left: 52pt;text-indent: -14pt;text-align: justify;">Disable the plugin and implement the callbacks you need for your application.</p></li><li><p style="padding-top: 3pt;padding-left: 52pt;text-indent: -14pt;text-align: justify;">This will add the callbacks into your application_callbacks.c file.</p></li></ol></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;">Create your own plugin from the original:</p><ol id="l51"><li><p style="padding-top: 3pt;padding-left: 51pt;text-indent: -13pt;text-align: justify;">Go to the plugin directory within the stack install located at app/framework/plugin.</p></li><li><p style="padding-top: 3pt;padding-left: 52pt;text-indent: -14pt;text-align: justify;">Copy the plugin contents into a new directory inside app/framework/plugin.</p></li><li><p style="padding-top: 3pt;padding-left: 52pt;text-indent: -14pt;text-align: justify;">Each plugin includes a configuration file called plugin.properties. This file is used by AppBuilder to display the plugin within the configuration pane and manage dependencies within the framework. At the very least, you must change the name of the plugin in the plugin.properties file so that you can recognize it in AppBuilder.</p></li><li><p style="padding-top: 3pt;padding-left: 52pt;text-indent: -14pt;text-align: justify;">Once you do this, you must restart AppBuilder so that your new plugin is picked up when AppBuilder scans the stack install directory.</p></li></ol></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: justify;"><a name="bookmark90">Over the Air Upgrade (OTA) Plugins</a></p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The Over-the-air Bootload cluster is a large piece of functionality in the Smart Energy 1.1 specification. It involves a number of modules in order to support software implementations on different platforms and for both the client and server.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">This section details each of the different pieces and describes their function in the Zigbee application framework.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l52"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: justify;"><a name="bookmark91">Architecture</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">This section explains the architecture of the cluster and where developer code fits into the Zigbee application framework.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The Zigbee Over-the-air Bootload (OTA) cluster provides a common way for all devices to have a manufacturer-independent method to upgrade devices in the field. The Zigbee OTA cluster only supports application bootloaders where a device has the capability to download and store the entire image in external storage while still running in the Zigbee network.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 107%;text-align: justify;">The Zigbee OTA cluster defines the protocol by which client devices query for new upgrade images and download the data, and how the server devices manage the downloads and determine when devices shall upgrade after downloading images.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Silicon Labs provides all the cluster code for both client and server to correctly process and respond to all Zigbee OTA messages. In addition, it provides code for managing the stored image(s) and bootloading the target chip.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">A number of decisions have to be made about the architecture of the upgrade and how it will be handled. Below are several key questions to answer.</p><ol id="l53"><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">What external storage device will be used for the OTA upgrade image?</p><ol id="l54"><li><p style="padding-top: 3pt;padding-left: 51pt;text-indent: -13pt;text-align: left;">Silicon Labs provides a few EEPROM driver implementations as well as a POSIX file system (for UART host only).</p></li><li><p style="padding-top: 3pt;padding-left: 52pt;text-indent: -14pt;text-align: left;">If a different driver or method is desired, then this code must be provided.</p></li></ol></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">Does a client device require multiple upgrade files in order to bootload?</p><ol id="l55"><li><p style="padding-top: 3pt;padding-left: 55pt;text-indent: -18pt;text-align: left;">If so, the multiple upgrade files can be co-located within the same Zigbee OTA file transferred over-the-air. However, this requires a storage device that can hold all the upgrade files at the same time.</p></li><li><p style="padding-top: 3pt;padding-left: 52pt;text-indent: -14pt;text-align: left;">The Zigbee OTA cluster also supports requesting multiple files, but the client must manage this.</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">How will upgrade files be labeled?</p><p style="padding-top: 7pt;padding-left: 38pt;text-indent: 0pt;text-align: justify;">Each OTA file has a manufacturer ID, an image type ID, and a version number. The value for the manufacturer ID is assigned by Zigbee, but the manufacturer controls the other two values, which can be set to whatever values they want. The choice of what values to use depends on the versioning scheme used by the developer, and how products from the same manufacturer are differentiated.</p></li><li><p style="padding-top: 2pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">Will image signing and verification be used by client devices?</p><ol id="l56"><li><p style="padding-top: 3pt;padding-left: 55pt;text-indent: -18pt;text-align: justify;">Although the choice to support the Zigbee OTA cluster is optional for Smart Energy devices, if devices do support the cluster, then manufacturers must digitally sign upgrade images, and their devices must verify the authenticity and integrity of those im- ages.</p></li><li><p style="padding-top: 2pt;padding-left: 52pt;text-indent: -14pt;text-align: justify;">Manufacturers that use image signing must obtain signing certificates, and embed the EUI64s of allowed signers within the soft- ware so downloaded images can be validated.</p></li></ol></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">How will bootloading be handled by clients?</p><p style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;text-align: justify;">Bootloading is device specific, though Silicon Labs provides sample code to bootload both its SOC and NCP chips. But it is likely the developer will have to provide additional specific code to support their own device.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">How will the server receive the images to be given out to clients?</p></li></ol></li></ol><p style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;text-align: justify;">The Zigbee implementation provides a POSIX server that can serve up OTA files that reside on a file system. If the server is an EEPROM-based system, then some other mechanism must be created to transfer the images to the server, so that those can be served up to Zigbee OTA clients.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l57"><li><p class="s6" style="padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark92">Generating Zigbee OTA Images</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Silicon Labs provides a tool called image-builder that can generate correctly formatted Zigbee OTA images. This tool takes in bootloader files (such as an EBL file) and generates the correct format according to the command-line input, as illustrated in the following figure. The tool can also sign the images using the ECDSA signature algorithm as dictated by the Zigbee OTA cluster specification.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For more information on using this tool please consult document <i>AN716: Instructions for Using Image Builder</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 126pt;text-indent: 0pt;text-align: left;"><span><img width="449" height="258" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_020.gif"/></span></p><p class="s5" style="padding-top: 8pt;padding-left: 28pt;text-indent: 0pt;text-align: center;">Figure 15-1. OTA Image Generation</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s6" style="padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark93">Image Signing</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 106%;text-align: justify;">The Zigbee Smart Energy Profile requires that OTA files be signed by the manufacturer. Downloaded files must be validated by the OTA client prior to installation. When images are signed the signer’s certificate is included automatically as a tag in the file, and a signature tag is added as the last tag in the file.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 107%;text-align: justify;">The EUI of the authorized signing certificates must be embedded in the client’s current software image so it can validate that only the certificates pertaining to the manufacturer of the device can sign update images.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For development and or test deployments that want to use signing and OTA images a test certificate can be used from the Certicom Test CA to sign images. The image-builder tool has a test certificate embedded in it for this purpose and by default AppBuilder includes the EUI of that test certificate as an authorized signer.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-top: 4pt;padding-left: 60pt;text-indent: -36pt;text-align: left;">Note: <span class="p">For generation of production images to be shipped to deployed devices, it is highly recommended that manufacturers use their own certificates issued from the Certicom Production CA to sign images, and specify only these EUIs as authorized signers.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: justify;">The certificates and private keys used for signing are the same type as certificates and private keys used by Smart Energy devices. However, their use and storage should be handled differently. The following are the differences:</p><ol id="l58"><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">Certificates and private keys used for signing should only be used for signing. They should never be put on devices as device-specific certificates and keys. This holds true regardless of whether the device is a test device or a production device.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">The EUI used for the signing certificate should NOT be used for by any other device or for any other purpose. That EUI should NOT be part of a general pool of EUIs used for production devices.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">It is recommended that at least three signing certificates with private keys be generated with three different EUIs. Multiple signing certificates allows for deprecating an expired or compromised private key.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">Devices should be set up to accept all of those EUIs as authorized signers of images. If a single key or certificate is compromised it can be deprecated through a software update, and devices will not accept images signed by that entity. In that case, a new signing certificate should be created to replace the compromised one and subsequent software releases should set it up to be an authorized signer. In the interim one of the other two alternative signing certificates can be used to sign software updates.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">Signer private keys should be stored in a secure location with limited access.</p></li></ol><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Lastly, it should be noted that mixing production device certificates with a test certificate signer (and vice versa) does not work. In other words, if a device has a production certificate from the Certicom Production CA then it can only validate images signed with a production certificate. Similarly, devices with test certificates can only accept signers that have certificates issued from the Certicom Test CA.</p></li></ol></li><li><p class="s5" style="padding-top: 7pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark94">Plugin Architecture</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">A diagram of the architecture of the OTA plugins is shown in the following figure.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 65pt;text-indent: 0pt;text-align: left;"><span><img width="616" height="500" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_021.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 28pt;text-indent: 0pt;text-align: center;">Figure 15-2. OTA Plugin Architecture</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark95">ZCL Framework Core</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">This code is provided by the core Zigbee application framework and performs the basic parsing and verification of incoming and outgoing messages using the Zigbee Cluster Library.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark96">OTA Bootload Cluster Common Code Plugin</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">This plugin provides common code to the OTA client and server cluster plugins. It must be enabled if either the <b>OTA </b>Bootload Cluster Server Plugin or the OTA Bootload Cluster Client Plugin is enabled.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">This plugin has no configurable options.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark97">OTA Bootload Cluster Server Plugin</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The OTA Server cluster performs the message parsing of Over-the-air Bootload cluster client commands sent to the server, and generates server commands sent to the clients. It does not handle storage of the OTA files but instead relies upon an external module for that support. Its role is simply to validate the incoming messages and generate the correct replies based on its own supported functionality and the OTA specification.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Silicon Labs provides a Zigbee application framework plugin that implements the server cluster.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24.25pt" cellspacing="0"><tr style="height:15pt"><td style="width:139pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Options</p></td><td style="width:401pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:35pt"><td style="width:139pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Page Request Support</p></td><td style="width:401pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 6pt;text-indent: 0pt;text-align: justify;">The OTA Server Cluster plugin can support the optional Page Request feature of the Zigbee OTA cluster. If this option is enabled, the server will answer page requests and send multiple blocks of the download image back to the client.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark98">OTA Bootload Cluster Server Policy Plugin</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">This module defines how the OTA server reacts when it receives certain requests from the client. The server cluster code calls into this module to ask how certain operations should be handled. For example, when a client is finished downloading a file it sends an <i>upgrade end request </i>to the server to ask when it can upgrade to the new image. The server cluster code parses the message and then calls into the server policy code to determine the answer.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Other examples of policies handled by this module include how to respond when a query for the <i>next </i>OTA image to download is received, and how to respond when receiving an image block request.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">This plugin has no configurable options.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark99">OTA Bootload Cluster Client Plugin</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The OTA client cluster performs the message parsing of Over-the-air Bootload cluster server commands sent to the client, and generation of client commands sent to the server. It does not handle storage of the OTA files, but instead relies upon an external module for that support. Its role is simply to validate the incoming messages and generate the correct replies based on its own supported functionality.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Silicon Labs provides a Zigbee application framework plugin that implements the client cluster. The plugin has optional support for the signature verification feature. When enabled, this checks the ECDSA signature on received OTA files before generating the upgrade end message sent back to the server.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24.25pt" cellspacing="0"><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Options</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Query OTA Server Delay (minutes)</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">How often the client queries the OTA server for a new upgrade image.</p></td></tr><tr style="height:35pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Download Delay (ms)</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 8pt;text-indent: 0pt;text-align: left;">How often a new block of data (or page) is requested during a download by the client. A value of 0 means the client requests the blocks (or pages) as fast as the server responds.</p></td></tr><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Download Error Threshold</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">How many sequential errors cause a download to be aborted.</p></td></tr><tr style="height:25pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Upgrade Wait Threshold</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 43pt;text-indent: 0pt;text-align: left;">How many sequential, missed responses to an upgrade end request cause a download to be applied anyway.</p></td></tr><tr style="height:35pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Server Discovery Delay (minutes)</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 9pt;text-indent: 0pt;text-align: left;">How often a client looks for an OTA server in the network when it did not successfully discover one. Once a client discovers the server, it remembers that server until it reboots.</p></td></tr><tr style="height:25pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Run Upgrade Delay Request (minutes)</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 24pt;text-indent: 0pt;text-align: left;">How often the client will ask the server to apply a previously downloaded upgrade when the server has previously told the client to wait.</p></td></tr><tr style="height:46pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Use Page Request</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 8pt;text-indent: 0pt;text-align: left;">Selecting this option causes the client device to use an OTA Page Request command to ask for a large block of data all at once, rather than use individual image block requests for each block. If the server does not support this optional feature, then the client falls back to using individual block requests.</p></td></tr><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Page Request Size</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">The size of the page to request from the server.</p></td></tr><tr style="height:25pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Page Request Timeout (seconds)</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">The length of time to wait for all blocks from a page request to come in. After this time has expired, missed packets are requested individually with image block requests.</p></td></tr><tr style="height:46pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Signature Verification Support</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 7pt;text-indent: 0pt;text-align: left;">This requires all received images to be signed with an ECDSA signature and verifies the signature once the download has completed. If an image fails verification it is discarded. This verification occurs prior to any custom verification that might verify the contents.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24.25pt" cellspacing="0"><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Options</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:77pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Verification Delay (ms)</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 15pt;text-indent: 0pt;text-align: left;">This controls how often an ongoing verification process executes. When signature verification is enabled this controls how often digest calculation is executed. Digest calculation can take quite a long time for an OTA image. Other processing for the system may be deemed more important, and therefore Silicon Labs adds delays between calculations. This also controls how often custom verification written by the application developer is executed. A value of 0 means the calculations run to completion.</p></td></tr><tr style="height:25pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Image Signer EUI64 0</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;padding-right: 25pt;text-indent: 0pt;text-align: left;">The big endian EUI64 address of a device authorized to sign OTA images for this client. A value of all 0s is ignored.</p></td></tr><tr style="height:25pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Image Signer EUI64 1</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;padding-right: 25pt;text-indent: 0pt;text-align: left;">The big endian EUI64 address of a device authorized to sign OTA images for this client. A value of all 0s is ignored.</p></td></tr><tr style="height:25pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Image Signer EUI64 2</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;padding-right: 25pt;text-indent: 0pt;text-align: left;">The big endian EUI64 address of a device authorized to sign OTA images for this client. A value of all 0s is ignored.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-top: 4pt;padding-left: 60pt;text-indent: -36pt;text-align: justify;">Note: <span class="p">The default value for the Image Signer EUI64 0 option is the EUI64 of the test certificate embedded within the image-builder tool provided by Silicon Labs. Using this default will allow customers to test image signing and verification prior to obtaining produc- tion signing certificates from Certicom.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark100">OTA Bootload Cluster Client Policy Plugin</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">This module controls the OTA cluster client’s behavior. It dictates what image information it uses in the query, what custom verification of the image is done by the device, and what happens when the client receives a command to upgrade to the new image.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Silicon Labs provides a plugin that provides a simple implementation of the OTA client policy.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">Note: <span class="p">The Manufacturer ID is not set in this plugin, but in the “ZCL Clusters” tab of AppBuilder.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24.25pt" cellspacing="0"><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Options</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:25pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Image Type ID</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 18pt;text-indent: 0pt;text-align: left;">The device&#39;s OTA image identifier used for querying the OTA server about the next image to use for an upgrade.</p></td></tr><tr style="height:25pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Firmware Version</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 10pt;text-indent: 0pt;text-align: left;">The device&#39;s current firmware version, used when querying the OTA server about the next image to use for an upgrade.</p></td></tr><tr style="height:46pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Hardware Version</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 12pt;text-indent: 0pt;text-align: left;">Devices may have a hardware version that limits what images they can use. OTA images may be configured with minimum and maximum hardware versions on which they are supported. If the device is not restricted by hardware version then this value should be 0xFFFF</p></td></tr><tr style="height:25pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Perform EBL Verification (SOC only)</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 14pt;text-indent: 0pt;text-align: left;">This uses the application bootloader routines to verify the EBL image after signature verification passes.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark101">OTA Storage Plugins</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The over-the-air cluster requires a storage device for files received by the OTA clients, or served up by the OTA server. This storage varies based on the device’s hardware and design. Therefore, this functionality is separated from the core cluster code and accessed through a set of APIs. The interface supports managing multiple files, retrieving arbitrary blocks of data from the files, and performing basic validation on the file format.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Silicon Labs currently provides two main plugins that implement the OTA storage module, the <b>OTA Storage POSIX Filesystem Plugin</b></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">and the <b>OTA Simple Storage Plugin</b>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l59"><li><p class="s6" style="padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark102">OTA Storage POSIX File System Plugin</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">This implementation uses a POSIX file system as the storage module to store and retrieve data for OTA files. It can handle any number of files. This plugin is used with an EZSP-based platform (such as EFR32 NCP) where the host is connected to the NCP through UART.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">This plugin has no configurable options.</p></li><li><p class="s6" style="padding-top: 7pt;padding-left: 59pt;text-indent: -36pt;text-align: justify;"><a name="bookmark103">OTA Simple Storage Module Plugin</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">This implementation provides a simple storage module that stores only one file. It uses an OTA storage driver to perform the actual storage of the data in a hardware or software device accessible by the OTA cluster code. When enabled the developer must also select either the <b>OTA Simple Storage RAM Driver Plugin </b>or the <b>OTA Simple Storage EEPROM Driver Plugin</b>.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 181%;text-align: justify;">The plugin can be used by either an EZSP- or an SOC-based platform. This plugin has no configurable options.</p></li><li><p class="s6" style="padding-top: 2pt;padding-left: 59pt;text-indent: -36pt;text-align: justify;"><a name="bookmark104">OTA Simple Storage RAM Driver Plugin</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">This driver provides a RAM storage device for storing files. It is intended only as a test implementation for development on WSTKs; it is not intended as production ready code. Prior to integrating external storage hardware into a device, this driver can be useful for examining the basic behavior of the OTA cluster. The storage device has a pre-built OTA image already in place that can be used for downloading but does not actually perform an upgrade.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">This plugin has no configurable options.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s6" style="padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark105">OTA Simple Storage EEPROM Driver Plugin</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">This driver uses the HAL routines to read and write data from an EEPROM.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For the SOC platforms this module handles the details of re-mapping the image so that it can be read by the bootloader. Existing boot- loaders require that the EBL or GBL header be the first bytes at the top the storage device, so the code must relocate the OTA header to another location while at the same time providing an interface to the storage code that accesses the OTA file in a linear manner.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">The following figure illustrates a change in the OTA image on disk.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 135pt;text-indent: 0pt;text-align: left;"><span><img width="427" height="329" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_022.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 28pt;text-indent: 0pt;text-align: center;">Figure 15-3. OTA Image Change</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24.25pt" cellspacing="0"><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Options</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:56pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">SOC Bootloading Support</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 11pt;text-indent: 0pt;text-align: left;">This option enables bootloading support for SOC devices. When enabled, it will re- map the OTA image file so that the bootloader data is at the top of the EEPROM and therefore can be accessed by all existing Ember bootloaders. It requires that the bootloader portion of the image is the first TAG in the file. The OTA storage starting offset should be 0 when this is enabled.</p></td></tr><tr style="height:25pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 12pt;text-indent: 0pt;text-align: left;">Frequency for Saving Download Offset to Non-Volatile Memory (bytes)</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 28pt;text-indent: 0pt;text-align: left;">How often the current download offset is stored to NVM, in bytes. If set to 0 it will always be written to NVM.</p></td></tr><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">OTA Storage Start Offset</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">The starting offset for the OTA image storage location in the NVM.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24.25pt" cellspacing="0"><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Options</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">OTA Storage End Offset</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">The last offset for the OTA image storage location in the NVM.</p></td></tr><tr style="height:87pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 32pt;text-indent: 0pt;text-align: left;">EEPROM Device Read-modify-write Support</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 7pt;text-indent: 0pt;text-align: left;">This checkbox indicates whether the underlying EEPROM storage driver has support for read-modify-write, where a portion of a page of flash can be rewritten without erasing the entire page. If the driver requires a page erase before writing any data this box should not be checked. Before EmberZNet 4.6.2 read-modify-write support was required by the underlying flash driver. EmberZNet 4.6.2 introduced the ability to use parts where a page-erase is required. When designing software for the development boards this checkbox should remain checked since the EEPROM parts require read- modify-write support.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s6" style="padding-top: 4pt;padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark106">OTA Bootload Cluster Storage Common Code Plugin</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;line-height: 183%;text-align: left;">This plugin provides code common to all the OTA storage plugins and must be enabled when one of those plugins is enabled. This plugin has no configurable options.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s5" style="padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark107">OTA Cluster Platform Bootloader Plugin</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">When the client has a completed file downloaded and ready to upgrade, it waits for a command from the server to apply the upgrade. Upon receipt of the command to upgrade, the OTA client cluster code calls into the OTA client policy code to perform the next steps to apply the upgrade.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Silicon Labs provides a single plugin to handle bootloading. The behavior differs depending on the platform on which it is being used. The Ember OTA Client Policy plugin calls into this plugin to perform the actual bootloading.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For the SoC, the bootload code simply calls the HAL routine to execute the application bootloader. The application bootloader then reads from the data stored in external EEPROM, copies that data into the chip’s internal flash, and then reboots.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 106%;text-align: justify;">For the NCP, Silicon Labs provides an implementation that bootloads the NCP through serial UART or SPI bus. This implementation works only with the Ember NCP bootloader provided as part of the EZSP NCP firmware delivery. The implementation executes the bootloader on the NCP, transfers the file from the storage device on the host to the NCP by xmodem, then reboots the NCP.</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">For the host, developers are expected to write their own code for bootloading a host system connected to an NCP.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark108">OTA Cluster Command Line Interface</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l60"><li><p class="s6" style="padding-top: 4pt;padding-left: 95pt;text-indent: -72pt;line-height: 10pt;text-align: left;"><a name="bookmark109">Client Commands</a></p><p class="s5" style="padding-left: 203pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Table 16-1. OTA Cluster Client Commands</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24.25pt" cellspacing="0"><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Command</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota client printImages</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Prints all images that are stored in the OTA storage module along with their index.</p></td></tr><tr style="height:25pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota client info</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 24pt;text-indent: 0pt;text-align: left;">Prints the Manufacturer ID, Image Type ID, and Version information that are used when a query next image is sent to the server by the client.</p></td></tr><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota client status</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Prints information on the current state of the OTA client download.</p></td></tr><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota client verify &lt;index&gt;</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Performs signature verification on the image at the specified index.</p></td></tr><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota client bootload &lt;index&gt;</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Bootloads the image at the specified index by calling the OTA bootload callback.</p></td></tr><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota client delete &lt;index&gt;</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Deletes the image at the specified index from the OTA storage device.</p></td></tr><tr style="height:35pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota client start</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 15pt;text-indent: 0pt;text-align: left;">Starts the OTA client state machine. The state machine discovers the OTA server, queries for new images, download the images, and waits for the server command to upgrade.</p></td></tr><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota client stop</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Stops the OTA client state machine.</p></td></tr><tr style="height:35pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota client page-request &lt;boolean&gt;</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 4pt;text-indent: 0pt;text-align: justify;">Dynamically enables or disables the use of page request if the client turned on support in AppBuilder. By default, if the client enabled page request support in AppBuilder then the client uses the page request command when downloading a file.</p></td></tr><tr style="height:25pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota client block-test</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 25pt;text-indent: 0pt;text-align: left;">Test harness command. Sends an invalid block request to the client’s previously discovered OTA server to verify that the server sends back the correct command.</p></td></tr></table></li><li><p class="s6" style="padding-top: 7pt;padding-left: 95pt;text-indent: -72pt;text-align: left;"><a name="bookmark110">Server Commands</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-top: 4pt;padding-left: 28pt;text-indent: 0pt;text-align: center;">Table 16-2. OTA Cluster Server Commands</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24.25pt" cellspacing="0"><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Command</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#808080"><p class="s20" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Description</p></td></tr><tr style="height:15pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota server printImages</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Prints all images that are stored in the OTA storage module along with their index.</p></td></tr><tr style="height:14pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota server policy print</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Prints the policies used by the OTA Server Policy plugin.</p></td></tr><tr style="height:14pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota server delete &lt;index&gt;</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Deletes the image at the specified index from the OTA storage device.</p></td></tr><tr style="height:72pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota server policy query &lt;int&gt;</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 6pt;text-indent: 0pt;text-align: left;">Sets the policy used by the OTA Server Policy plugin when it receives a query request from the client. The policy values are:</p><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 190pt;text-indent: 0pt;line-height: 115%;text-align: left;">0: Upgrade if server has newer (default) 1: Downgrade if server has older</p><p class="s21" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">2: Reinstall if server has same</p><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">3: No next version (no <i>next </i>image is available for download)</p></td></tr><tr style="height:61pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota server policy blockRequest &lt;int&gt;</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 2pt;padding-left: 5pt;padding-right: 8pt;text-indent: 0pt;text-align: left;">Sets the policy used by the OTA Server Policy plugin when it receives an image block request. The policy values are:</p><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">0: Send block (default)</p><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">1: Delay download once for 2 minutes</p><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">2: Always abort download after first block</p></td></tr><tr style="height:60pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota server policy upgrade &lt;int&gt;</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 5pt;text-indent: 0pt;text-align: left;">Sets the policy used by the OTA Server Policy plugin when it receives an upgrade end request. The policy values are:</p><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 248pt;text-indent: 0pt;line-height: 115%;text-align: left;">0: Upgrade Now (default) 1: Upgrade in 2 minutes</p><p class="s21" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">2: Ask me later to upgrade</p></td></tr><tr style="height:104pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota server notify &lt;dest&gt;</p><p class="s21" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">&lt;payload type&gt;</p><p class="s21" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">&lt;jitter&gt;</p><p class="s21" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">&lt;manuf-id&gt;</p><p class="s21" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">&lt;device-id&gt;</p><p class="s21" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">&lt;version&gt;</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 6pt;text-indent: 0pt;text-align: left;">This command sends an OTA Image Notify message to the specified destination indi- cating a new version of an image is available for download. The payload type field val- ues are:</p><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">0: Include only jitter field</p><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">1: Include jitter and manuf-id</p><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">2: Include jitter, manuf-id, and device-id</p><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">3: Include jitter, manuf-id, device-id, and version</p><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 16pt;text-indent: 0pt;text-align: left;">All fields in the CLI command must be specified. However if the payload type is less than 3, those values will be ignored and not included in the message.</p></td></tr><tr style="height:54pt"><td style="width:184pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zcl ota server page-req-miss &lt;modulus&gt;</p></td><td style="width:356pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s21" style="padding-top: 1pt;padding-left: 5pt;padding-right: 5pt;text-indent: 0pt;text-align: left;">Test harness command. Sets a module’s value that tells the OTA server to artificially skip certain image block responses sent in response to an image page request. This simulates missed blocks that the client will have to request later after the page request has completed. If the number of the block sent by the server is a multiple of the modu- lus value then it will be skipped.</p></td></tr></table></li></ol></li><li><p class="s5" style="padding-top: 7pt;padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark111">OTA Client State Machine</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The following figure illustrates how the OTA Bootload Cluster client plugin code will behave from start to finish.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="604" height="739" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_023.gif"/></span></p><p class="s5" style="padding-top: 4pt;padding-left: 485pt;text-indent: 0pt;text-align: center;">Figure 15-4. OTA</p><p class="s5" style="padding-left: 28pt;text-indent: 0pt;text-align: center;">Bootload Cluster Client Plugin Behavior</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 59pt;text-indent: -36pt;text-align: left;"><a name="bookmark112">Example Client and Server Setup</a></p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">A separate application note (<i>AN728: Over-the-Air Bootload Server and Client Setup</i>) describes a complete client and server setup using these plugins and Silicon Labs development kits.</p></li></ol></li><li><p class="s5" style="padding-top: 7pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark113">Reporting Plugin</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Reports can be setup on a reporting device when the device is required to periodically send out reports. The plugin relies on bindings. Each report is an asynchronous message sent out from the reporting device, when a local ZCL attribute has changed, to corresponding entries in the binding table. Either the node sending the reports, the node receiving the reports, or another third-party configuration device may create the binding table entry(s) on the reporting node. This plugin supports both requesting reports from another device and sending out attribute reports when the device has been configured to do so. If the application will receive reports from multiple sources, the device should be configured as a concentrator.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l61"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark114">Reporting Command Line Interface (CLI)</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The framework provides CLI commands for creating and managing reporting table entries directly on the device, requesting reports from another device, and configuring device to send out reports from another device.</p><p class="s5" style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Local Commands</p><ul id="l62"><li><p class="s5" style="padding-top: 8pt;padding-left: 29pt;text-indent: -5pt;line-height: 181%;text-align: left;">plugin reporting print Print the report table.</p></li><li><p class="s5" style="padding-left: 29pt;text-indent: -5pt;line-height: 181%;text-align: left;">plugin reporting clear Print the report table.</p></li><li><p class="s5" style="padding-left: 29pt;text-indent: -5pt;line-height: 181%;text-align: left;">plugin reporting remove [index:1] Remove an entry from the report table.</p><ul id="l63"><li><p class="s5" style="padding-left: 35pt;text-indent: -6pt;line-height: 10pt;text-align: left;">index – the index of the report to be removed (1 byte).</p></li></ul></li><li><p class="s5" style="padding-top: 8pt;padding-left: 29pt;text-indent: -5pt;line-height: 183%;text-align: left;">plugin reporting add [endpoint:1] [clusterId:2] [attributeId:2] [mask:1] [minInterval:2] [maxInterval:2] [reportableChange:4] Add a new entry to the report table.</p><ul id="l64"><li><p class="s5" style="padding-left: 45pt;text-indent: -16pt;line-height: 10pt;text-align: left;">- endpoint – The local endpoint from which the attribute is reported (1 byte).</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 45pt;text-indent: -16pt;text-align: left;">- clusterId – The cluster where the attribute is located (2 bytes).</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 45pt;text-indent: -16pt;text-align: left;">- attributeId – The id of the attribute being reported (2 bytes).</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 45pt;text-indent: -16pt;text-align: left;">- mask – 0 for client-side attributes or 1 for server-side attributes (1 byte).</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 45pt;text-indent: -16pt;text-align: left;">- minInterval – The minimum reporting interval, measured in seconds (2 bytes).</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 45pt;text-indent: -16pt;text-align: left;">- maxInterval – The maximum reporting interval, measured in seconds (2 bytes).</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 45pt;text-indent: -16pt;text-align: left;">- reportableChange – The minimum change to the attribute that will result in a report being sent (4 bytes).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Remote Commands</p></li></ul></li><li><p class="s5" style="padding-top: 8pt;padding-left: 30pt;text-indent: -6pt;text-align: left;">zcl global report [endpoint:1] [clusterId:2] [attributeId:2] [direction:1]</p><p class="s5" style="padding-top: 8pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">Creates a report with the specified cluster, attribute and server/client direction.</p><ul id="l65"><li><p class="s5" style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">endpoint <span class="p">– src endpoint id to read from (2 bytes).</span></p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">clusterId – cluster id to read from (2 bytes).</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">attributeId – the attribute id to read from (2 bytes).</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">direction – 0 for client-to-server, 1 for server-to-client (1 byte).</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-top: 4pt;padding-left: 30pt;text-indent: -6pt;text-align: justify;">zcl global report-read [cluster:2] [attributeId:2] [direction:1]</p><p class="s5" style="padding-top: 8pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">Creates a global read reporting command for the associated cluster, attribute and server/client direction.</p><ul id="l66"><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">cluster – cluster id to read from (2 bytes).</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">attributeId – the attribute id to read from (2 bytes).</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">direction – 0 for client-to-server, 1 for server-to-client (1 byte).</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 23pt;text-indent: 0pt;line-height: 107%;text-align: justify;">zcl global send-me-a-report [cluster:2] [attributeId:2] [dataType:1] [minReportTime:2] [maxReportTime:2] [reportableChange:- 2147483648]</p><p class="s5" style="padding-top: 7pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">Creates a global send me a report command for the associated values.</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 42pt;text-indent: -16pt;text-align: left;">- cluster <span class="p">– </span>The cluster id of the requested report (2 bytes).</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 42pt;text-indent: -16pt;text-align: left;">- attributeId <span class="p">– </span>The attribute id for requested report (2 bytes).</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 42pt;text-indent: -16pt;text-align: left;">- dataType <span class="p">– </span>The Zigbee type value for the requested report (1 byte).</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 42pt;text-indent: -16pt;text-align: left;">- minReportTime <span class="p">– </span>Minimum number of seconds between reports (2 bytes).</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 42pt;text-indent: -16pt;text-align: left;">- maxReportTime <span class="p">– </span>Maximum number of seconds between reports (2 bytes).</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 42pt;text-indent: -16pt;text-align: left;">- reportableChange <span class="p">– </span>Amount of change to trigger a report.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 26pt;text-indent: -2pt;line-height: 181%;text-align: left;">zcl global expect-report-from-me [cluster:2] [attributeId:2] [timeout:2] Create an expect-report-from-me message with associated values.</p></li><li><p class="s5" style="padding-left: 42pt;text-indent: -16pt;line-height: 10pt;text-align: left;">- cluster <span class="p">– </span>The cluster id of the requested report (2 bytes).</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 42pt;text-indent: -16pt;text-align: left;">- attributeId <span class="p">– </span>The attribute id for requested report (2 bytes).</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 42pt;text-indent: -16pt;text-align: left;">- timeout <span class="p">– </span>Maximum amount of time between reports.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: justify;"><a name="bookmark115">Reporting Connection Setup through CLI</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">The CLI example below makes a few assumptions regarding application configurations as follow:</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">The report sender application should implement the Basic Cluster on endpoint 6. The report receiver application should implement the Basic Cluster on endpoint 1. Both applications should have debugging messages turned on. It is also assumed that both devices have joined the same network with the report sender node as the creator of the network.</p><ol id="l67"><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;">Clear all bindings on the sender node since reports are sent via bindings.</p><p class="s10" style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">report_sender_cli&gt; option binding-table clear</p></li><li><p style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Request reports of the application version (cluster 0x0000, attribute 0x0001) of the sender to receiver node by receiving node.</p><p class="s10" style="padding-top: 7pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">report_receiver_cli&gt; zcl global send-me-a-report 0x0000 0x0001 0x20 10 20 {00} report_receiver_cli&gt; send 0 1 6</p></li><li><p style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Following outputs should be observed:</p><p class="s10" style="padding-top: 8pt;padding-left: 24pt;text-indent: 35pt;text-align: left;">report_sender_cli&gt; CFG_RPT: (Basic) - direction:00, attr:0000 type:20, min:000A, max:0014 change:00</p><p class="s10" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">report_receiver_cli&gt; CFG_RPT_RESP: (BASIC) – status: 00</p></li><li><p style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">After successfully send the report request (status – 00), an actual report can be read by the receiver node using following command:</p><p class="s10" style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">report_receiver_cli&gt; zcl global report-read 0x0000 0x0000 0x00 report_receiver_cli&gt; send 0 1 6</p></li><li><p style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Following outputs should be observed:</p><p class="s10" style="padding-top: 8pt;padding-left: 24pt;text-indent: 35pt;text-align: left;">report_receiver_cli&gt; READ_RPT_CFG_RESP: (Basic) - status:00, direction:00, attr:0000 type:20, min:000A, max:0014 change:00</p></li><li><p style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Find node field ID or IEEEAddr from receiver node.</p><p class="s10" style="padding-top: 7pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">report_receiver_cli&gt; info</p></li><li><p style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Create binding on sending node to start sending reports to the receiver.</p><p class="s10" style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">report_sender_cli&gt; option binding-table set 0 0x0000 0x06 0x01 {EUI64 node ID from previous</p><p class="s10" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">step}</p></li><li><p style="padding-top: 8pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Following outputs should be observed:</p><p class="s10" style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">“set bind 0: 0x00”</p></li><li><p style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">The receiver node should start getting reports as follow:</p><p class="s10" style="padding-top: 7pt;padding-left: 60pt;text-indent: 0pt;text-align: left;">report_receiver_cli&gt; RPT_ATTR: (Basic) - attr:0000 type:20, val:01</p></li><li><p style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">Cancel report (by setting the maximum interval to 0xFFFF)</p><p class="s10" style="padding-top: 7pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">report_receiver_cli&gt; zcl global send-me-a-report 0x0000 0x0000 0x20 0x0000 0xFFFF {00} report_receiver_cli&gt; send 0 1 6</p></li><li><p style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">Following outputs should be observed:</p></li></ol><p class="s10" style="padding-top: 7pt;padding-left: 24pt;text-indent: 35pt;text-align: left;">report_sender_cli&gt; CFG_RPT: (Basic) - direction:00, attr:0000 type:20, min:0000, max:FFFF change:00</p><p class="s10" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">report_receiver_cli&gt; CFG_RPT_RESP: (Basic) – status: 00</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark116">Reporting for External Attributes</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;"><a name="bookmark117">The framework automatically notifies the plugin whenever attributes that it manages are changed. Customers who use external attributes must notify the Reporting plugin when those attributes change. Failure to notify the plugin will result in incorrect reporting behavior. Any applications that will be reporting external attributes must call </a><span class="s8">emberAfReportingAttributeChangeCallback </span>whenever ex- ternal attributes change.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;">Tunneling Plugin</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Tunnels are established between a client and server with a specific protocol (which may be manufacturer-specific) and optional flow control support. The client opens the tunnel by sending a Request Tunnel command to the server. If the server does not support the protocol or flow control, it rejects the tunnel. The tunneling plugins do not deal with protocols at all. Instead, they rely on the application for parsing the raw data and, in the case of the server, for indicating whether particular protocols are supported. The tunneling plugins do not currently support flow control and automatically reject tunnels that request flow control.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Once the tunnel is established, either side can send data with the Transfer Data command. If the sender does not have access to the tunnel, a Transfer Data Error command is sent. If the plugins receive a Transfer Data Error command for a tunnel of which they are a part, they assume that something went wrong and that the tunnel is now closed.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Tunnels can be closed by either the client or server. When the client wants to close the tunnel, it sends a Close Tunnel command to the server. The server can close a tunnel if it has been inactive for some period of time, specified by the Close Tunnel Timeout attribute. If the server closes an inactive tunnel, it does not notify the client, as it is assumed that the client is sleepy in this case. The Close Tunnel Timeout attribute is adjustable by the user through a plugin option.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l68"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark118">Tunneling Setup</a></p><ol id="l69"><li><p style="padding-top: 5pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">In AppBuilder, select File &gt; New &gt; Silicon Labs AppBuilder Project &gt; Silicon Labs Zigbee &gt; EmberZNet SoC 6.6.0.0 &gt; Z3Light.</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">On the ZCL Clusters tab, change the ZCL device type to any of the SE devices.</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">Enable the Tunneling cluster client and/or server.</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">Enable the Generic Tunnel cluster server. NOTE: the spec says that the Tunneling client must include the Generic Tunnel client, but this is an error in the spec.</p></li><li><p style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">On the Printing and CLI tab, in the Application specific debug printing section, enable printing for Tunneling by checking the &quot;Com- piled in&quot; and &quot;Enabled at startup&quot; checkboxes next to &quot;Tunneling cluster.&quot;</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">In the General-purpose debug printing area, enable printing for Debug by checking the &quot;Compiled in&quot; and &quot;Enabled at startup&quot; check- boxes next to &quot;Debug.&quot;</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">On the Plugins tab enable the Fragmentation plugin.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">On the Plugins tab, verify that the Tunneling client and/or server plugins are enabled and adjust any plugin-specific options.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Verify that the Generic Tunnel client plugins is enabled.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Enable the General response commands plugin.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">Click <b>Generate </b>to generate the application.</p></li><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">In the generated Application_callbacks.c file, modify the emberAfPluginTunnelingServerIsProtocolSupportedCallback stub so that it returns TRUE for any protocols supported by the application.</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark119">Tunneling Command Line Interface (CLI)</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">The framework provides CLI commands for opening and closing tunnels as well as sending data.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark120">Tunneling Client CLI Commands</a></p><ul id="l70"><li><p class="s5" style="padding-top: 7pt;padding-left: 30pt;text-indent: -6pt;text-align: left;">zcl tunneling request &lt;protocol id:1&gt; &lt;manufacturer code:2&gt; &lt;flow control:1&gt;</p><ul id="l71"><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">Protocols 0 through 5 are defined by the spec.</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">Protocols 6 through 199 are reserved for future use.</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">Protocols 200 through 254 are for manufacturer-specific protocols.</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">Protocol 255 is reserved.</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">The manufacturer code is only used when the protocol is 200 through 254.</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">The manufacturer code should be set to 0xFFFF when not used.</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">Flow control should be 0 when not used and 1 when used.</p></li></ul></li><li><p class="s5" style="padding-top: 8pt;padding-left: 30pt;text-indent: -6pt;text-align: left;">zcl tunneling close &lt;tunnel id:2&gt;</p><p style="padding-top: 8pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">* The tunnel id is a unique 16-bit identifier assigned by the server and sent in the Tunnel Request Response command.</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 30pt;text-indent: -6pt;text-align: left;">zcl tunneling transfer-to-server &lt;tunnel id:2&gt; &lt;data&gt;</p><ul id="l72"><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">The tunnel id is a unique 16-bit identifier assigned by the server and sent in the Tunnel Request Response command.</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">The data is raw protocol data and is not preceded by a length byte like other string types.</p></li></ul></li><li><p class="s5" style="padding-top: 8pt;padding-left: 30pt;text-indent: -6pt;text-align: left;">zcl tunneling random-to-server &lt;tunnel id:2&gt; &lt;length:2&gt;</p><ul id="l73"><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">The tunnel id is a unique 16-bit identifier assigned by the server and sent in the Tunnel Request Response command.</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">The length is the number of bytes of random data to send.</p></li><li><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 5pt;text-align: left;">The framework and fragmentation library only support messages up to 255 bytes. With the three-byte ZCL header and the two-byte protocol id, only 250 bytes are left for the data.</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark121">Tunneling Server CLI Commands</a></p><ul id="l74"><li><p class="s5" style="padding-top: 7pt;padding-left: 30pt;text-indent: -6pt;text-align: left;">zcl tunneling transfer-to-client &lt;tunnel id:2&gt; &lt;data&gt;</p><ul id="l75"><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">The tunnel id is a unique 16-bit identifier assigned by the server and sent in the Tunnel Request Response command.</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">The data is raw protocol data and is not preceded by a length byte like other string types.</p></li></ul></li><li><p class="s5" style="padding-top: 8pt;padding-left: 30pt;text-indent: -6pt;text-align: left;">zcl tunneling random-to-client &lt;tunnel id:2&gt; &lt;length:2&gt;</p></li></ul><ul id="l76"><li><p style="padding-top: 7pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">The tunnel id is a unique 16-bit identifier assigned by the server and sent in the Tunnel Request Response command.</p></li><li><p style="padding-top: 8pt;padding-left: 35pt;text-indent: -6pt;text-align: left;">The length is the number of bytes of random data to send.</p></li><li><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 5pt;text-align: justify;">The framework and fragmentation library only support messages up to 255 bytes. With the three-byte ZCL header and the two-byte protocol id, only 250 bytes are left for the data.</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark122">Tunneling Current Limitations</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Both ends of a tunnel should ensure that only the partner to which the tunnel has been built up is granted read/write access to it. The spec mentions enforcing by checking the MAC address of the sending node. The plugins currently only check node and endpoint IDs and do not check the MAC.</p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The Tunneling cluster client and server are supposed to negotiate a maximum transfer size by reading the Maximum Incoming Transfer Size and Maximum Outgoing Transfer Size attributes from the Tunneling cluster client or server plugins. These plugins set these attrib- utes, but do not read them from the remote node to negotiate the maximum size for the transfer.</p></li></ol></li></ol></li><li><h3 style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;"><a name="bookmark123">Extending the Zigbee Cluster Library (ZCL)</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l77"><li><p class="s5" style="padding-top: 10pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark124">Introduction</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Developers may extend the Zigbee application layer using any of the following techniques:</p><ol id="l78"><li><p style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">Private Profile: The profile ID is a two-byte value passed in Zigbee messages in the Zigbee APS frame. In order for two Zigbee devices to interact at the application layer, they must have the same profile ID. If they do not they will drop each other’s messages. A private profile is used to completely protect all interaction within a given system. If you are planning to use Zigbee for your network and link layers but in other respects are planning to have a closed system, you may wish to create a private Zigbee Profile. If you use a private profile, your devices will not be interoperable with any other Zigbee devices using other profiles.</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;">Manufacturer-Specific Clusters: Any clusters with cluster IDs of range 0xfc00 – 0xffff are considered manufacturer-specific and must have an associated two-byte manufacturer code. All commands and attributes within a manufacturer-specific cluster are also con- sidered manufacturer-specific.</p><p style="padding-top: 7pt;padding-left: 38pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Example: In the sample-extensions.xml file included with the application framework, Silicon Labs has defined a sample manufacturer- specific cluster with Cluster ID 0xfc00 and manufacturer code 0x1002 (Silicon Labs’ manufacturer code).</p></li><li><p style="padding-top: 2pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">Manufacturer-Specific Commands: You can augment a standard Zigbee cluster by adding manufacturer-specific commands to that cluster. Manufacturer-specific commands within a standard Zigbee cluster may use the entire range of command IDs 0x00 – 0xff. A two-byte manufacturing code must be provided for the manufacturer-specific command so that the command can be distinguished from the standard Zigbee commands in that cluster.</p><p style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;text-align: justify;">Example: In the sample-extensions.xml file included with the application framework, Silicon Labs has defined three commands to extend the On/Off cluster called OffWithTransition, OnWithTransition and ToggleWithTransition. These commands share the same command IDs as the standard Off, On and Toggle commands in that cluster. However, they also include the manufacturer code 0x1002, indicating that they are Silicon Labs’ manufacturer-specific commands.</p></li><li><p style="padding-top: 3pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;">Manufacturer-Specific Attributes: Standard Zigbee clusters can be extended by adding manufacturer-specific attributes to your ap- plication. Manufacturer-specific attributes within a standard Zigbee cluster may use the entire attribute ID address space from 0x0000 to 0xffff. A two-byte manufacturer code must be included for each manufacturer-specific attribute so that it can be distinguished from non-manufacturer-specific attributes.</p></li></ol><p style="padding-top: 8pt;padding-left: 38pt;text-indent: 0pt;text-align: justify;">Example: In the sample-extensions.xml file included with the application framework, Silicon Labs has defined a single attribute Tran- sition Time which shares the same attribute ID with the on/off state in the on/off cluster 0x0000. However, the transition time attribute also contains the manufacturer code 0x1002, indicating that it is Silicon Labs’ manufacturer-specific attribute.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 60pt;text-indent: -36pt;text-align: justify;">Note: <a href="http://zigbee.org/" class="s7" target="_blank">Silicon Labs’ manufacturer code 0x1002 is defined by the Zigbee organization and is included in the Manufacturer Code data- base (Zigbee document #053874). Manufacturer codes are required for the implementation of manufacturer-specific clusters, attributes and commands. Unique manufacturer codes are provided by Zigbee for each requesting organization. To get a man- ufacturer code for your organization contact Zigbee at </a><a href="http://zigbee.org/" class="s9" target="_blank">http://zigbee.org</a><a href="http://zigbee.org/" class="s7" target="_blank">.</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-top: 4pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark125">Limitations to Consider</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">There are two notable limitations to consider when extending the application framework with manufacturer-specific clusters, attributes and commands.</p><ul id="l79"><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: justify;">All cluster IDs including those of manufacturer-specific clusters MUST be unique within a single device. The Zigbee application frame- work does not currently support overlapping manufacturer-specific cluster IDs within a single device. In other words, you cannot implement cluster 0xFC00 with manufacturer code 0xFEED AND cluster 0xFC00 with manufacturer code 0xBEEF on the SAME device. The Zigbee application framework assumes that ALL cluster IDs are unique regardless of the manufacturer code associated with them.</p></li><li><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -14pt;text-align: justify;">All attribute and command IDs within a manufacturer-specific cluster MUST be unique, and are assumed to have the same manufac- turer code as the cluster they are in. The Zigbee protocol does not support overlapping manufacturer-specific attribute or command IDs (with different manufacturer codes) WITHIN a manufacturer-specific cluster. The reason is simply that only a single manufacturer code is passed in the Zigbee application header. If the cluster addressed is in the manufacturer-specific range 0xFC00 – 0xFFFF then the manufacturer code is assumed to apply to the cluster. This makes it impossible to address, for instance, Attribute 0x0000 with manufacturer code 0xFEED inside cluster 0x0000 with manufacturer code 0xBEEF. The Zigbee application framework does not even bother to store individual manufacturer codes for attributes within a manufacturer-specific cluster since the manufacturer code of the cluster is assumed to apply to all of the attributes within it.</p></li></ul></li><li><p class="s5" style="padding-top: 7pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark126">Defining ZCL Extensions within the Application Framework and AppBuilder</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">The entire Zigbee Cluster Library is defined in XML format in the tool/appbuilder directory. In addition to expected XML files such as general.xml or ha.xml that describe the clusters, commands and attributes associated with standard ZCL used by the Zigbee application framework, there is a sample extension file called, unsurprisingly, sample-extensions.xml. This XML file contains several sample Zigbee extensions including a custom cluster, custom attributes added to the on/off cluster and custom commands added to the on/off cluster.</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">In order to extend the Zigbee cluster library, you must create a similar extension file for your extensions and add them into the AppBuilder by following the instructions included in the AppBuilder Online Help in the section entitled “Creating Custom Clusters.” Further documen- tation about extending the Zigbee application framework is included in the sample-extensions.xml file.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 60pt;text-indent: -36pt;text-align: justify;">Note: <span class="p">Any multi-byte numeric constant values specified in the XML file should specify the full number of digits as hex, such as &quot;0x000000000000&quot; (for an int48u) rather than simply &quot;0x00&quot; or &quot;0&quot;. This ensures that the proper default value will be added to the GENERATED_DEFAULTS define in the &lt;appname&gt;_endpoint_config.h file during generation.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark127">Manufacturer-Specific Attribute APIs</a></p><p style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Some APIs in Zigbee application framework used to interact with attributes have been modified to take a manufacturer code as an argument.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l80"><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark128">Attribute Read and Write</a></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">All of the read and write attribute functions have additional functions that take a manufacturer code along with the rest of the attribute- addressing information. When you read and write to a manufacturer-specific attribute you must supply the manufacturer code for the attribute you wish to read or write so that it can be found in the attribute table. For example, you may read a standard Zigbee attribute using the function <span class="s8">emberAfReadServerAttribute</span>. However, if you call this function for a manufacturer-specific attribute no man- ufacturer Code argument allows you to properly identify your manufacturer-specific attribute, so the read will fail. If you wish to read a manufacturer-specific attribute you must use the manufacturer-specific functions <span class="s8">emberAfReadManufacturerSpecificServ- erAttribute </span>and <span class="s8">emberAfReadManufacturerSpecificClientAttribute</span>. Both of these functions take a manufacturer code, which they pass on to the general function <span class="s8">emberAfReadOrUpdateAttribute</span>.</p><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Breaking out the manufacturer-specific APIs into their own interface eliminates the need for code that is non-manufacturer-specific to pass around bogus manufacturer codes. This would be a waste of code space given the large number of attribute interactions that exist in the application framework.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-left: 52pt;text-indent: -28pt;text-align: left;"><a name="bookmark129">Attribute Changed Callbacks</a></p></li></ol></li></ol></li></ol><p style="padding-top: 8pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">Silicon Labs has also added manufacturer-specific attribute changed callbacks into the Zigbee application framework, so that standard attribute callbacks do not need to waste code space checking a non-existent manufacturer code.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-top: 21pt;padding-left: 36pt;text-indent: 0pt;text-align: left;">Simplicity Studio</h2><p class="s23" style="padding-top: 15pt;padding-left: 36pt;text-indent: 0pt;text-align: left;">One-click access to MCU and wireless tools, documentation, software, source code libraries &amp; more. Available for Windows, Mac and Linux!</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="768" height="435" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_024.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="79" height="79" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_025.png"/></span></p><h4 style="padding-left: 91pt;text-indent: 0pt;text-align: center;">IoT Portfolio</h4><p style="padding-top: 1pt;padding-left: 94pt;text-indent: 0pt;text-align: center;"><a href="http://www.silabs.com/IoT" class="s24">www.silabs.com/IoT</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="79" height="79" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_026.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;">SW/HW</h4><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 37pt;text-indent: 0pt;text-align: left;"><a href="http://www.silabs.com/simplicity" class="s25">www.silabs.com/simplicity</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="79" height="79" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_027.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;">Quality</h4><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"><a href="http://www.silabs.com/quality" class="s24">www.silabs.com/quality</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 31pt;text-indent: 0pt;text-align: left;">Support &amp; Community</h4><p style="text-indent: 0pt;text-align: left;"><span><img width="79" height="79" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_028.png"/></span></p><p style="padding-top: 1pt;padding-left: 33pt;text-indent: 0pt;text-align: left;"><a href="http://www.silabs.com/community" class="s24">www.silabs.com/community</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Disclaimer</p><p class="s27" style="padding-top: 1pt;padding-bottom: 1pt;padding-left: 6pt;text-indent: 0pt;line-height: 114%;text-align: left;">Silicon Labs intends to provide customers with the latest, accurate, and in-depth documentation of all peripherals and modules available for system and software implementers using or intending to use the Silicon Labs products. Characterization data, available modules and peripherals, memory sizes and memory addresses refer to</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><span><img width="771" height="49" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_029.png"/></span></p><p class="s27" style="padding-top: 1pt;padding-bottom: 1pt;padding-left: 6pt;text-indent: 0pt;line-height: 114%;text-align: left;">of use of the information supplied in this document. This document does not imply or expressly grant any license to design or fabricate any integrated circuits. The products are not designed or authorized to be used within any FDA Class III devices, applications for which FDA premarket approval is required, or Life Support Systems</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><span><img width="745" height="23" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_030.png"/></span></p><p class="s27" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;line-height: 114%;text-align: left;">products shall under no circumstances be used in weapons of mass destruction including (but not limited to) nuclear, biological or chemical weapons, or missiles capable of delivering such weapons. Silicon Labs disclaims all express and implied warranties and shall not be responsible or liable for any injuries or damages related to use of a Silicon Labs product in such unauthorized applications.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Trademark Information</p><p class="s27" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;line-height: 114%;text-align: left;">Silicon Laboratories Inc.®, Silicon Laboratories®, Silicon Labs®, SiLabs® and the Silicon Labs logo®, Bluegiga®, Bluegiga Logo®, ClockBuilder®, CMEMS®, DSPLL®, EFM®, EFM32®, EFR, Ember®, Energy Micro, Energy Micro logo and combinations thereof, “the world’s most energy friendly microcontrollers”, Ember®, EZLink®, EZRadio®, EZRadioPRO®, Gecko®, Gecko OS, Gecko OS Studio, ISOmodem®, Precision32®, ProSLIC®, Simplicity Studio®, SiPHY®, Telegesis, the Telegesis Logo®, USBXpress®, Zentri, the Zentri logo and Zentri DMS, Z-Wave®, and others are trademarks or registered trademarks of Silicon Labs. ARM, CORTEX, Cortex-M3 and THUMB are trademarks or registered trademarks of ARM Holdings. Keil is a registered trademark of ARM Limited. Wi-Fi is a registered trademark of the Wi-Fi Alliance. All other products or brand names mentioned herein are trademarks of their respective holders.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="134" height="66" alt="image" src="ug391-zigbee-app-framework-dev-guide/Image_031.png"/></span></p><p class="s27" style="padding-top: 6pt;padding-left: 134pt;text-indent: 0pt;text-align: left;">Silicon Laboratories Inc. 400 West Cesar Chavez Austin, TX 78701</p><p class="s27" style="padding-left: 134pt;text-indent: 0pt;line-height: 9pt;text-align: left;">USA</p><p style="padding-top: 4pt;padding-left: 134pt;text-indent: 0pt;text-align: left;"><a href="http://www.silabs.com/" class="s28">http://www.silabs.com</a></p></body></html>
